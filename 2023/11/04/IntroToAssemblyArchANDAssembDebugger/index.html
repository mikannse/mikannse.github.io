<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>IntroToAssemblyArchANDAssembDebuggerHTB | MikannseのSekai</title><meta name="author" content="Mikannse"><meta name="copyright" content="Mikannse"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="ArchitectureAssembly Language我们与个人电脑和智能手机的大部分互动都是通过操作系统和其他应用程序完成的。这些应用程序通常使用高级语言开发，如C++，Java，Python等。我们还知道，这些设备中的每一个都有一个核心处理器，它运行所有必要的进程来执行系统和应用程序，沿着的还有随机存取存储器（RAM）、视频存储器和其他类似的组件。 然而，这些物理组件不能解释或理解高级语言">
<meta property="og:type" content="article">
<meta property="og:title" content="IntroToAssemblyArchANDAssembDebuggerHTB">
<meta property="og:url" content="http://mikannse.space/2023/11/04/IntroToAssemblyArchANDAssembDebugger/index.html">
<meta property="og:site_name" content="MikannseのSekai">
<meta property="og:description" content="ArchitectureAssembly Language我们与个人电脑和智能手机的大部分互动都是通过操作系统和其他应用程序完成的。这些应用程序通常使用高级语言开发，如C++，Java，Python等。我们还知道，这些设备中的每一个都有一个核心处理器，它运行所有必要的进程来执行系统和应用程序，沿着的还有随机存取存储器（RAM）、视频存储器和其他类似的组件。 然而，这些物理组件不能解释或理解高级语言">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg">
<meta property="article:published_time" content="2023-11-03T16:16:34.000Z">
<meta property="article:modified_time" content="2024-01-27T13:23:51.670Z">
<meta property="article:author" content="Mikannse">
<meta property="article:tag" content="网安">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="渗透测试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg"><link rel="shortcut icon" href="/img/icon.jpg"><link rel="canonical" href="http://mikannse.space/2023/11/04/IntroToAssemblyArchANDAssembDebugger/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Mikannse","link":"链接: ","source":"来源: MikannseのSekai","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'IntroToAssemblyArchANDAssembDebuggerHTB',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2024-01-27 21:23:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">70</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/yjr-1100/Photobag/githubioimg/background_4k.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="MikannseのSekai"><span class="site-name">MikannseのSekai</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">IntroToAssemblyArchANDAssembDebuggerHTB</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-03T16:16:34.000Z" title="发表于 2023-11-04 00:16:34">2023-11-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-27T13:23:51.670Z" title="更新于 2024-01-27 21:23:51">2024-01-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BD%91%E5%AE%89/">网安</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>59分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="IntroToAssemblyArchANDAssembDebuggerHTB"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h1><h2 id="Assembly-Language"><a href="#Assembly-Language" class="headerlink" title="Assembly Language"></a>Assembly Language</h2><p>我们与个人电脑和智能手机的大部分互动都是通过操作系统和其他应用程序完成的。这些应用程序通常使用高级语言开发，如C++，Java，Python等。我们还知道，这些设备中的每一个都有一个核心处理器，它运行所有必要的进程来执行系统和应用程序，沿着的还有随机存取存储器（RAM）、视频存储器和其他类似的组件。</p>
<p>然而，这些物理组件不能解释或理解高级语言，因为它们基本上只能处理<code>1</code>和<code>0</code>。这就是汇编语言的用武之地，作为一种低级语言，它可以编写处理器可以理解的直接指令。由于处理器只能处理二进制数据“即<code>1</code>和<code>0</code>”，因此人类在不参考手册的情况下与处理器交互以了解哪个十六进制代码运行哪个指令将是具有挑战性的。</p>
<p>这就是为什么低级汇编语言被建立起来的原因。通过使用汇编，开发人员可以编写人类可读的机器指令，然后将其汇编成等效的机器代码，以便处理器可以直接运行它们。这就是为什么有些人把汇编语言称为符号机器码的原因。例如，汇编代码’<code>add rax, 1</code>‘比其等效的机器外壳代码’<code>4883C001</code>‘更直观，更容易记住，并且比等效的二进制机器代码’<code>01001000 10000011 11000000 00000001</code>‘更容易记住。正如我们所看到的，没有汇编语言，编写机器指令或直接与处理器交互是非常具有挑战性的。</p>
<p>机器码通常表示为<code>Shellcode</code>，机器码字节的十六进制表示。Shellcode可以被翻译回它的汇编副本，也可以作为二进制指令直接加载到内存中执行。</p>
<h3 id="High-level-vs-Low-level"><a href="#High-level-vs-Low-level" class="headerlink" title="High-level vs. Low-level"></a>High-level vs. Low-level</h3><p>由于有不同的处理器设计，每个处理器理解不同的机器指令集和不同的汇编语言。在过去，应用程序必须为每个处理器编写汇编，因此为多个处理器开发应用程序并不容易。在20世纪70年代早期，高级语言（如<code>C</code>）被开发出来，使编写一个简单易懂的代码成为可能，这些代码可以在任何处理器上工作，而无需为每个处理器重写。更具体地说，这是通过为每种语言创建编译器来实现的。</p>
<p>当高级代码被编译时，它被翻译成处理器的汇编指令，然后汇编成机器代码在处理器上运行。这就是为什么编译器是为各种语言和各种处理器构建的，以将高级代码转换为汇编代码，然后转换为与运行的处理器匹配的机器代码。</p>
<p>后来，解释型语言被开发出来，比如<code>Python</code>、<code>PHP</code>、<code>Bash</code>、<code>JavaScript</code>和其他语言，它们通常不被编译，而是在运行时被解释。这些类型的语言利用预构建的库来运行它们的指令。这些库通常是用其他高级语言（如<code>C</code>或<code>C++</code>）编写和编译的。因此，当我们用解释语言发出命令时，它将使用编译库来运行该命令，该命令使用其汇编代码/机器代码来执行在处理器上运行该命令所需的所有指令。</p>
<h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><p><img src="https://academy.hackthebox.com/storage/modules/85/assembly_Compilation_Stages_1.jpg" alt="Compilation Stages"></p>
<p>让我们以一个基本的’<code>Hello World!</code>‘程序为例，它将这些单词打印在屏幕上，并展示它如何从高级代码变为机器代码。在解释型语言（如Python）中，它将是以下基本行：</p>
<p>Code: </p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello World!"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>如果我们运行这行Python代码，它实际上会执行以下<code>C</code>代码：</p>
<p>Code: 验证码： cC</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"Hello World!"</span>, <span class="number">12</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意：实际的<code>C</code>源代码要长得多，但以上是字符串’<code>Hello World!</code>‘打印的本质。如果你有兴趣了解更多，你可以在这个<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/0332e569c12d3dc97171546c6dc10e42c27de34b/Python/bltinmodule.c#L1829">链接</a>和这个<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/9975cc5008c795e069ce11e2dbed2110cc12e74e/Objects/fileobject.c#L119">链接</a>上查看Python 3 print函数的源代码。</p>
<p>上面的<code>C</code>代码使用了Linux <code>write</code>系统调用，它内置了进程写入屏幕的功能。在Assembly中调用的相同系统调用如下所示：</p>
<p>Code: </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mov rax, 1</span><br><span class="line">mov rdi, 1</span><br><span class="line">mov rsi, message</span><br><span class="line">mov rdx, 12</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">mov rax, 60</span><br><span class="line">mov rdi, 0</span><br><span class="line">syscall</span><br></pre></td></tr></tbody></table></figure>

<p>正如我们所看到的，当在<code>write</code>或Assembly中调用<code>C</code>系统调用时，两者都使用<code>1</code>，文本和<code>12</code>作为参数。这将在本模块的后面部分进行更深入的介绍。从这一点来看，汇编代码、shellcode和二进制机器代码基本上是相同的，但格式不同。前面的汇编代码可以被汇编成下面的十六进制机器代码（即，shellcode）：</p>
<p>Code: </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">48 c7 c0 01</span><br><span class="line">48 c7 c7 01</span><br><span class="line">48 8b 34 25</span><br><span class="line">48 c7 c2 0d</span><br><span class="line">0f 05</span><br><span class="line"></span><br><span class="line">48 c7 c0 3c</span><br><span class="line">48 c7 c7 00</span><br><span class="line">0f 05</span><br></pre></td></tr></tbody></table></figure>

<p>最后，为了让处理器执行链接到这台机器的指令，它必须被翻译成二进制，看起来像下面这样：</p>
<p>Code: 验证码： binary二进制</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">01001000 11000111 11000000 00000001</span><br><span class="line">01001000 11000111 11000111 00000001</span><br><span class="line">01001000 10001011 00110100 00100101</span><br><span class="line">01001000 11000111 11000010 00001101 </span><br><span class="line">00001111 00000101</span><br><span class="line"></span><br><span class="line">01001000 11000111 11000000 00111100 </span><br><span class="line">01001000 11000111 11000111 00000000 </span><br><span class="line">00001111 00000101</span><br></pre></td></tr></tbody></table></figure>

<p>CPU对<code>1</code>和<code>0</code>使用不同的电荷，因此一旦它接收到这些指令，就可以从二进制数据中计算出这些指令。</p>
<p>注意：对于多平台语言，如<code>Java</code>，代码被编译成Java字节码，这对所有处理器/系统都是相同的，然后由本地Java编译环境编译成机器码。<em>这就是为什么Java比其他直接编译成机器码的语言（如C++）相对较慢的原因。像C++这样的语言更适合处理器密集型应用程序，如游戏。</em></p>
<p>我们现在看到了计算机语言是如何从每个处理器唯一的汇编语言发展到甚至不需要编译就可以在任何设备上工作的高级语言的。</p>
<h3 id="Value-for-Pentesters-Pentesters的价值"><a href="#Value-for-Pentesters-Pentesters的价值" class="headerlink" title="Value for Pentesters Pentesters的价值"></a>Value for Pentesters Pentesters的价值</h3><p>理解汇编语言指令对于二进制开发至关重要，二进制开发是渗透测试的重要组成部分。当涉及到利用编译程序时，攻击它们的唯一方法就是通过它们的二进制文件。要反汇编、调试和跟踪内存中的二进制指令并找到潜在的漏洞，我们必须对汇编语言及其如何流经CPU组件有基本的了解。</p>
<p>这就是为什么一旦我们开始学习二进制利用技术，如缓冲区溢出，ROP链，堆利用等，我们将处理大量汇编指令并在内存中遵循它们。此外，要利用这些漏洞，我们必须构建自定义漏洞，使用汇编指令在内存中操作代码并注入要执行的汇编外壳代码。</p>
<p>学习英特尔x86汇编语言对于在现代机器上编写二进制文件的漏洞至关重要。除了Intel x86之外，ARM也变得越来越普遍，因为大多数现代智能手机和一些现代笔记本电脑（如M1 MacBook  Pro）都配备了ARM处理器。在这些系统中利用二进制文件需要ARM汇编知识。本模块不包括ARM汇编语言。话虽如此，汇编语言基础无疑对任何愿意学习ARM汇编的人都有帮助，因为这两种语言有很多相似之处。</p>
<h2 id="Computer-Architecture"><a href="#Computer-Architecture" class="headerlink" title="Computer Architecture"></a>Computer Architecture</h2><p>今天，大多数现代计算机都是建立在所谓的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Von_Neumann_architecture">冯·诺依曼体系结构</a>上的，该体系结构是由<code>Von Neumann</code>在1945年开发的，以便能够创建“通用计算机”，正如<code>Alan Turing</code>当时所描述的那样。<code>Alan Turing</code>反过来，他的想法基于<code>Charles Babbage</code>的世纪中期的“可编程计算机”概念。请注意，所有这些人都是数学家。</p>
<p>该架构执行机器代码以执行特定算法。它主要包括以下几个要素：</p>
<ul>
<li>Central Processing Unit (CPU)</li>
<li>Memory Unit</li>
<li>Input/Output Devices</li>
<li>Mass Storage Unit</li>
<li>Keyboard</li>
<li>Display</li>
</ul>
<p>此外，CPU本身由三个主要组件组成：</p>
<ul>
<li>Control Unit (CU)</li>
<li>Arithmetic/Logic Unit (ALU)</li>
<li>Registers</li>
</ul>
<p><img src="https://academy.hackthebox.com/storage/modules/85/von_neumann_arch.jpg" alt="Von Neumann Architecture"></p>
<p>虽然非常古老，但这种架构仍然是大多数现代计算机，服务器甚至智能手机的基础。</p>
<p>汇编语言主要处理CPU和内存。这就是为什么理解计算机体系结构的总体设计至关重要，所以当我们开始使用汇编指令来移动和处理数据时，我们知道它从哪里来，以及每条指令的速度/成本有多高。</p>
<p>此外，基本和高级的二进制开发需要对计算机体系结构有正确的理解。对于基本的堆栈溢出，我们只需要知道一般的设计。一旦我们开始使用ROP和Heap漏洞，我们的理解应该是深刻的。现在让我们更深入地研究一些基本组成部分。</p>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>计算机的内存是当前运行程序的数据和指令所在的地方。计算机的内存也被称为主内存。它是CPU用来检索和处理数据的主要位置。它非常频繁地这样做（每秒数十亿次），因此内存必须在存储和检索数据和指令时非常快。</p>
<p>There are two main types of memory</p>
<ol>
<li><code>Cache</code></li>
<li><code>Random Access Memory (RAM)</code></li>
</ol>
<h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p>高速缓存通常位于CPU本身，因此与RAM相比速度非常快，因为它以与CPU相同的时钟速度运行。然而，它的尺寸非常有限，非常复杂，并且由于它非常接近CPU核心而制造成本昂贵。</p>
<p>由于RAM的时钟速度通常比CPU内核慢得多，除了它远离CPU之外，如果CPU必须等待RAM来检索每个指令，它将有效地以低得多的时钟速度运行。这是高速缓存的主要优点。它使CPU能够比从RAM中检索更快地访问即将到来的指令和数据。</p>
<p>通常有三个级别的缓存内存，这取决于它们与CPU核心的接近程度：</p>
<table>
<thead>
<tr>
<th><strong>Level</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>Level 1 Cache</code></td>
<td>Usually in kilobytes, the fastest memory available, located in each CPU core. (Only registers are faster.)</td>
</tr>
<tr>
<td><code>Level 2 Cache</code></td>
<td>Usually in megabytes, extremely fast (but slower than L1), shared between all CPU cores.通常以兆字节为单位，非常快（但比L1慢），在所有CPU内核之间共享。</td>
</tr>
<tr>
<td><code>Level 3 Cache</code> <code>Level 1 Cache</code></td>
<td>Usually in megabytes (larger than L2), faster than RAM but slower than L1/L2. (Not all CPUs use L3.)</td>
</tr>
</tbody></table>
<h4 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h4><p>RAM比高速缓存大得多，大小从千兆字节到兆兆字节不等。RAM也位于远离CPU核心的位置，并且比缓存慢得多。从RAM地址读取数据需要更多的指令。</p>
<p>例如，从寄存器中检索一条指令只需要一个时钟周期，从L1缓存中检索它需要几个周期，而从RAM中检索它需要大约200个周期。当每秒执行数十亿次时，它会在整体执行速度上产生巨大的差异。</p>
<p>在过去，对于32位地址，存储器地址被限制在<code>0x00000000</code>到<code>0xffffffff</code>之间。这意味着最大可能的RAM大小是232字节，也就是只有4GB，此时我们将用完唯一地址。使用64位地址，范围现在达到<code>0xffffffffffffffff</code>，理论上最大RAM大小为264字节，约为18.5艾字节（1850万TB），因此我们应该不会很快用完内存地址。</p>
<p><img src="https://academy.hackthebox.com/storage/modules/85/memory_structure.jpg" alt="img"></p>
<p>当一个程序运行时，它的所有数据和指令都从存储单元移动到RAM，以便CPU在需要时访问。这是因为从存储单元访问它们要慢得多，并且会增加数据处理时间。当程序关闭时，其数据将从RAM中删除或重新使用。</p>
<p>正如我们所看到的，RAM分为四个主要的<code>segments</code>：</p>
<table>
<thead>
<tr>
<th>Segment</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Stack</code> <code>Level 1 Cache</code></td>
<td>有后进先出（LIFO）设计，大小固定。其中的数据只能通过推送和弹出数据以特定的顺序访问。</td>
</tr>
<tr>
<td><code>Heap</code> <code>Level 1 Cache</code></td>
<td>具有分层设计，因此在存储数据方面更大，更通用，因为数据可以以任何顺序存储和检索。然而，这使得堆比堆栈慢。</td>
</tr>
<tr>
<td><code>Data</code> <code>Level 1 Cache</code></td>
<td>有两个部分：<code>Data</code>，用于保存变量，<code>.bss</code>，用于保存未赋值的变量（即，用于以后分配的缓冲存储器）。</td>
</tr>
<tr>
<td><code>Text</code> <code>Level 1 Cache</code></td>
<td>主汇编指令被加载到这个段中，由CPU获取和执行。</td>
</tr>
</tbody></table>
<p>尽管这种分段适用于整个RAM，但<code>each application is allocated its Virtual Memory when it is run</code>。这意味着每个应用程序都有自己的<code>stack</code>、<code>heap</code>、<code>data</code>和<code>text</code>段。</p>
<h3 id="IO-x2F-Storage-IO-x2F-存储"><a href="#IO-x2F-Storage-IO-x2F-存储" class="headerlink" title="IO/Storage IO/存储"></a>IO/Storage IO/存储</h3><p>最后，我们有输入/输出设备，如键盘，屏幕或长期存储单元，也称为辅助存储器。处理器可以使用<code>Bus Interfaces</code>访问和控制IO设备，这些设备充当传输数据和地址的“高速公路”，使用二进制数据的电荷。</p>
<p>每条总线都有一个可以同时承载的比特（或电荷）容量。这通常是4位的倍数，范围高达128位。总线接口通常也用于访问内存和CPU本身之外的其他组件。如果我们仔细观察CPU或主板，我们可以看到它们上面的总线接口：</p>
<p><img src="https://academy.hackthebox.com/storage/modules/85/cpu_bus.jpg" alt="bus"></p>
<p>与易失性的主存储器不同，存储单元存储永久数据，如操作系统文件或整个应用程序及其数据。</p>
<p>存储单元访问速度最慢。首先，因为它们离CPU最远，通过SATA或USB等总线接口访问它们需要更长的时间来存储和检索数据。它们在设计上也较慢，以允许更多的数据存储。只要有更多的数据要通过，它们就会慢一些。</p>
<p>近年来，已经从传统的磁性存储单元（如磁带或硬盘驱动器（HDD））转向固态驱动器（SSD）。这是因为SSD使用与RAM类似的设计，使用非易失性电路，即使没有电力也可以保留数据。这使得存储单元在存储和检索数据时更快。尽管如此，由于它们远离CPU并通过特殊接口连接，它们是访问速度最慢的单元。</p>
<h3 id="Speed-速度"><a href="#Speed-速度" class="headerlink" title="Speed 速度"></a>Speed 速度</h3><p>从上面可以看出，组件离CPU核心越远，它就越慢。此外，它可以容纳的数据越多，它就越慢，因为它只需要通过更多的数据来获取数据。下表总结了每个组件及其大小和速度：</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Speed</th>
<th>Size</th>
</tr>
</thead>
<tbody><tr>
<td><code>Registers</code> <code>Level 1 Cache</code></td>
<td>Fastest</td>
<td>Bytes</td>
</tr>
<tr>
<td><code>L1 Cache</code> <code>Level 1 Cache</code></td>
<td>Fastest, other than Registers</td>
<td>Kilobytes</td>
</tr>
<tr>
<td><code>L2 Cache</code> <code>Level 1 Cache</code></td>
<td>Very fast</td>
<td>Megabytes</td>
</tr>
<tr>
<td><code>L3 Cache</code> <code>Level 1 Cache</code></td>
<td>Fast, but slower than the above</td>
<td>Megabytes</td>
</tr>
<tr>
<td><code>RAM</code> <code>Level 1 Cache</code></td>
<td>Much slower than all of the above</td>
<td>Gigabytes-Terabytes</td>
</tr>
<tr>
<td><code>Storage</code> <code>Level 1 Cache</code></td>
<td>Slowest</td>
<td>Terabytes and more</td>
</tr>
</tbody></table>
<p>这里的速度是相对的，取决于CPU的时钟速度。现在我们对计算机体系结构有了一个大致的了解，我们将在下一节讨论寄存器和CPU体系结构。</p>
<h2 id="CPU-Architecture"><a href="#CPU-Architecture" class="headerlink" title="CPU Architecture"></a>CPU Architecture</h2><p>中央处理器（CPU）是计算机中的主要处理单元。CPU包含负责移动和控制数据的<code>Control Unit</code>（CU）和负责执行程序通过汇编指令请求的各种算术和逻辑计算的<code>Arithmetic/Logic Unit</code>（ALU）。</p>
<p>CPU处理指令的方式和效率取决于它的<code>Instruction Set Architecture</code>。行业中有多种ISA，每种ISA都有其处理数据的方式。<code>RISC</code>架构基于处理更简单的指令，这需要更多的周期，但每个周期更短，功耗更低。<code>CISC</code>架构基于更少、更复杂的指令，可以在更少的周期内完成所请求的指令，但每条指令需要更多的时间和功率来处理。</p>
<p>让我们看看<code>RISC</code>和<code>CISC</code>，并了解更多关于指令周期和寄存器的信息。</p>
<h3 id="Clock-Speed-amp-Clock-Cycle"><a href="#Clock-Speed-amp-Clock-Cycle" class="headerlink" title="Clock Speed &amp; Clock Cycle"></a>Clock Speed &amp; Clock Cycle</h3><p>每个CPU都有一个时钟速度来表示其整体速度。时钟的每一个滴答都运行一个时钟周期，处理一条基本指令，如获取地址或存储地址。具体来说，这是由CU或ALU完成的。</p>
<p>循环发生的频率被计数为每秒循环（<code>Hertz</code>）。如果CPU的速度为3.0 GHz，则每秒可以运行30亿个周期（每个核心）。</p>
<p><img src="https://academy.hackthebox.com/storage/modules/85/assembly_clock_cycle_0.jpg" alt="instruction cycle"></p>
<p>现代处理器具有多核设计，允许它们同时具有多个周期。</p>
<h3 id="Instruction-Cycle"><a href="#Instruction-Cycle" class="headerlink" title="Instruction Cycle"></a>Instruction Cycle</h3><p><code>Instruction Cycle</code>是CPU处理单个机器指令所需的周期。</p>
<p><img src="https://academy.hackthebox.com/storage/modules/85/assembly_instruction_cycle.jpg" alt="instruction cycle"></p>
<p>一个指令周期由四个阶段组成：<code>Fetch</code>、<code>Decode</code>、<code>Execute</code>和<code>Store</code>：</p>
<table>
<thead>
<tr>
<th><strong>Instruction</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>1. Fetch</code> <code>3. Execute</code></td>
<td>从<code>Instruction Address Register</code>（IAR）中获取下一条指令的地址，该地址告诉它下一条指令的位置。</td>
</tr>
<tr>
<td><code>2. Decode</code></td>
<td>从IAR获取指令，并将其从二进制解码，以查看需要执行的内容。</td>
</tr>
<tr>
<td><code>3. Execute</code></td>
<td>从寄存器/存储器中获取指令操作数，并在<code>ALU</code>或<code>CU</code>中处理指令。</td>
</tr>
<tr>
<td><code>4. Store</code> <code>3. Execute</code></td>
<td>将新值存储在目标操作数中。</td>
</tr>
</tbody></table>
<p>指令周期中的所有阶段都由控制单元执行，除非需要执行算术指令“加、减、.”。等等”，由ALU执行。 </p>
<p>每个指令周期需要多个时钟周期才能完成，具体取决于CPU架构和指令的复杂性。一旦单个指令周期结束，CU递增到下一个指令并对其运行相同的周期，依此类推。</p>
<p><img src="https://academy.hackthebox.com/storage/modules/85/assembly_clock_cycle_1.jpg" alt="instruction cycle"></p>
<p>例如，如果我们要执行汇编指令<code>add rax, 1</code>，它将运行一个指令周期：</p>
<ol>
<li>从<code>rip</code>寄存器<code>48 83 C0 01</code>（二进制）中获取指令。</li>
<li>解码“<code>48 83 C0 01</code>”以知道它需要对<code>add</code>处的值执行<code>1</code>的<code>rax</code>。</li>
<li>在<code>rax</code>（通过<code>CU</code>）获得当前值，将<code>1</code>添加到它（通过<code>ALU</code>）。</li>
<li>将新值存储回<code>rax</code>。</li>
</ol>
<p>在过去，处理器习惯于顺序处理指令，因此它们必须等待一条指令完成才能开始下一条指令。另一方面，现代处理器可以通过同时运行多个指令/时钟周期来并行处理多个指令。这是通过多线程和多核设计实现的。</p>
<p><img src="https://academy.hackthebox.com/storage/modules/85/assembly_clock_cycle_2.jpg" alt="instruction cycle"></p>
<h3 id="Processor-Specific"><a href="#Processor-Specific" class="headerlink" title="Processor Specific"></a>Processor Specific</h3><p>如前所述，每个处理器理解不同的指令集。例如，虽然基于64位x86架构的Intel处理器可以将机器代码<code>4883C001</code>解释为<code>add rax, 1</code>，但是ARM处理器将相同的机器代码翻译为<code>biceq r8, r0, r8, asr #6</code>指令。正如我们所看到的，相同的机器代码在每个处理器上执行完全不同的指令。</p>
<p>这是因为每种处理器类型都有不同的低级汇编语言架构，称为<code>Instruction Set Architectures</code>ISA。例如，上面看到的add指令<code>add rax, 1</code>用于Intel x86 64位处理器。为ARM处理器汇编语言编写的相同指令表示为<code>add r1, r1, 1</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">It is important to understand that each processor has its own set of instructions and corresponding machine code.</span><br></pre></td></tr></tbody></table></figure>

<p>此外，单个指令集架构可以具有用于相同汇编代码的若干语法解释。例如，上面的<code>add</code>指令基于x86架构，其由多个处理器（如Intel、AMD和传统AT T处理器）支持。该指令使用Intel语法编写为<code>add rax, 1</code>，使用AT T语法编写为<code>addb $0x1,%rax</code>。</p>
<p>正如我们所看到的，尽管我们可以看出这两条指令是相似的，并且做同样的事情，但它们的语法是不同的，并且源操作数和目标操作数的位置也被交换了。尽管如此，这两种代码汇编相同的机器码并执行相同的指令。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">So, each processor type has its Instruction Set Architectures,  and each architecture can be further represented in several syntax  formats</span><br></pre></td></tr></tbody></table></figure>

<p>本模块将主要关注英特尔x86 64位汇编语言（也称为x86_64和AMD 64），因为大多数现代计算机和服务器都运行在这种处理器架构上。我们也将使用Intel语法。</p>
<p>如果我们想知道我们的Linux系统是否支持<code>x86_64</code>架构，我们可以使用<code>lscpu</code>命令：                           </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mikannse7@htb[/htb]$ lscpu</span><br><span class="line"></span><br><span class="line">Architecture:                    x86_64</span><br><span class="line">CPU op-mode(s):                  32-bit, 64-bit</span><br><span class="line">Byte Order:                      Little Endian</span><br><span class="line"></span><br><span class="line">&lt;SNIP&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>正如我们在上面的输出中所看到的，CPU架构是<code>x86_64</code>，支持32位和64位。字节顺序是小端。我们也可以使用<code>uname -m</code>命令来获取CPU架构。我们将在下一节讨论两种最常见的指令集架构：<code>CISC</code>和<code>RISC</code>。</p>
<h2 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h2><p><code>Instruction Set Architecture</code>（<code>ISA</code>）指定了每个体系结构上汇编语言的语法和语义。它不仅仅是一种不同的语法，而是内置在处理器的核心设计中，因为它影响指令执行的方式和顺序以及它们的复杂程度。<code>ISA</code>主要由以下组件组成：</p>
<ul>
<li>Instructions</li>
<li>Registers</li>
<li>Memory Addresses</li>
<li>Data Types</li>
</ul>
<table>
<thead>
<tr>
<th>Component</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td><code>Instructions</code></td>
<td>要以<code>opcode operand_list</code>格式处理的指令。通常有1、2或3个逗号分隔的操作数。</td>
<td><code>add rax, 1</code>, <code>mov rsp, rax</code>, <code>push rax</code> <code>add rax, 1</code>、<code>mov rsp, rax</code>、<code>push rax</code></td>
</tr>
<tr>
<td><code>Registers</code></td>
<td>用于临时存储操作数、地址或指令。</td>
<td><code>rax</code>, <code>rsp</code>, <code>rip</code> <code>rax</code>、<code>rsp</code>、<code>rip</code></td>
</tr>
<tr>
<td><code>Memory Addresses</code></td>
<td>存储数据或指令的地址。可能指向内存或寄存器。</td>
<td><code>0xffffffffaa8a25ff</code>, <code>0x44d0</code>, <code>$rax</code> <code>0xffffffffaa8a25ff</code>、<code>0x44d0</code>、<code>$rax</code></td>
</tr>
<tr>
<td><code>Data Types</code></td>
<td>存储数据的类型。</td>
<td><code>byte</code>, <code>word</code>, <code>double word</code> <code>byte</code>、<code>word</code>、<code>double word</code></td>
</tr>
</tbody></table>
<p>这些是区分不同ISA和汇编语言的主要组件。我们将在接下来的章节中更深入地介绍它们中的每一个，并学习如何使用各种指令。</p>
<p>有两种主要的指令集架构被广泛使用：</p>
<ol>
<li><code>Complex Instruction Set Computer</code>（<code>CISC</code>）-用于大多数计算机和服务器的<code>Intel</code>和<code>AMD</code>处理器。</li>
<li><code>Reduced Instruction Set Computer</code>（<code>RISC</code>）-用于<code>ARM</code>和<code>Apple</code>处理器，大多数智能手机和一些现代笔记本电脑。</li>
</ol>
<p>让我们看看每一个的优点和缺点，以及它们之间的主要区别。</p>
<h3 id="CISC"><a href="#CISC" class="headerlink" title="CISC"></a>CISC</h3><p>CISC架构是ISA最早开发的架构之一。顾名思义，CISC体系结构倾向于一次运行更复杂的指令，以减少指令的总数。这样做是为了尽可能多地依赖于CPU，将次要指令组合成更复杂的指令。</p>
<p>例如，假设我们要用“<code>add rax, rbx</code>”指令添加两个寄存器。在这种情况下，CISC处理器可以在单个“Fetch-Decode-Execute-Store”指令周期中完成此操作，而不必将其拆分为多个指令来获取<code>rax</code>，然后获取<code>rbx</code>，然后将它们添加，然后将它们存储在“rax”中，每个指令都将占用自己的“Fetch-Decode-Execute-Store”指令周期。</p>
<p>主要有两个原因：</p>
<ol>
<li>通过将处理器设计为在其核心中运行更高级的指令，使更多的指令能够同时执行。</li>
<li>在过去，内存和晶体管是有限的，所以更倾向于通过将多条指令合并为一条来编写较短的程序。</li>
</ol>
<p>为了使处理器能够执行复杂的指令，处理器的设计变得更加复杂，因为它被设计为执行大量不同的复杂指令，每个复杂指令都有自己的单元来执行它。</p>
<p>此外，尽管执行单个指令需要单个指令周期，但是由于指令更复杂，每个指令周期需要更多的时钟周期。这一事实导致更多的功耗和热量来执行每个指令。</p>
<h3 id="RISC"><a href="#RISC" class="headerlink" title="RISC"></a>RISC</h3><p>RISC架构倾向于将指令分割成小指令，因此CPU仅被设计为处理简单指令。这样做是为了通过编写最优化的汇编代码将优化传递给软件。</p>
<p>例如，RISC处理器上的相同的前一个<code>add r1, r2, r3</code>指令将获取<code>r2</code>，然后获取<code>r3</code>，将它们相加，最后将它们存储在<code>r1</code>中。这些指令中的每一条都需要一个完整的“提取-解码-执行-存储”指令周期，这导致每个程序的总指令数更大，因此汇编代码更长。</p>
<p>由于不支持各种类型的复杂指令，与CISC处理器（<code>~200</code>）相比，RISC处理器只支持有限数量的指令（<code>~1500</code>）。因此，要执行复杂的指令，这必须通过汇编的次要指令组合来完成。</p>
<p>据说我们可以用一个只支持一条指令的处理器来建造一台通用计算机！这表明我们可以只使用<code>sub</code>指令来创建非常复杂的指令。你能想到如何实现这一点吗？</p>
<p>另一方面，将复杂指令分割成次要指令的优点是使所有指令的长度相同，或者是32位，或者是64位。这使得CPU的时钟速度能够围绕指令长度进行设计，以便执行指令周期中的每个阶段总是精确地占用一个机器时钟周期。</p>
<p>下图显示了CISC指令如何占用可变数量的时钟周期，而RISC指令占用固定数量的时钟周期： <img src="https://academy.hackthebox.com/storage/modules/85/assembly_cisc_risk_cycles.jpg" alt="risc vs cisc cycles"></p>
<p>在单个时钟周期内执行每个指令阶段，并且只执行简单的指令，导致RISC处理器消耗CISC处理器所消耗的一小部分功率，这使得这些处理器非常适合使用电池运行的设备，如智能手机和笔记本电脑。</p>
<h3 id="CISC-vs-RISC"><a href="#CISC-vs-RISC" class="headerlink" title="CISC vs. RISC"></a>CISC vs. RISC</h3><p>下表总结了CISC和RISC之间的主要区别：</p>
<table>
<thead>
<tr>
<th>Area区域</th>
<th>CISC</th>
<th>RISC</th>
</tr>
</thead>
<tbody><tr>
<td><code>Complexity</code> <code>Instructions</code></td>
<td>支持复杂指令</td>
<td>支持简单指令</td>
</tr>
<tr>
<td><code>Length of instructions</code> <code>Instructions</code></td>
<td>更长的指令-可变长度“8位的倍数”</td>
<td>更短的指令-固定长度“32位/64位”</td>
</tr>
<tr>
<td><code>Total instructions per program</code> <code>Instructions</code></td>
<td>指令总数更少-代码更短</td>
<td>更多总指令-更长的代码</td>
</tr>
<tr>
<td><code>Optimization</code> <code>Instructions</code></td>
<td>依赖于硬件优化（在CPU中）</td>
<td>依赖于软件优化（在装配中）</td>
</tr>
<tr>
<td><code>Instruction Execution Time</code> <code>Instructions</code></td>
<td>变量-多个时钟周期</td>
<td>固定-一个时钟周期</td>
</tr>
<tr>
<td><code>Instructions supported by CPU</code> <code>Instructions</code></td>
<td>许多指令（~1500）</td>
<td>更少的指令（~200）</td>
</tr>
<tr>
<td><code>Power Consumption</code> <code>Instructions</code></td>
<td>High</td>
<td>Very low</td>
</tr>
<tr>
<td><code>Examples</code> <code>Instructions</code></td>
<td>Intel, AMD</td>
<td>ARM, Apple</td>
</tr>
</tbody></table>
<p>在过去，由于每个程序的总指令数量较多，因此汇编代码较长，这对于RISC处理器来说是一个显著的缺点，因为内存和存储资源有限。然而，今天这不再是一个大问题，因为内存和存储不像过去那样昂贵和有限。</p>
<p>此外，随着新的汇编器和编译器在软件层面上编写极其优化的代码，RISC处理器变得比CISC处理器更快，即使在执行和处理繁重的应用程序时，所有这些都消耗更少的功率。</p>
<p>所有这些都使得RISC处理器在近年来更加普遍。RISC可能在未来几年成为主导架构。但正如我们所说，我们将测试的绝大多数计算机和服务器都运行在具有CISC架构的英特尔/AMD处理器上，因此学习CISC组装是我们的首要任务。由于所有汇编语言变体的基础都非常相似，因此在完成本模块后，学习ARM汇编应该会更加简单。</p>
<h2 id="Registers-Addresses-and-Data-Types"><a href="#Registers-Addresses-and-Data-Types" class="headerlink" title="Registers, Addresses, and Data Types"></a>Registers, Addresses, and Data Types</h2><p>现在我们已经了解了通用计算机和处理器架构，在开始学习汇编之前，我们需要了解一些汇编元素：<code>Registers</code>，<code>Memory Addresses</code>，<code>Address Endianness</code>和<code>Data Types</code>。这些元素中的每一个都很重要，正确理解它们将帮助我们在编写和调试汇编代码时避免问题和故障排除时间。</p>
<h3 id="Registers"><a href="#Registers" class="headerlink" title="Registers"></a>Registers</h3><p>如前所述，每个CPU内核都有一组寄存器。寄存器是任何计算机中最快的组件，因为它们内置在CPU内核中。然而，寄存器的大小非常有限，一次只能保存几个字节的数据。x86架构中有很多寄存器，但我们只关注学习基本汇编所必需的寄存器，以及未来二进制开发所必需的寄存器。</p>
<p>我们将重点关注两种主要类型的寄存器：<code>Data Registers</code>和<code>Pointer Registers</code>。</p>
<table>
<thead>
<tr>
<th><strong>Data Registers</strong></th>
<th><strong>Pointer Registers</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>rax</code></td>
<td><code>rbp</code></td>
</tr>
<tr>
<td><code>rbx</code></td>
<td><code>rsp</code></td>
</tr>
<tr>
<td><code>rcx</code></td>
<td><code>rip</code></td>
</tr>
<tr>
<td><code>rdx</code></td>
<td></td>
</tr>
<tr>
<td><code>r8</code></td>
<td></td>
</tr>
<tr>
<td><code>r9</code></td>
<td></td>
</tr>
<tr>
<td><code>r10</code></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><code>Data Registers</code> -通常用于存储指令/系统调用参数。主数据寄存器为：<code>rax</code>、<code>rbx</code>、<code>rcx</code>和<code>rdx</code>。<code>rdi</code>和<code>rsi</code>寄存器也存在，通常用于指令<code>destination</code>和<code>source</code>操作数。然后，我们有辅助数据寄存器，可以在所有先前的寄存器都在使用时使用，它们是<code>r8</code>、<code>r9</code>和<code>r10</code>。</li>
<li><code>Pointer Registers</code> -用于存储特定的重要地址指针。主指针寄存器是指向堆栈开始的基本堆栈指针<code>rbp</code>、指向堆栈内的当前位置（堆栈顶部）的当前堆栈指针<code>rsp</code>以及保存下一指令的地址的指令指针<code>rip</code>。</li>
</ul>
<h3 id="Sub-Registers"><a href="#Sub-Registers" class="headerlink" title="Sub-Registers"></a>Sub-Registers</h3><p>每个<code>64-bit</code>寄存器可以进一步划分为包含低位的更小的子寄存器，在一个字节<code>8-bits</code>、2个字节<code>16-bits</code>和4个字节<code>32-bits</code>。每个子寄存器都可以单独使用和访问，因此如果数据量较少，我们不必使用全部64位。</p>
<p><img src="https://academy.hackthebox.com/storage/modules/85/assembly_register_parts.jpg" alt="register parts"></p>
<p>子寄存器可以通过以下方式访问：</p>
<table>
<thead>
<tr>
<th>Size in bits</th>
<th>Size in bytes</th>
<th>Name</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td><code>16-bit</code> <code>rcx</code></td>
<td><code>2 bytes</code> <code>rcx</code></td>
<td>the base name</td>
<td><code>ax</code> <code>rcx</code></td>
</tr>
<tr>
<td><code>8-bit</code> <code>rcx</code></td>
<td><code>1 bytes</code> <code>rcx</code></td>
<td>base name and/or ends with <code>l</code></td>
<td><code>al</code> <code>rcx</code></td>
</tr>
<tr>
<td><code>32-bit</code> <code>rcx</code></td>
<td><code>4 bytes</code> <code>rcx</code></td>
<td>base name + starts with the <code>e</code> prefix</td>
<td><code>eax</code> <code>rcx</code></td>
</tr>
<tr>
<td><code>64-bit</code> <code>rcx</code></td>
<td><code>8 bytes</code> <code>rcx</code></td>
<td>base name + starts with the <code>r</code> prefix</td>
<td><code>rax</code> <code>rcx</code></td>
</tr>
</tbody></table>
<p>例如，对于<code>bx</code>数据寄存器，16位为<code>bx</code>，因此8位为<code>bl</code>，32位为<code>ebx</code>，64位为<code>rbx</code>。指针寄存器也是如此。如果我们取基本堆栈指针<code>bp</code>，它的16位子寄存器是<code>bp</code>，因此8位是<code>bpl</code>，32位是<code>ebp</code>，64位是<code>rbp</code>。</p>
<p>以下是x86_64架构中所有基本寄存器的子寄存器名称：</p>
<table>
<thead>
<tr>
<th>Description</th>
<th>64-bit Register64</th>
<th>32-bit Register32</th>
<th>16-bit Register16</th>
<th>8-bit Register8-</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Data/Arguments Registers</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Syscall Number/Return value</td>
<td><code>rax</code> <code>rcx</code></td>
<td><code>eax</code> <code>rcx</code></td>
<td><code>ax</code> <code>rcx</code></td>
<td><code>al</code> <code>rcx</code></td>
</tr>
<tr>
<td>Callee Saved</td>
<td><code>rbx</code> <code>rcx</code></td>
<td><code>ebx</code> <code>rcx</code></td>
<td><code>bx</code> <code>rcx</code></td>
<td><code>bl</code> <code>rcx</code></td>
</tr>
<tr>
<td>1st arg - Destination operand</td>
<td><code>rdi</code> <code>rcx</code></td>
<td><code>edi</code> <code>rcx</code></td>
<td><code>di</code> <code>rcx</code></td>
<td><code>dil</code> <code>rcx</code></td>
</tr>
<tr>
<td>2nd arg - Source operand</td>
<td><code>rsi</code> <code>rcx</code></td>
<td><code>esi</code> <code>rcx</code></td>
<td><code>si</code> <code>rcx</code></td>
<td><code>sil</code> <code>rcx</code></td>
</tr>
<tr>
<td>3rd arg</td>
<td><code>rdx</code> <code>rcx</code></td>
<td><code>edx</code> <code>rcx</code></td>
<td><code>dx</code> <code>rcx</code></td>
<td><code>dl</code> <code>rcx</code></td>
</tr>
<tr>
<td>4th arg - Loop counter4th arg</td>
<td><code>rcx</code></td>
<td><code>ecx</code> <code>rcx</code></td>
<td><code>cx</code> <code>rcx</code></td>
<td><code>cl</code> <code>rcx</code></td>
</tr>
<tr>
<td>5th arg</td>
<td><code>r8</code> <code>rcx</code></td>
<td><code>r8d</code> <code>rcx</code></td>
<td><code>r8w</code> <code>rcx</code></td>
<td><code>r8b</code> <code>rcx</code></td>
</tr>
<tr>
<td>6th arg</td>
<td><code>r9</code> <code>rcx</code></td>
<td><code>r9d</code> <code>rcx</code></td>
<td><code>r9w</code> <code>rcx</code></td>
<td><code>r9b</code> <code>rcx</code></td>
</tr>
<tr>
<td><strong>Pointer Registers</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Base Stack Pointer</td>
<td><code>rbp</code> <code>rcx</code></td>
<td><code>ebp</code> <code>rcx</code></td>
<td><code>bp</code> <code>rcx</code></td>
<td><code>bpl</code> <code>rcx</code></td>
</tr>
<tr>
<td>Current/Top Stack Pointer</td>
<td><code>rsp</code> <code>rcx</code></td>
<td><code>esp</code> <code>rcx</code></td>
<td><code>sp</code> <code>rcx</code></td>
<td><code>spl</code> <code>rcx</code></td>
</tr>
<tr>
<td>Instruction Pointer ‘call only</td>
<td><code>rip</code> <code>rcx</code></td>
<td><code>eip</code> <code>rcx</code></td>
<td><code>ip</code> <code>rcx</code></td>
<td><code>ipl</code> <code>rcx</code></td>
</tr>
</tbody></table>
<p>在学习本模块时，我们将讨论如何使用这些寄存器。</p>
<p>还有其他各种寄存器，但我们不会在本模块中介绍它们，因为它们对于基本的汇编用法来说并不需要。例如，有<code>RFLAGS</code>寄存器，用于维护CPU使用的各种标志，如零标志<code>ZF</code>，用于条件指令。</p>
<h3 id="Memory-Addresses"><a href="#Memory-Addresses" class="headerlink" title="Memory Addresses"></a>Memory Addresses</h3><p>如前所述，x86 64位处理器具有64位宽的地址，范围从<code>0x0</code>到<code>0xffffffffffffffff</code>，因此我们期望地址在此范围内。然而，RAM被分割成不同的区域，如堆栈、堆和其他程序和内核特定的区域。每个内存区域都有特定的<code>read</code>、<code>write</code>、<code>execute</code>权限，指定我们是否可以从中读取、写入或调用其中的地址。</p>
<p>每当一条指令通过指令周期被执行时，第一步是从它所在的地址获取指令，如前所述。存在几种类型的地址获取（即，寻址模式）在x86体系结构中：</p>
<table>
<thead>
<tr>
<th>Addressing Mode</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td><code>Immediate</code> <code>rcx</code></td>
<td>该值在指令中给出</td>
<td><code>add 2</code> <code>rcx</code></td>
</tr>
<tr>
<td><code>Register</code> <code>rcx</code></td>
<td>保存该值的寄存器名称在指令中给出</td>
<td><code>add rax</code> <code>rcx</code></td>
</tr>
<tr>
<td><code>Direct</code> <code>rcx</code></td>
<td>直接完整地址在指令中给出</td>
<td><code>call 0xffffffffaa8a25ff</code> <code>rcx</code></td>
</tr>
<tr>
<td><code>Indirect</code> <code>rcx</code></td>
<td>在指令中给出一个引用指针</td>
<td><code>call 0x44d000</code> or <code>call [rax]</code> <code>call 0x44d000</code>或<code>call [rax]</code></td>
</tr>
<tr>
<td><code>Stack</code> <code>rcx</code></td>
<td>地址位于堆栈顶部</td>
<td><code>add rsp</code> <code>rcx</code></td>
</tr>
</tbody></table>
<p>在上表中，越低越慢。值的即时性越低，获取它的速度就越慢。</p>
<p>尽管速度不是我们在学习基本汇编语言时最关心的问题，但我们应该了解每个地址的位置和方式。了解这些将有助于我们在未来的二进制攻击中，例如缓冲区溢出攻击。同样的理解将对高级二进制开发（如ROP或Heap开发）产生更重要的影响。</p>
<h3 id="地址Endianness"><a href="#地址Endianness" class="headerlink" title="地址Endianness"></a>地址Endianness</h3><p>地址的字节顺序是它们存储或从内存中检索的字节顺序。有两种类型的endianness：<code>Little-Endian</code>和<code>Big-Endian</code>。对于小端处理器，地址的小端字节首先填充/检索<code>right-to-left</code>，而对于大端处理器，大端字节首先填充/检索<code>left-to-right</code>。</p>
<p>例如，如果我们将地址<code>0x0011223344556677</code>存储在内存中，小端处理器将在最右边的字节上存储<code>0x00</code>字节，然后在它之后填充<code>0x11</code>字节，因此它变成<code>0x1100</code>，然后是<code>0x22</code>字节，因此它变成<code>0x221100</code>，等等。这是原始值的倒数。当然，当检索回值时，处理器也将使用little-endian检索，因此检索到的值将与原始值相同。</p>
<p>另一个显示这如何影响存储值的例子是二进制。例如，如果我们有一个2字节整数<code>426</code>，它的二进制表示是<code>00000001 10101010</code>。这两个字节的存储顺序将改变其值。例如，如果我们将其反向存储为<code>10101010 00000001</code>，则其值变为<code>43521</code>。</p>
<p>大端处理器将这些字节存储为<code>00000001 10101010``left-to-right</code>，而小端处理器将它们存储为<code>10101010 00000001``right-to-left</code>。当检索值时，处理器必须使用与存储它们时相同的字节序，否则它将得到错误的值。这表明存储/检索字节的顺序有很大的不同。</p>
<p>现在我们已经了解了通用计算机和处理器架构，在开始学习汇编之前，我们需要了解一些汇编元素：<code>Registers</code>，<code>Memory Addresses</code>，<code>Address Endianness</code>和<code>Data Types</code>。这些元素中的每一个都很重要，正确理解它们将帮助我们在编写和调试汇编代码时避免问题和故障排除时间。</p>
<h3 id="Registers-1"><a href="#Registers-1" class="headerlink" title="Registers"></a>Registers</h3><p>如前所述，每个CPU内核都有一组寄存器。寄存器是任何计算机中最快的组件，因为它们内置在CPU内核中。然而，寄存器的大小非常有限，一次只能保存几个字节的数据。x86架构中有很多寄存器，但我们只关注学习基本汇编所必需的寄存器，以及未来二进制开发所必需的寄存器。</p>
<p>我们将重点关注两种主要类型的寄存器：<code>Data Registers</code>和<code>Pointer Registers</code>。</p>
<table>
<thead>
<tr>
<th><strong>Data Registers数据寄存器</strong></th>
<th><strong>Pointer Registers指针寄存器</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>rax</code></td>
<td><code>rbp</code></td>
</tr>
<tr>
<td><code>rbx</code></td>
<td><code>rsp</code></td>
</tr>
<tr>
<td><code>rcx</code></td>
<td><code>rip</code></td>
</tr>
<tr>
<td><code>rdx</code></td>
<td></td>
</tr>
<tr>
<td><code>r8</code></td>
<td></td>
</tr>
<tr>
<td><code>r9</code></td>
<td></td>
</tr>
<tr>
<td><code>r10</code></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><code>Data Registers</code> -通常用于存储指令/系统调用参数。主数据寄存器为：<code>rax</code>、<code>rbx</code>、<code>rcx</code>和<code>rdx</code>。<code>rdi</code>和<code>rsi</code>寄存器也存在，通常用于指令<code>destination</code>和<code>source</code>操作数。然后，我们有辅助数据寄存器，可以在所有先前的寄存器都在使用时使用，它们是<code>r8</code>、<code>r9</code>和<code>r10</code>。</li>
<li><code>Pointer Registers</code> -用于存储特定的重要地址指针。主指针寄存器是指向堆栈开始的基本堆栈指针<code>rbp</code>、指向堆栈内的当前位置（堆栈顶部）的当前堆栈指针<code>rsp</code>以及保存下一指令的地址的指令指针<code>rip</code>。</li>
</ul>
<h3 id="Sub-Registers-子寄存器"><a href="#Sub-Registers-子寄存器" class="headerlink" title="Sub-Registers 子寄存器"></a>Sub-Registers 子寄存器</h3><p>每个<code>64-bit</code>寄存器可以进一步划分为包含低位的更小的子寄存器，在一个字节<code>8-bits</code>、2个字节<code>16-bits</code>和4个字节<code>32-bits</code>。每个子寄存器都可以单独使用和访问，因此如果数据量较少，我们不必使用全部64位。</p>
<p><img src="https://academy.hackthebox.com/storage/modules/85/assembly_register_parts.jpg" alt="register parts"></p>
<p>子寄存器可以通过以下方式访问：</p>
<table>
<thead>
<tr>
<th>Size in bits大小（位）</th>
<th>Size in bytes字节大小</th>
<th>Name名称</th>
<th>Example例如</th>
</tr>
</thead>
<tbody><tr>
<td><code>16-bit</code> <code>rcx</code></td>
<td><code>2 bytes</code> <code>rcx</code></td>
<td>the base name站点名称</td>
<td><code>ax</code> <code>rcx</code></td>
</tr>
<tr>
<td><code>8-bit</code> <code>rcx</code></td>
<td><code>1 bytes</code> <code>rcx</code></td>
<td>base name and/or ends with <code>l</code> 基本名称和/或以<code>l</code>结尾</td>
<td><code>al</code> <code>rcx</code></td>
</tr>
<tr>
<td><code>32-bit</code> <code>rcx</code></td>
<td><code>4 bytes</code> <code>rcx</code></td>
<td>base name + starts with the <code>e</code> prefix 基本名称+以<code>r</code>前缀开头</td>
<td><code>eax</code> <code>rcx</code></td>
</tr>
<tr>
<td><code>64-bit</code> <code>rcx</code></td>
<td><code>8 bytes</code> <code>rcx</code></td>
<td>base name + starts with the <code>r</code> prefix 基本名称+以<code>r</code>前缀开头</td>
<td><code>rax</code> <code>rcx</code></td>
</tr>
</tbody></table>
<p>例如，对于<code>bx</code>数据寄存器，16位为<code>bx</code>，因此8位为<code>bl</code>，32位为<code>ebx</code>，64位为<code>rbx</code>。指针寄存器也是如此。如果我们取基本堆栈指针<code>bp</code>，它的16位子寄存器是<code>bp</code>，因此8位是<code>bpl</code>，32位是<code>ebp</code>，64位是<code>rbp</code>。</p>
<p>以下是x86_64架构中所有基本寄存器的子寄存器名称：</p>
<table>
<thead>
<tr>
<th>Description描述</th>
<th>64-bit Register64-位寄存器</th>
<th>32-bit Register32-位寄存器</th>
<th>16-bit Register16-位寄存器</th>
<th>8-bit Register8-位寄存器</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Data/Arguments Registers</strong> 数据/参数寄存器</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Syscall Number/Return value系统调用编号/返回值</td>
<td><code>rax</code> <code>rcx</code></td>
<td><code>eax</code> <code>rcx</code></td>
<td><code>ax</code> <code>rcx</code></td>
<td><code>al</code> <code>rcx</code></td>
</tr>
<tr>
<td>Callee Saved调用者保存</td>
<td><code>rbx</code> <code>rcx</code></td>
<td><code>ebx</code> <code>rcx</code></td>
<td><code>bx</code> <code>rcx</code></td>
<td><code>bl</code> <code>rcx</code></td>
</tr>
<tr>
<td>1st arg - Destination operand第一个参数-目标操作数</td>
<td><code>rdi</code> <code>rcx</code></td>
<td><code>edi</code> <code>rcx</code></td>
<td><code>di</code> <code>rcx</code></td>
<td><code>dil</code> <code>rcx</code></td>
</tr>
<tr>
<td>2nd arg - Source operand第二个参数-源操作数</td>
<td><code>rsi</code> <code>rcx</code></td>
<td><code>esi</code> <code>rcx</code></td>
<td><code>si</code> <code>rcx</code></td>
<td><code>sil</code> <code>rcx</code></td>
</tr>
<tr>
<td>3rd arg第三个参数</td>
<td><code>rdx</code> <code>rcx</code></td>
<td><code>edx</code> <code>rcx</code></td>
<td><code>dx</code> <code>rcx</code></td>
<td><code>dl</code> <code>rcx</code></td>
</tr>
<tr>
<td>4th arg - Loop counter4th arg -循环计数器</td>
<td><code>rcx</code></td>
<td><code>ecx</code> <code>rcx</code></td>
<td><code>cx</code> <code>rcx</code></td>
<td><code>cl</code> <code>rcx</code></td>
</tr>
<tr>
<td>5th arg第五个参数</td>
<td><code>r8</code> <code>rcx</code></td>
<td><code>r8d</code> <code>rcx</code></td>
<td><code>r8w</code> <code>rcx</code></td>
<td><code>r8b</code> <code>rcx</code></td>
</tr>
<tr>
<td>6th arg第六个参数</td>
<td><code>r9</code> <code>rcx</code></td>
<td><code>r9d</code> <code>rcx</code></td>
<td><code>r9w</code> <code>rcx</code></td>
<td><code>r9b</code> <code>rcx</code></td>
</tr>
<tr>
<td><strong>Pointer Registers</strong> 指针寄存器</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Base Stack Pointer基本堆栈指针</td>
<td><code>rbp</code> <code>rcx</code></td>
<td><code>ebp</code> <code>rcx</code></td>
<td><code>bp</code> <code>rcx</code></td>
<td><code>bpl</code> <code>rcx</code></td>
</tr>
<tr>
<td>Current/Top Stack Pointer当前/顶部堆栈指针</td>
<td><code>rsp</code> <code>rcx</code></td>
<td><code>esp</code> <code>rcx</code></td>
<td><code>sp</code> <code>rcx</code></td>
<td><code>spl</code> <code>rcx</code></td>
</tr>
<tr>
<td>Instruction Pointer ‘call only’指令指针“仅调用”</td>
<td><code>rip</code> <code>rcx</code></td>
<td><code>eip</code> <code>rcx</code></td>
<td><code>ip</code> <code>rcx</code></td>
<td><code>ipl</code> <code>rcx</code></td>
</tr>
</tbody></table>
<p>在学习本模块时，我们将讨论如何使用这些寄存器。</p>
<p>还有其他各种寄存器，但我们不会在本模块中介绍它们，因为它们对于基本的汇编用法来说并不需要。例如，有<code>RFLAGS</code>寄存器，用于维护CPU使用的各种标志，如零标志<code>ZF</code>，用于条件指令。</p>
<h3 id="Memory-Addresses-1"><a href="#Memory-Addresses-1" class="headerlink" title="Memory Addresses"></a>Memory Addresses</h3><p>如前所述，x86 64位处理器具有64位宽的地址，范围从<code>0x0</code>到<code>0xffffffffffffffff</code>，因此我们期望地址在此范围内。然而，RAM被分割成不同的区域，如堆栈、堆和其他程序和内核特定的区域。每个内存区域都有特定的<code>read</code>、<code>write</code>、<code>execute</code>权限，指定我们是否可以从中读取、写入或调用其中的地址。</p>
<p>每当一条指令通过指令周期被执行时，第一步是从它所在的地址获取指令，如前所述。存在几种类型的地址获取（即，寻址模式）在x86体系结构中：</p>
<table>
<thead>
<tr>
<th>Addressing Mode</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td><code>Immediate</code> <code>rcx</code></td>
<td>The value is given within the instruction</td>
<td><code>add 2</code> <code>rcx</code></td>
</tr>
<tr>
<td><code>Register</code> <code>rcx</code></td>
<td>保存该值的寄存器名称在指令中给出</td>
<td><code>add rax</code> <code>rcx</code></td>
</tr>
<tr>
<td><code>Direct</code> <code>rcx</code></td>
<td>直接完整地址在指令中给出</td>
<td><code>call 0xffffffffaa8a25ff</code> <code>rcx</code></td>
</tr>
<tr>
<td><code>Indirect</code> <code>rcx</code></td>
<td>在指令中给出一个引用指针</td>
<td><code>call 0x44d000</code> or <code>call [rax]</code> <code>call 0x44d000</code>或<code>call [rax]</code></td>
</tr>
<tr>
<td><code>Stack</code> <code>rcx</code></td>
<td>地址位于堆栈顶部</td>
<td><code>add rsp</code> <code>rcx</code></td>
</tr>
</tbody></table>
<p>在上表中，越低越慢。值的即时性越低，获取它的速度就越慢。</p>
<p>尽管速度不是我们在学习基本汇编语言时最关心的问题，但我们应该了解每个地址的位置和方式。了解这些将有助于我们在未来的二进制攻击中，例如缓冲区溢出攻击。同样的理解将对高级二进制开发（如ROP或Heap开发）产生更重要的影响。</p>
<h3 id="地址Endianness-1"><a href="#地址Endianness-1" class="headerlink" title="地址Endianness"></a>地址Endianness</h3><p>地址的字节顺序是它们存储或从内存中检索的字节顺序。有两种类型的endianness：<code>Little-Endian</code>和<code>Big-Endian</code>。对于小端处理器，地址的小端字节首先填充/检索<code>right-to-left</code>，而对于大端处理器，大端字节首先填充/检索<code>left-to-right</code>。</p>
<p>例如，如果我们将地址<code>0x0011223344556677</code>存储在内存中，小端处理器将在最右边的字节上存储<code>0x00</code>字节，然后在它之后填充<code>0x11</code>字节，因此它变成<code>0x1100</code>，然后是<code>0x22</code>字节，因此它变成<code>0x221100</code>，等等。这是原始值的倒数。当然，当检索回值时，处理器也将使用little-endian检索，因此检索到的值将与原始值相同。</p>
<p>另一个显示这如何影响存储值的例子是二进制。例如，如果我们有一个2字节整数<code>426</code>，它的二进制表示是<code>00000001 10101010</code>。这两个字节的存储顺序将改变其值。例如，如果我们将其反向存储为<code>10101010 00000001</code>，则其值变为<code>43521</code>。</p>
<p>大端处理器将这些字节存储为<code>00000001 10101010``left-to-right</code>，而小端处理器将它们存储为<code>10101010 00000001``right-to-left</code>。当检索值时，处理器必须使用与存储它们时相同的字节序，否则它将得到错误的值。这表明存储/检索字节的顺序有很大的不同。</p>
<h1 id="Assembling-amp-Debugging"><a href="#Assembling-amp-Debugging" class="headerlink" title="Assembling &amp; Debugging"></a>Assembling &amp; Debugging</h1><h2 id="程序集文件结构"><a href="#程序集文件结构" class="headerlink" title="程序集文件结构"></a>程序集文件结构</h2><p>当我们在接下来的章节中学习各种汇编指令时，我们将不断地编写代码，汇编它，并调试它。这是学习每条指令做什么的最好方法。因此，我们需要学习汇编代码文件的基本结构，然后对其进行汇编和调试。</p>
<p>在本节中，我们将介绍Assembly文件的基本结构，在接下来的两节中，我们将介绍Assembly文件的组装和调试。我们将使用模板<code>Hello World!</code> Assembly代码作为示例，首先学习Assembly文件的一般结构，然后学习如何组装和调试它。让我们从查看和剖析示例<code>Hello World!</code> Assembly代码模板开始：</p>
<p>Code: </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">         global  _start</span><br><span class="line"></span><br><span class="line">         section .data</span><br><span class="line">message: db      "Hello HTB Academy!"</span><br><span class="line"></span><br><span class="line">         section .text</span><br><span class="line">_start:</span><br><span class="line">         mov     rax, 1</span><br><span class="line">         mov     rdi, 1</span><br><span class="line">         mov     rsi, message</span><br><span class="line">         mov     rdx, 18</span><br><span class="line">         syscall</span><br><span class="line"></span><br><span class="line">         mov     rax, 60</span><br><span class="line">         mov     rdi, 0</span><br><span class="line">         syscall</span><br></pre></td></tr></tbody></table></figure>

<p>这个汇编代码（一旦汇编和链接）应该将字符串’<code>Hello HTB Academy!</code>‘打印到屏幕上。我们还不会详细讨论如何处理它，但是我们需要理解代码模板的主要元素。</p>
<h3 id="程序集文件结构-1"><a href="#程序集文件结构-1" class="headerlink" title="程序集文件结构"></a>程序集文件结构</h3><p>首先，让我们看看代码的分发方式：</p>
<p><img src="https://academy.hackthebox.com/storage/modules/85/nasm_structure.jpg" alt="img"></p>
<p>查看代码的垂直部分，每行可以包含三个元素：</p>
<table>
<thead>
<tr>
<th>1. <code>Labels</code></th>
<th>2. <code>Instructions</code></th>
<th>3. <code>Operands</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>我们已经在前面的章节中讨论了<code>instructions</code>和它们的<code>operands</code>，我们将在接下来的章节中详细介绍各种汇编指令。除此之外，我们还可以在每一行定义一个<code>label</code>。每个标签都可以用<code>instructions</code>或<code>directives</code>表示。</p>
<p>接下来，如果我们逐行查看代码，我们会看到它有三个主要部分：</p>
<table>
<thead>
<tr>
<th>Section</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>global _start</code></td>
<td>这是一个<code>directive</code>，它指示代码从下面定义的<code>_start</code>标签开始执行。</td>
</tr>
<tr>
<td><code>section .data</code></td>
<td>这是<code>data</code>部分，它应该包含所有变量。</td>
</tr>
<tr>
<td><code>section .text</code></td>
<td>这是包含所有要执行的代码的<code>text</code>部分。</td>
</tr>
</tbody></table>
<p><code>.data</code>和<code>.text</code>部分都涉及将存储这些指令的<code>data</code>和<code>text</code>存储器段。</p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>汇编代码是基于行的，这意味着文件是逐行处理的，执行每行的指令。我们在第一行看到一个指令<code>global _start</code>，它指示机器开始处理<code>_start</code>标签之后的指令。因此，机器转到<code>_start</code>标签并开始执行那里的指令，这将在屏幕上打印消息。这将在<code>Control Instructions</code>部分中更详细地介绍。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>接下来是<code>.data</code>部分。<code>data</code>部分保存了我们的变量，使我们更容易定义变量并重用它们，而无需多次编写它们。一旦我们运行我们的程序，我们所有的变量将被加载到内存中的<code>data</code>段。</p>
<p>当我们运行程序时，它会将我们定义的任何变量加载到内存中，以便在我们调用它们时可以使用它们。我们将在模块的后面注意到，当我们开始执行<code>_start</code>标签处的指令时，所有变量都已经加载到内存中。</p>
<p>我们可以使用<code>db</code>来定义一个字节列表，<code>dw</code>来定义一个单词列表，<code>dd</code>来定义一个数字列表，等等。我们还可以标记任何变量，以便我们以后可以调用或引用它。以下是定义变量的一些示例：</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>db 0x0a</code> <code>section .data</code></td>
<td>定义字节<code>0x0a</code>，这是一个新行。</td>
</tr>
<tr>
<td><code>message db 0x41, 0x42, 0x43, 0x0a</code> <code>section .data</code></td>
<td>定义标签<code>message =&gt; abc\n</code>。</td>
</tr>
<tr>
<td><code>message db "Hello World!", 0x0a</code> <code>section .data</code></td>
<td>定义标签<code>message =&gt; Hello World!\n</code>。</td>
</tr>
</tbody></table>
<p>此外，我们可以使用<code>equ</code>指令和<code>$</code>令牌来计算表达式，例如定义变量字符串的长度。但是，用<code>equ</code>指令定义的标签是常量，以后不能更改。</p>
<p>例如，下面的代码定义了一个变量，然后为其长度定义了一个常量：</p>
<p>Code: </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">section .data</span><br><span class="line">    message db "Hello World!", 0x0a</span><br><span class="line">    length  equ $-message</span><br></pre></td></tr></tbody></table></figure>

<p>注意：<code>$</code>标记表示当前距离当前部分的开始处。由于<code>message</code>变量位于<code>data</code>部分的开头，因此当前位置，即。<code>$</code>的值，等于字符串的长度。对于这个模块的范围，我们将只使用这个标记来计算字符串的长度，使用上面显示的同一行代码。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>第二个（也是最重要的）部分是<code>.text</code>部分。这个部分保存所有的汇编指令，并将它们加载到<code>text</code>内存段。一旦所有指令都被加载到<code>text</code>段中，处理器就开始一个接一个地执行它们。</p>
<p>默认的约定是在<code>_start</code>部分的开头使用<code>.text</code>标签，根据<code>global _start</code>指令，该标签开始将在程序运行时执行的主代码。正如我们将在本模块后面看到的，我们可以在<code>.text</code>部分中定义其他标签，用于循环和其他函数。</p>
<p>内存中的<code>text</code>段是只读的，所以我们不能在其中写入任何变量。另一方面，<code>data</code>段是读/写的，这就是为什么我们向它写入变量。然而，内存中的<code>data</code>段是不可执行的，所以我们向它写入的任何代码都不能执行。这种分离是内存保护的一部分，用于减轻缓冲区溢出和其他类型的二进制利用。</p>
<p>提示：我们可以使用分号<code>;</code>向汇编代码添加注释。我们可以使用注释来解释代码的每一部分的用途，以及每一行的作用。这样做可以为我们节省保存大量的时间，如果我们将来重新访问代码并需要理解它的话。</p>
<p>有了这个，我们应该了解程序集文件的基本结构。</p>
<h2 id="Assembling-amp-Disassembling"><a href="#Assembling-amp-Disassembling" class="headerlink" title="Assembling &amp; Disassembling"></a>Assembling &amp; Disassembling</h2><p>现在我们了解了Assembly文件的基本结构和元素，我们可以开始使用<code>nasm</code>工具组装它。我们在上一节中学习的整个程序集文件结构都是基于<code>nasm</code>文件结构的。在使用<code>nasm</code>组装我们的代码时，它理解文件的各个部分，然后正确地组装它们，以便在运行时正确运行。</p>
<p>在我们使用<code>nasm</code>组装代码之后，我们可以使用<code>ld</code>链接它以利用各种操作系统功能和库。</p>
<h3 id="Assembling"><a href="#Assembling" class="headerlink" title="Assembling"></a>Assembling</h3><p>首先，我们将上述代码复制到名为<code>helloWorld.s</code>的文件中。</p>
<p>注意：汇编文件通常使用<code>.s</code>或<code>.asm</code>扩展名。我们将在本模块中使用<code>.s</code>。</p>
<p>我们不必一直使用制表符来分隔汇编文件的各个部分，因为这只是出于演示目的。我们可以将以下代码写入我们的<code>helloWorld.s</code>文件：</p>
<p>Code: </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">global _start</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">    message db "Hello HTB Academy!"</span><br><span class="line">    length equ $-message</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">_start:</span><br><span class="line">    mov rax, 1</span><br><span class="line">    mov rdi, 1</span><br><span class="line">    mov rsi, message</span><br><span class="line">    mov rdx, length</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rax, 60</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    syscall</span><br></pre></td></tr></tbody></table></figure>

<p>请注意，我们如何使用<code>equ</code>来动态计算<code>message</code>的长度，而不是使用静态的<code>18</code>。这将在以后变得非常方便。一旦我们这样做，我们将使用<code>nasm</code>组装文件，使用以下命令：                              </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mikannse7@htb[/htb]$ nasm -f elf64 helloWorld.s</span><br></pre></td></tr></tbody></table></figure>

<p>注意：<code>-f elf64</code>标志用于说明我们想要汇编64位汇编代码。如果我们想汇编一个32位代码，我们会使用<code>-f elf</code>。</p>
<p>这应该输出一个<code>helloWorld.o</code>目标文件，然后将其组装成机器码，沿着所有变量和部分的详细信息。这个文件还不能执行。</p>
<h3 id="Linking"><a href="#Linking" class="headerlink" title="Linking"></a>Linking</h3><p>最后一步是使用<code>ld</code>链接我们的文件。<code>helloWorld.o</code>目标文件虽然已组装，但仍然无法执行。这是因为<code>nasm</code>使用的许多引用和标签需要解析为实际地址，同时沿着将文件与可能需要的各种OS库链接。</p>
<p>这就是为什么Linux二进制文件被称为<code>ELF</code>，它代表<code>Executable and Linkable Format</code>。要使用<code>ld</code>链接文件，我们可以使用以下命令：                                                   </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mikannse7@htb[/htb]$ ld -o helloWorld helloWorld.o</span><br></pre></td></tr></tbody></table></figure>

<p>注意：如果我们要汇编一个32位的二进制文件，我们需要添加’<code>-m elf_i386</code>‘标志。</p>
<p>一旦我们用<code>ld</code>链接文件，我们就应该有最终的可执行文件：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mikannse7@htb[/htb]$ ./helloWorld</span><br><span class="line">Hello HTB Academy!</span><br></pre></td></tr></tbody></table></figure>

<p>我们已经成功地组装和链接了我们的第一个组装文件。我们将通过这个模块频繁地组装、链接和运行我们的代码，所以让我们构建一个简单的<code>bash</code>脚本来使其更容易：</p>
<p>Code: </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">fileName=<span class="string">"<span class="variable">${1%%.*}</span>"</span> <span class="comment"># remove .s extension</span></span><br><span class="line"></span><br><span class="line">nasm -f elf64 <span class="variable">${fileName}</span><span class="string">".s"</span></span><br><span class="line">ld <span class="variable">${fileName}</span><span class="string">".o"</span> -o <span class="variable">${fileName}</span></span><br><span class="line">[ <span class="string">"<span class="variable">$2</span>"</span> == <span class="string">"-g"</span> ] &amp;&amp; gdb -q <span class="variable">${fileName}</span> || ./<span class="variable">${fileName}</span></span><br></pre></td></tr></tbody></table></figure>

<p>现在，我们可以将此脚本写入<code>assembler.sh</code>，<code>chmod +x</code> it，然后在我们的汇编文件中运行它。它将组装它，链接它，并运行它：                                                                           </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mikannse7@htb[/htb]$ ./assembler.sh helloWorld.s</span><br><span class="line">Hello HTB Academy!</span><br></pre></td></tr></tbody></table></figure>

<p>太好了！在我们继续之前，让我们分解并检查我们的文件，以了解更多关于我们刚刚完成的过程的信息。</p>
<h3 id="Disassembling"><a href="#Disassembling" class="headerlink" title="Disassembling"></a>Disassembling</h3><p>要反汇编文件，我们将使用<code>objdump</code>工具，它从文件中转储机器代码并解释每个十六进制代码的汇编指令。我们可以使用<code>-D</code>标志反汇编一个二进制文件。</p>
<p>注意：我们还将使用标记<code>-M intel</code>，以便<code>objdump</code>将以我们正在使用的Intel语法编写指令，正如我们之前讨论的那样。</p>
<p>让我们从反汇编最终的<code>ELF</code>可执行文件开始：                                                              </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mikannse7@htb[/htb]$ objdump -M intel -d helloWorld</span><br><span class="line"></span><br><span class="line">helloWorld:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000401000 &lt;_start&gt;:</span><br><span class="line">  401000:	b8 01 00 00 00       	mov    eax,0x1</span><br><span class="line">  401005:	bf 01 00 00 00       	mov    edi,0x1</span><br><span class="line">  40100a:	48 be 00 20 40 00 00 	movabs rsi,0x402000</span><br><span class="line">  401011:	00 00 00</span><br><span class="line">  401014:	ba 12 00 00 00       	mov    edx,0x12</span><br><span class="line">  401019:	0f 05                	syscall</span><br><span class="line">  40101b:	b8 3c 00 00 00       	mov    eax,0x3c</span><br><span class="line">  401020:	bf 00 00 00 00       	mov    edi,0x0</span><br><span class="line">  401025:	0f 05                	syscall</span><br></pre></td></tr></tbody></table></figure>

<p>我们看到，我们的原始汇编代码被高度保留，唯一的变化是使用<code>0x402000</code>代替<code>message</code>变量，并将<code>length</code>常量替换为其值<code>0x12</code>。我们还看到，<code>nasm</code>有效地将我们的<code>64-bit</code>寄存器更改为<code>32-bit</code>子寄存器，以便尽可能使用更少的内存，就像将<code>mov rax, 1</code>更改为<code>mov eax,0x1</code>一样。</p>
<p>如果我们只想显示汇编代码，而不显示机器码或地址，我们可以添加<code>--no-show-raw-insn --no-addresses</code>标志，如下所示：                                                                                   </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mikannse7@htb[/htb]$ objdump -M intel --no-show-raw-insn --no-addresses -d helloWorld</span><br><span class="line"></span><br><span class="line">helloWorld:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">&lt;_start&gt;:</span><br><span class="line">        mov    eax,0x1</span><br><span class="line">        mov    edi,0x1</span><br><span class="line">        movabs rsi,0x402000</span><br><span class="line">        mov    edx,0x12</span><br><span class="line">        syscall </span><br><span class="line">        mov    eax,0x3c</span><br><span class="line">        mov    edi,0x0</span><br><span class="line">        syscall</span><br></pre></td></tr></tbody></table></figure>

<p>注：注意<code>objdump</code>已将第三条指令更改为<code>movabs</code>。这与<code>mov</code>相同，所以如果需要重新汇编代码，可以将其更改回<code>mov</code>。</p>
<p><code>-d</code>标志只会反汇编代码的<code>.text</code>部分。要转储任何字符串，我们可以使用<code>-s</code>标志，并添加<code>-j .data</code>以仅检查<code>.data</code>部分。这意味着我们也不需要添加<code>-M intel</code>。最后一个命令如下：                                 </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mikannse7@htb[/htb]$ objdump -sj .data helloWorld</span><br><span class="line"></span><br><span class="line">helloWorld:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Contents of section .data:</span><br><span class="line"> 402000 48656c6c 6f204854 42204163 6164656d  Hello HTB Academ</span><br><span class="line"> 402010 7921                                 y!</span><br></pre></td></tr></tbody></table></figure>

<p>正如我们所看到的，<code>.data</code>部分确实包含了带有字符串<code>message</code>的<code>Hello HTB Academy!</code>变量。这应该会让我们给予一个更好的概念，即我们的代码是如何组装成机器码的，以及组装后的外观如何。接下来，让我们了解一下代码调试的基础知识，这是我们需要学习的一项关键技能。</p>
<h2 id="GNU-Debugger-GDB"><a href="#GNU-Debugger-GDB" class="headerlink" title="GNU Debugger (GDB)"></a>GNU Debugger (GDB)</h2><p>对于开发人员和pentester来说，这是一个需要学习的重要技能。搜索是用于查找和删除问题的术语（即，我们的代码中的bug，因此命名为debugging。当我们开发一个程序时，我们经常会在代码中遇到bug。不断地修改代码直到代码达到我们的期望是没有效率的。相反，我们通过设置断点来执行调试，并查看程序如何在每个断点上运行，以及我们的输入如何在它们之间变化，这应该让我们给予一个清晰的概念，是什么导致了<code>bug</code>。</p>
<p>用高级语言编写的程序可以在特定行上设置断点，并通过调试器运行程序以监视它们的行为。使用汇编，我们处理以汇编指令表示的机器代码，因此我们的断点设置在加载机器代码的内存位置，正如我们将看到的。</p>
<p>为了调试我们的二进制文件，我们将使用一个著名的用于Linux程序的调试器，称为<a target="_blank" rel="noopener" href="https://www.gnu.org/software/gdb/">GNU调试器</a>（<code>GDB</code>）。Linux上还有其他类似的调试器，如<a target="_blank" rel="noopener" href="https://www.radare.org/r/">Radare</a>和<a target="_blank" rel="noopener" href="https://www.hopperapp.com/">Hopper</a>，Windows上也有类似的调试器，如<a target="_blank" rel="noopener" href="https://www.immunityinc.com/products/debugger/">Immunity Debugger</a>和<a target="_blank" rel="noopener" href="http://wingdb.com/">WinGDB</a>。也有强大的调试器可用于许多平台，如<a target="_blank" rel="noopener" href="https://www.hex-rays.com/products/ida/">IDA Pro</a>和<a target="_blank" rel="noopener" href="https://github.com/eteran/edb-debugger">EDB</a>。在本模块中，我们将使用GDB。对于Linux二进制文件来说，它是最可靠的，因为它是由GNU直接构建和维护的，这使它与Linux系统及其组件有了很好的集成。</p>
<h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><p>GDB安装在许多Linux发行版中，它也默认安装在Parrot OS和PwnBox中。如果您的VM中没有安装它，您可以使用<code>apt</code>通过以下命令安装它：   </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mikannse7@htb[/htb]$ sudo apt-get update</span><br><span class="line">mikannse7@htb[/htb]$ sudo apt-get install gdb</span><br></pre></td></tr></tbody></table></figure>

<p><code>GDB</code>的一个重要特性是它支持第三方插件。<a target="_blank" rel="noopener" href="https://github.com/hugsy/gef">GEF是</a>一个很好的插件，它维护得很好，并且有很好的文档。GEF是一个免费的开源GDB插件，专为逆向工程和二进制开发而构建。这一事实使它成为一个很好的学习工具。</p>
<p>要将GEF添加到GDB，我们可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mikannse7@htb[/htb]$ wget -O ~/.gdbinit-gef.py -q https://gef.blah.cat/py</span><br><span class="line">mikannse7@htb[/htb]$ echo source ~/.gdbinit-gef.py &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></tbody></table></figure>

<h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>现在我们已经安装了这两个工具，我们可以使用以下命令运行gdb来调试我们的<code>HelloWorld</code>二进制文件，GEF将自动加载：                                                                  </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mikannse7@htb[/htb]$ gdb -q ./helloWorld</span><br><span class="line">...SNIP...</span><br><span class="line">gef➤</span><br></pre></td></tr></tbody></table></figure>

<p>正如我们在<code>gef➤</code>中看到的，GEF是在GDB运行时加载的。如果您在使用<code>GEF</code>时遇到任何问题，可以参考<a target="_blank" rel="noopener" href="https://hugsy.github.io/gef/">GEF文档</a>，您可能会找到解决方案。</p>
<p>接下来，我们将经常组装和链接我们的汇编代码，然后用<code>gdb</code>运行它。为了快速完成，我们可以使用我们在上一节中编写的带有<code>assembler.sh</code>标志的<code>-g</code>脚本。它将组装并链接代码，然后使用<code>gdb</code>运行它，如下所示：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mikannse7@htb[/htb]$ ./assembler.sh helloWorld.s -g</span><br><span class="line">...SNIP...</span><br><span class="line">gef➤</span><br></pre></td></tr></tbody></table></figure>

<h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h3><p>一旦启动<code>GDB</code>，我们就可以使用<code>info</code>命令来查看程序的一般信息，比如它的函数或变量。</p>
<p>提示：如果我们想了解任何命令如何在<code>GDB</code>中运行，我们可以使用<code>help CMD</code>命令来获取其文档。例如，我们可以尝试执行<code>help info</code></p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>首先，我们将使用<code>info</code>命令来检查二进制文件中定义了哪些<code>functions</code>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gef➤  info functions</span><br><span class="line"></span><br><span class="line">All defined functions:</span><br><span class="line"></span><br><span class="line">Non-debugging symbols:</span><br><span class="line">0x0000000000401000  _start</span><br></pre></td></tr></tbody></table></figure>

<p>正如我们所看到的，我们找到了主要的<code>_start</code>函数。</p>
<h4 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h4><p>我们也可以使用<code>info variables</code>命令来查看程序中所有可用的变量：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gef➤  info variables</span><br><span class="line"></span><br><span class="line">All defined variables:</span><br><span class="line"></span><br><span class="line">Non-debugging symbols:</span><br><span class="line">0x0000000000402000  message</span><br><span class="line">0x0000000000402012  __bss_start</span><br><span class="line">0x0000000000402012  _edata</span><br><span class="line">0x0000000000402018  _end</span><br></pre></td></tr></tbody></table></figure>

<p>正如我们所看到的，我们找到了<code>message</code>，沿着和其他一些定义内存段的默认变量。我们可以用函数做很多事情，但我们将重点关注两个要点：断点和断点。</p>
<h3 id="Disassemble"><a href="#Disassemble" class="headerlink" title="Disassemble"></a>Disassemble</h3><p>要查看特定函数中的指令，我们可以使用<code>disassemble</code>或<code>disas</code>命令沿着函数名，如下所示：  </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gef➤  disas _start</span><br><span class="line"></span><br><span class="line">Dump of assembler code for function _start:</span><br><span class="line">   0x0000000000401000 &lt;+0&gt;:	mov    eax,0x1</span><br><span class="line">   0x0000000000401005 &lt;+5&gt;:	mov    edi,0x1</span><br><span class="line">   0x000000000040100a &lt;+10&gt;:	movabs rsi,0x402000</span><br><span class="line">   0x0000000000401014 &lt;+20&gt;:	mov    edx,0x12</span><br><span class="line">   0x0000000000401019 &lt;+25&gt;:	syscall</span><br><span class="line">   0x000000000040101b &lt;+27&gt;:	mov    eax,0x3c</span><br><span class="line">   0x0000000000401020 &lt;+32&gt;:	mov    edi,0x0</span><br><span class="line">   0x0000000000401025 &lt;+37&gt;:	syscall</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></tbody></table></figure>

<p>正如我们所看到的，我们得到的输出非常类似于我们的汇编代码和我们在上一节中从<code>objdump</code>得到的反汇编输出。我们需要关注这个反汇编的主要内容：每个指令和操作数的内存地址（即，参数）。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Having the memory address is critical for examining the variables/operands and setting breakpoints for a certain instruction.</span><br></pre></td></tr></tbody></table></figure>

<p>通过调试，您可能会注意到有些内存地址是<code>0x00000000004xxxxx</code>的形式，而不是它们在内存<code>0xffffffffaa8a25ff</code>中的原始地址。这是由于位置无关可执行程序<code>$rip-relative addressing</code>中的<code>PIE</code>，其中存储器地址是相对于它们与程序自己的虚拟RAM内的指令指针<code>$rip</code>的距离来使用的，而不是使用原始存储器地址。可以禁用此功能以降低二进制攻击的风险。</p>
<p>接下来，让我们通过使用断点、检查数据和单步执行程序来了解使用GDB进行调试的基本知识。</p>
<h2 id="Debugging-with-GDB"><a href="#Debugging-with-GDB" class="headerlink" title="Debugging with GDB"></a>Debugging with GDB</h2><p>现在我们有了关于程序的一般信息，我们将开始运行它并调试它。调试主要包括四个步骤：</p>
<table>
<thead>
<tr>
<th>Step</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Break</code></td>
<td>在不同的兴趣点设置断点</td>
</tr>
<tr>
<td><code>Examine</code></td>
<td>运行程序并在这些点上检查程序的状态</td>
</tr>
<tr>
<td><code>Step</code></td>
<td>浏览程序，检查它如何处理每条指令和用户输入</td>
</tr>
<tr>
<td><code>Modify</code></td>
<td>在特定的断点处修改特定寄存器或地址中的值，以研究它将如何影响执行</td>
</tr>
</tbody></table>
<p>在本节中，我们将通过这些要点来学习使用GDB调试程序的基础知识。</p>
<h3 id="Break"><a href="#Break" class="headerlink" title="Break"></a>Break</h3><p>调试的第一步是设置<code>breakpoints</code>以在特定位置或满足特定条件时停止执行。这有助于我们检查程序的状态和寄存器的值。<code>Breakpoints</code>还允许我们在该点停止程序的执行，以便我们可以进入每个指令并检查它如何更改程序和值。</p>
<p>我们可以在特定地址或特定函数设置断点。要设置断点，我们可以使用<code>break</code>或<code>b</code>命令，沿着我们想要中断的地址或函数名。例如，为了遵循我们程序运行的所有指令，让我们在<code>_start</code>函数处中断，如下所示：                                                                          </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gef➤  b _start</span><br><span class="line"></span><br><span class="line">Breakpoint 1 at 0x401000</span><br></pre></td></tr></tbody></table></figure>

<p>现在，为了启动我们的程序，我们可以使用<code>run</code>或<code>r</code>命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gef➤  b _start</span><br><span class="line">Breakpoint 1 at 0x401000</span><br><span class="line">gef➤  r</span><br><span class="line">Starting program: ./helloWorld </span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0000000000401000 in _start ()</span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────── registers ────</span><br><span class="line">$rax   : 0x0               </span><br><span class="line">$rbx   : 0x0               </span><br><span class="line">$rcx   : 0x0               </span><br><span class="line">$rdx   : 0x0               </span><br><span class="line">$rsp   : 0x00007fffffffe310  →  0x0000000000000001</span><br><span class="line">$rbp   : 0x0               </span><br><span class="line">$rsi   : 0x0               </span><br><span class="line">$rdi   : 0x0               </span><br><span class="line">$rip   : 0x0000000000401000  →  &lt;_start+0&gt; mov eax, 0x1</span><br><span class="line">...SNIP...</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0x00007fffffffe310│+0x0000: 0x0000000000000001	 ← $rsp</span><br><span class="line">0x00007fffffffe318│+0x0008: 0x00007fffffffe5a0  →  "./helloWorld"</span><br><span class="line">...SNIP...</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">     0x400ffa                  add    BYTE PTR [rax], al</span><br><span class="line">     0x400ffc                  add    BYTE PTR [rax], al</span><br><span class="line">     0x400ffe                  add    BYTE PTR [rax], al</span><br><span class="line"> →   0x401000 &lt;_start+0&gt;       mov    eax, 0x1</span><br><span class="line">     0x401005 &lt;_start+5&gt;       mov    edi, 0x1</span><br><span class="line">     0x40100a &lt;_start+10&gt;      movabs rsi, 0x402000</span><br><span class="line">     0x401014 &lt;_start+20&gt;      mov    edx, 0x12</span><br><span class="line">     0x401019 &lt;_start+25&gt;      syscall </span><br><span class="line">     0x40101b &lt;_start+27&gt;      mov    eax, 0x3c</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line">[#0] Id 1, Name: "helloWorld", stopped 0x401000 in _start (), reason: BREAKPOINT</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line">[#0] 0x401000 → _start()</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></tbody></table></figure>

<p>如果我们想在某个地址设置断点，比如<code>_start+10</code>，我们可以选择<code>b *_start+10</code>或<code>b *0x40100a</code>：                                           </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gef➤  b *0x40100a</span><br><span class="line">Breakpoint 1 at 0x40100a</span><br></pre></td></tr></tbody></table></figure>

<p><code>*</code>告诉<code>GDB</code>在存储在<code>0x40100a</code>中的指令处中断。</p>
<p>注意：一旦程序运行，如果我们设置了另一个断点，比如<code>b *0x401005</code>，为了继续到那个断点，我们应该使用<code>continue</code>或<code>c</code>命令。如果我们再次使用<code>run</code>或<code>r</code>，它将从头开始运行程序。这对于跳过循环很有用，我们将在本模块的后面部分看到。</p>
<p>如果我们想查看在执行的任何时候有哪些断点，可以使用<code>info breakpoint</code>命令。我们也可以<code>disable</code>、<code>enable</code>或<code>delete</code>任何断点。此外，GDB还支持设置条件中断，当满足特定条件时停止执行。</p>
<h3 id="Examine"><a href="#Examine" class="headerlink" title="Examine"></a>Examine</h3><p>调试的下一步是<code>examining</code>寄存器和地址中的值。正如我们在前面的终端输出中看到的，当我们遇到断点时，<code>GEF</code>自动为我们提供了很多有用的信息。这是使用<code>GEF</code>插件的好处之一，因为它可以自动执行我们通常在每个断点处执行的许多步骤，例如检查寄存器，堆栈和当前汇编指令。</p>
<p>要手动检查任何地址或寄存器或检查任何其他地址或寄存器，我们可以使用格式为<code>x</code>的<code>x/FMT ADDRESS</code>命令，如<code>help x</code>所示。<code>ADDRESS</code>是我们要检查的地址或寄存器，而<code>FMT</code>是检查格式。检查格式<code>FMT</code>可以有三个部分：</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td><code>Count</code> <code>Break</code></td>
<td>我们要重复检查的次数</td>
<td><code>2</code>, <code>3</code>, <code>10</code> <code>2</code>、<code>3</code>、<code>10</code></td>
</tr>
<tr>
<td><code>Format</code> <code>Break</code></td>
<td>我们希望结果表示的格式</td>
<td><code>x(hex)</code>, <code>s(string)</code>, <code>i(instruction)</code> <code>x(hex)</code>、<code>s(string)</code>、<code>i(instruction)</code></td>
</tr>
<tr>
<td><code>Size</code> <code>Break</code></td>
<td>我们要检查的内存大小</td>
<td><code>b(byte)</code>, <code>h(halfword)</code>, <code>w(word)</code>, <code>g(giant, 8 bytes)</code> <code>b(byte)</code>、<code>h(halfword)</code>、<code>w(word)</code>、<code>g(giant, 8 bytes)</code></td>
</tr>
</tbody></table>
<h4 id="Instructions"><a href="#Instructions" class="headerlink" title="Instructions"></a>Instructions</h4><p>例如，如果我们想检查行中接下来的四条指令，我们将不得不检查<code>$rip</code>寄存器（它保存下一条指令的地址），并使用<code>4</code>作为<code>count</code>，<code>i</code>作为<code>format</code>，<code>g</code>作为<code>size</code>（对于8字节或64位）。因此，最后的检查命令将是<code>x/4ig $rip</code>，如下所示：      </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gef➤  x/4ig $rip</span><br><span class="line"></span><br><span class="line">=&gt; 0x401000 &lt;_start&gt;:	mov    eax,0x1</span><br><span class="line">   0x401005 &lt;_start+5&gt;:	mov    edi,0x1</span><br><span class="line">   0x40100a &lt;_start+10&gt;:	movabs rsi,0x402000</span><br><span class="line">   0x401014 &lt;_start+20&gt;:	mov    edx,0x12</span><br></pre></td></tr></tbody></table></figure>

<p>我们看到，我们得到了以下四个预期的指令。这可以帮助我们通过程序检查某些区域以及它们可能包含的指令。</p>
<h4 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h4><p>我们还可以检查存储在特定内存地址的变量。从前面的反汇编中，我们知道我们的<code>message</code>变量存储在地址<code>.data</code>上的<code>0x402000</code>部分。我们还看到了即将到来的命令<code>movabs rsi, 0x402000</code>，所以我们可能想检查从<code>0x402000</code>移动了什么。</p>
<p>在这种情况下，我们不会为<code>Count</code>放置任何东西，因为我们只需要一个地址（1是默认值），并且将使用<code>s</code>作为格式以字符串格式而不是十六进制格式获取它：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gef➤  x/s 0x402000</span><br><span class="line"></span><br><span class="line">0x402000:	"Hello HTB Academy!"</span><br></pre></td></tr></tbody></table></figure>

<p>正如我们所看到的，我们可以看到这个地址处的字符串表示为文本而不是十六进制字符。</p>
<p>注意：如果我们没有指定<code>Size</code>或<code>Format</code>，它将默认为我们使用的最后一个。</p>
<h4 id="Addresses"><a href="#Addresses" class="headerlink" title="Addresses"></a>Addresses</h4><p>最常见的检查格式是十六进制<code>x</code>。我们经常需要检查包含十六进制数据的地址和寄存器，例如内存地址，指令或二进制数据。让我们来看看前面同样的指令，但格式是<code>hex</code>，看看它是什么样子：    </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gef➤  x/wx 0x401000</span><br><span class="line"></span><br><span class="line">0x401000 &lt;_start&gt;:	0x000001b8</span><br></pre></td></tr></tbody></table></figure>

<p>我们看到的不是<code>mov eax,0x1</code>，而是<code>0x000001b8</code>，这是<code>mov eax,0x1</code>机器码的十六进制表示，采用little-endian格式。</p>
<ul>
<li>这是读作：<code>b8 01 00 00</code>。</li>
</ul>
<p>尝试重复我们使用<code>x</code>检查字符串的命令来检查十六进制的字符串。我们应该看到相同的文本，但在十六进制格式。我们还可以使用<code>GEF</code>功能来检查某些地址。例如，在任何时候，我们都可以使用<code>registers</code>命令打印出所有寄存器的当前值：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gef➤  registers</span><br><span class="line">$rax   : 0x0               </span><br><span class="line">$rbx   : 0x0               </span><br><span class="line">$rcx   : 0x0               </span><br><span class="line">$rdx   : 0x0               </span><br><span class="line">$rsp   : 0x00007fffffffe310  →  0x0000000000000001</span><br><span class="line">$rbp   : 0x0               </span><br><span class="line">$rsi   : 0x0               </span><br><span class="line">$rdi   : 0x0               </span><br><span class="line">$rip   : 0x0000000000401000  →  &lt;_start+0&gt; mov eax, 0x1</span><br><span class="line">...SNIP...</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Step"><a href="#Step" class="headerlink" title="Step"></a>Step</h3><p>调试的第三步是<code>stepping</code>，每次通过程序一条指令或一行代码。正如我们所看到的，我们目前正在执行<code>helloWorld</code>程序中的第一条指令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">─────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">     0x400ffe                  add    BYTE PTR [rax], al</span><br><span class="line"> →   0x401000 &lt;_start+0&gt;       mov    eax, 0x1</span><br><span class="line">     0x401005 &lt;_start+5&gt;       mov    edi, 0x1</span><br></pre></td></tr></tbody></table></figure>

<p>注意：带有<code>-&gt;</code>符号的指令是我们所处的位置，它尚未被处理。</p>
<p>要浏览程序，我们可以使用三个不同的命令：用途：<code>stepi</code>和<code>step</code>。</p>
<h4 id="Step-Instruction"><a href="#Step-Instruction" class="headerlink" title="Step Instruction"></a>Step Instruction</h4><p><code>stepi</code>或<code>si</code>命令将逐个执行汇编指令，这是调试时可能执行的最小级别的步骤。让我们使用<code>s</code>命令来看看我们如何进入下一条指令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">─────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">gef➤  si</span><br><span class="line">0x0000000000401005 in _start ()</span><br><span class="line">   0x400fff                  add    BYTE PTR [rax+0x1], bh</span><br><span class="line"> →   0x401005 &lt;_start+5&gt;       mov    edi, 0x1</span><br><span class="line">     0x40100a &lt;_start+10&gt;      movabs rsi, 0x402000</span><br><span class="line">     0x401014 &lt;_start+20&gt;      mov    edx, 0x12</span><br><span class="line">     0x401019 &lt;_start+25&gt;      syscall </span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line">     [#0] Id 1, Name: "helloWorld", stopped 0x401005 in _start (), reason: SINGLE STEP</span><br></pre></td></tr></tbody></table></figure>

<p>正如我们所看到的，我们只执行了一步，然后在<code>mov edi, 0x1</code>指令处再次停止。</p>
<h4 id="Step-Count"><a href="#Step-Count" class="headerlink" title="Step Count"></a>Step Count</h4><p>与检查类似，我们可以通过在<code>si</code>命令后面添加一个数字来重复该命令。例如，如果我们想移动3步到达<code>syscall</code>指令，我们可以这样做：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gef➤  si 3</span><br><span class="line">0x0000000000401019 in _start ()</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">     0x401004 &lt;_start+4&gt;       add    BYTE PTR [rdi+0x1], bh</span><br><span class="line">     0x40100a &lt;_start+10&gt;      movabs rsi, 0x402000</span><br><span class="line">     0x401014 &lt;_start+20&gt;      mov    edx, 0x12</span><br><span class="line"> →   0x401019 &lt;_start+25&gt;      syscall </span><br><span class="line">     0x40101b &lt;_start+27&gt;      mov    eax, 0x3c</span><br><span class="line">     0x401020 &lt;_start+32&gt;      mov    edi, 0x0</span><br><span class="line">     0x401025 &lt;_start+37&gt;      syscall </span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line">[#0] Id 1, Name: "helloWorld", stopped 0x401019 in _start (), reason: SINGLE STEP</span><br></pre></td></tr></tbody></table></figure>

<p>正如我们所看到的，我们按预期在<code>syscall</code>指令处停止。</p>
<p>提示：您可以点击<code>return</code>/<code>enter</code>空，以重复最后一个命令。尝试在这个阶段击中它，你应该再做3个步骤，并在另一个<code>syscall</code>指令处中断。</p>
<h4 id="Step-步骤"><a href="#Step-步骤" class="headerlink" title="Step 步骤"></a>Step 步骤</h4><p>另一方面，<code>step</code>或<code>s</code>命令将继续执行，直到到达下一行代码或从当前函数中退出。如果我们运行一个汇编代码，它将在我们退出当前函数<code>_start</code>时中断。</p>
<p>如果在这个函数中有对另一个函数的调用，它将在该函数的开始处中断。否则，它将在程序结束后退出此函数后中断。让我们尝试使用<code>s</code>，看看会发生什么：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gef➤  step</span><br><span class="line"></span><br><span class="line">Single stepping until exit from function _start,</span><br><span class="line">which has no line number information.</span><br><span class="line">Hello HTB Academy!</span><br><span class="line">[Inferior 1 (process 14732) exited normally]</span><br></pre></td></tr></tbody></table></figure>

<p>我们看到，执行一直持续到我们到达<code>_start</code>函数的出口，所以我们到达了程序的结尾和<code>exited normally</code>，没有任何错误。我们还看到<code>GDB</code>也打印了程序的输出<code>Hello HTB Academy!</code>。</p>
<p>注意：还有<code>next</code>或<code>n</code>命令，它们也将继续到下一行，但会跳过同一行代码中调用的任何函数，而不是像<code>step</code>那样中断它们。还有<code>nexti</code>或<code>ni</code>，类似于<code>si</code>，但跳过函数调用，我们将在模块中稍后看到。</p>
<h3 id="Modify-修改"><a href="#Modify-修改" class="headerlink" title="Modify 修改"></a>Modify 修改</h3><p>调试的最后一步是在某个执行点上寄存器和地址中的<code>modifying</code>值。这有助于我们看到这将如何影响程序的执行。</p>
<h4 id="Addresses-1"><a href="#Addresses-1" class="headerlink" title="Addresses"></a>Addresses</h4><p>要修改GDB中的值，我们可以使用<code>set</code>命令。但是，我们将在<code>patch</code>中使用<code>GEF</code>命令来简化这一步。我们在GDB中输入<code>help patch</code>，以获得其帮助菜单：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gef➤  help patch</span><br><span class="line"></span><br><span class="line">Write specified values to the specified address.</span><br><span class="line">Syntax: patch (qword|dword|word|byte) LOCATION VALUES</span><br><span class="line">patch string LOCATION "double-escaped string"</span><br><span class="line">...SNIP...</span><br></pre></td></tr></tbody></table></figure>

<p>正如我们所看到的，我们必须提供新值的<code>type/size</code>，要存储的<code>location</code>和我们想要使用的<code>value</code>。因此，让我们尝试将存储在<code>.data</code>部分中的字符串（如前所述，地址为<code>0x402000</code>）更改为字符串<code>Patched!\n</code>。</p>
<p>我们将在第一个<code>syscall</code>在<code>0x401019</code>处中断，然后执行修补程序，如下所示：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gef➤  break *0x401019</span><br><span class="line"></span><br><span class="line">Breakpoint 1 at 0x401019</span><br><span class="line">gef➤  r</span><br><span class="line">gef➤  patch string 0x402000 "Patched!\\x0a"</span><br><span class="line">gef➤  c</span><br><span class="line"></span><br><span class="line">Continuing.</span><br><span class="line">Patched!</span><br><span class="line"> Academy!</span><br></pre></td></tr></tbody></table></figure>

<p>我们看到我们成功地修改了字符串，得到了<code>Patched!\n Academy!</code>而不是旧的字符串。注意我们如何使用<code>\x0a</code>在字符串后面添加一个新行。</p>
<h4 id="Registers-2"><a href="#Registers-2" class="headerlink" title="Registers"></a>Registers</h4><p>我们还注意到我们没有替换整个字符串。这是因为我们只修改了字符串的长度，而保留了旧字符串的其余部分。最后，<code>printf</code>函数指定要打印的字节长度为<code>0x12</code>。</p>
<p>为了解决这个问题，让我们将存储在<code>$rdx</code>中的值修改为字符串的长度，即<code>0x9</code>。我们将只修补一个字节的大小。我们将在本模块的后面详细介绍<code>syscall</code>的工作原理。让我们演示如何使用<code>set</code>修改<code>$rdx</code>，如下所示：          </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gef➤  break *0x401019</span><br><span class="line"></span><br><span class="line">Breakpoint 1 at 0x401019</span><br><span class="line">gef➤  r</span><br><span class="line">gef➤  patch string 0x402000 "Patched!\\x0a"</span><br><span class="line">gef➤  set $rdx=0x9</span><br><span class="line">gef➤  c</span><br><span class="line"></span><br><span class="line">Continuing.</span><br><span class="line">Patched!</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以看到，我们成功地修改了最终打印的字符串，并让程序输出了我们选择的内容。修改寄存器和地址值的能力将在调试和二进制开发中对我们有很大帮助，因为它允许我们测试各种值和条件，而不必每次都更改代码和重新编译二进制。</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>无论我们是想确切地了解程序失败的原因，还是想了解程序是如何运行的，以及它在每个点上都在做什么，GDB都变得非常方便。</p>
<p>对于渗透测试，这个过程使我们能够了解程序在某个点上如何处理输入，以及它失败的确切原因。这使我们能够开发利用这些失败的漏洞，正如我们将在二进制开发模块中学习的那样。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://mikannse.space">Mikannse</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://mikannse.space/2023/11/04/IntroToAssemblyArchANDAssembDebugger/">http://mikannse.space/2023/11/04/IntroToAssemblyArchANDAssembDebugger/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://mikannse.space" target="_blank">MikannseのSekai</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BD%91%E5%AE%89/">网安</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="post-meta__tags" href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">渗透测试</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/05/IntroToAssemblyBasicInstructionsANDFunctions/" title="IntroToAssemblyBasicInstructionsANDFunctionsHTB"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">IntroToAssemblyBasicInstructionsANDFunctionsHTB</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/30/ServersideAttacksHTB/" title="ServersideAttacksHTB"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ServersideAttacksHTB</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/17/Cross-Site%20Scripting%20(XSS)HTB/" title="Cross-Site Scripting (XSS)HTB"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-17</div><div class="title">Cross-Site Scripting (XSS)HTB</div></div></a></div><div><a href="/2023/10/24/HackingWordPressHTB/" title="HackingWordPressHTB"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-24</div><div class="title">HackingWordPressHTB</div></div></a></div><div><a href="/2023/11/15/Information%20Gathering%20-%20Web%20EditionHTB/" title="Information Gathering - Web EditionHTB"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-15</div><div class="title">Information Gathering - Web EditionHTB</div></div></a></div><div><a href="/2023/11/07/IntroToAssemblyShellcodingANDSkill/" title="IntroToAssemblyShellcodingANDSkillHTB"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-07</div><div class="title">IntroToAssemblyShellcodingANDSkillHTB</div></div></a></div><div><a href="/2023/10/28/IntroductiontoBashScriptingHTB/" title="IntroductiontoBashScriptingHTB"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-28</div><div class="title">IntroductiontoBashScriptingHTB</div></div></a></div><div><a href="/2023/11/05/IntroToAssemblyBasicInstructionsANDFunctions/" title="IntroToAssemblyBasicInstructionsANDFunctionsHTB"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-05</div><div class="title">IntroToAssemblyBasicInstructionsANDFunctionsHTB</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Mikannse</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">70</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mikannse/mikannse.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">暂时没有公告QAQ</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Architecture"><span class="toc-number">1.</span> <span class="toc-text">Architecture</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Assembly-Language"><span class="toc-number">1.1.</span> <span class="toc-text">Assembly Language</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#High-level-vs-Low-level"><span class="toc-number">1.1.1.</span> <span class="toc-text">High-level vs. Low-level</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5"><span class="toc-number">1.1.2.</span> <span class="toc-text">编译阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Value-for-Pentesters-Pentesters%E7%9A%84%E4%BB%B7%E5%80%BC"><span class="toc-number">1.1.3.</span> <span class="toc-text">Value for Pentesters Pentesters的价值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Computer-Architecture"><span class="toc-number">1.2.</span> <span class="toc-text">Computer Architecture</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory"><span class="toc-number">1.2.1.</span> <span class="toc-text">Memory</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cache"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">Cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RAM"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">RAM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-x2F-Storage-IO-x2F-%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">IO&#x2F;Storage IO&#x2F;存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Speed-%E9%80%9F%E5%BA%A6"><span class="toc-number">1.2.3.</span> <span class="toc-text">Speed 速度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-Architecture"><span class="toc-number">1.3.</span> <span class="toc-text">CPU Architecture</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Clock-Speed-amp-Clock-Cycle"><span class="toc-number">1.3.1.</span> <span class="toc-text">Clock Speed &amp; Clock Cycle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Instruction-Cycle"><span class="toc-number">1.3.2.</span> <span class="toc-text">Instruction Cycle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Processor-Specific"><span class="toc-number">1.3.3.</span> <span class="toc-text">Processor Specific</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">指令集架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CISC"><span class="toc-number">1.4.1.</span> <span class="toc-text">CISC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RISC"><span class="toc-number">1.4.2.</span> <span class="toc-text">RISC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CISC-vs-RISC"><span class="toc-number">1.4.3.</span> <span class="toc-text">CISC vs. RISC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Registers-Addresses-and-Data-Types"><span class="toc-number">1.5.</span> <span class="toc-text">Registers, Addresses, and Data Types</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Registers"><span class="toc-number">1.5.1.</span> <span class="toc-text">Registers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sub-Registers"><span class="toc-number">1.5.2.</span> <span class="toc-text">Sub-Registers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Addresses"><span class="toc-number">1.5.3.</span> <span class="toc-text">Memory Addresses</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80Endianness"><span class="toc-number">1.5.4.</span> <span class="toc-text">地址Endianness</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Registers-1"><span class="toc-number">1.5.5.</span> <span class="toc-text">Registers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sub-Registers-%E5%AD%90%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.5.6.</span> <span class="toc-text">Sub-Registers 子寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Addresses-1"><span class="toc-number">1.5.7.</span> <span class="toc-text">Memory Addresses</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80Endianness-1"><span class="toc-number">1.5.8.</span> <span class="toc-text">地址Endianness</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Assembling-amp-Debugging"><span class="toc-number">2.</span> <span class="toc-text">Assembling &amp; Debugging</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%9B%86%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">程序集文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%9B%86%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84-1"><span class="toc-number">2.1.1.</span> <span class="toc-text">程序集文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4"><span class="toc-number">2.1.2.</span> <span class="toc-text">指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.3.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Code"><span class="toc-number">2.1.4.</span> <span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Assembling-amp-Disassembling"><span class="toc-number">2.2.</span> <span class="toc-text">Assembling &amp; Disassembling</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Assembling"><span class="toc-number">2.2.1.</span> <span class="toc-text">Assembling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linking"><span class="toc-number">2.2.2.</span> <span class="toc-text">Linking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Disassembling"><span class="toc-number">2.2.3.</span> <span class="toc-text">Disassembling</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GNU-Debugger-GDB"><span class="toc-number">2.3.</span> <span class="toc-text">GNU Debugger (GDB)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Installation"><span class="toc-number">2.3.1.</span> <span class="toc-text">Installation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-number">2.3.2.</span> <span class="toc-text">入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF"><span class="toc-number">2.3.3.</span> <span class="toc-text">信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Variables"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">Variables</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Disassemble"><span class="toc-number">2.3.4.</span> <span class="toc-text">Disassemble</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Debugging-with-GDB"><span class="toc-number">2.4.</span> <span class="toc-text">Debugging with GDB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Break"><span class="toc-number">2.4.1.</span> <span class="toc-text">Break</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Examine"><span class="toc-number">2.4.2.</span> <span class="toc-text">Examine</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Instructions"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">Instructions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Strings"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">Strings</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Addresses"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">Addresses</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step"><span class="toc-number">2.4.3.</span> <span class="toc-text">Step</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Step-Instruction"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">Step Instruction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step-Count"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">Step Count</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step-%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.4.3.3.</span> <span class="toc-text">Step 步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modify-%E4%BF%AE%E6%94%B9"><span class="toc-number">2.4.4.</span> <span class="toc-text">Modify 修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Addresses-1"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">Addresses</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Registers-2"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">Registers</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Conclusion"><span class="toc-number">2.4.5.</span> <span class="toc-text">Conclusion</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/11/pwncollegeAssembly30/" title="pwncollegeAssembly30">pwncollegeAssembly30</a><time datetime="2024-10-10T17:05:42.000Z" title="发表于 2024-10-11 01:05:42">2024-10-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/09/pwncollege%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/" title="pwncollege汇编入门">pwncollege汇编入门</a><time datetime="2024-10-09T14:39:52.000Z" title="发表于 2024-10-09 22:39:52">2024-10-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/05/Git%E9%80%9F%E6%88%90/" title="Git速成">Git速成</a><time datetime="2024-10-05T04:57:08.000Z" title="发表于 2024-10-05 12:57:08">2024-10-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/03/%E6%89%93%E9%9D%B6%E8%AE%B0%E5%BD%95(%E4%B8%80%E5%85%AD%E4%BA%8C)%E4%B9%8BVulnHubCorrosion2/" title="打靶记录(一六二)之VulnHubCorrosion2">打靶记录(一六二)之VulnHubCorrosion2</a><time datetime="2024-10-03T09:24:11.000Z" title="发表于 2024-10-03 17:24:11">2024-10-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/02/%E6%89%93%E9%9D%B6%E8%AE%B0%E5%BD%95(%E4%B8%80%E5%85%AD%E4%B8%80)%E4%B9%8BVulnHubDrippingBlues1/" title="打靶记录(一六一)之VulnHubDrippingBlues1">打靶记录(一六一)之VulnHubDrippingBlues1</a><time datetime="2024-10-02T05:16:28.000Z" title="发表于 2024-10-02 13:16:28">2024-10-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/yjr-1100/Photobag/githubioimg/background_4k.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Mikannse</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  const disqus_config = function () {
    this.page.url = 'http://mikannse.space/2023/11/04/IntroToAssemblyArchANDAssembDebugger/'
    this.page.identifier = '/2023/11/04/IntroToAssemblyArchANDAssembDebugger/'
    this.page.title = 'IntroToAssemblyArchANDAssembDebuggerHTB'
  }

  const disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addModeChange('disqus', disqusReset)

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>