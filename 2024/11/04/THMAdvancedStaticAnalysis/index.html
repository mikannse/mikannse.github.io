<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>THMAdvancedStaticAnalysis | MikannseのSekai</title><meta name="author" content="Mikannse"><meta name="copyright" content="Mikannse"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="Introduction在 基本静态分析 房间中，我们研究了恶意软件的特征，如字符串、哈希、导入函数和标头中的其他关键信息，以了解给定恶意软件的用途。在 高级静态分析 中，我们将进一步将恶意软件逆向工程到反汇编代码中，并分析汇编指令，以更好地了解恶意软件的核心功能。 高级静态分析高级静态分析是一种用于分析恶意软件代码和结构而不执行恶意软件的技术。这可以帮助我们识别恶意软件的行为和弱点，并为防病毒软">
<meta property="og:type" content="article">
<meta property="og:title" content="THMAdvancedStaticAnalysis">
<meta property="og:url" content="https://blog.mikannse.cn/2024/11/04/THMAdvancedStaticAnalysis/index.html">
<meta property="og:site_name" content="MikannseのSekai">
<meta property="og:description" content="Introduction在 基本静态分析 房间中，我们研究了恶意软件的特征，如字符串、哈希、导入函数和标头中的其他关键信息，以了解给定恶意软件的用途。在 高级静态分析 中，我们将进一步将恶意软件逆向工程到反汇编代码中，并分析汇编指令，以更好地了解恶意软件的核心功能。 高级静态分析高级静态分析是一种用于分析恶意软件代码和结构而不执行恶意软件的技术。这可以帮助我们识别恶意软件的行为和弱点，并为防病毒软">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg">
<meta property="article:published_time" content="2024-11-04T01:28:47.000Z">
<meta property="article:modified_time" content="2024-11-04T07:30:25.224Z">
<meta property="article:author" content="Mikannse">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="恶意软件分析">
<meta property="article:tag" content="逆向">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg"><link rel="shortcut icon" href="/img/icon.jpg"><link rel="canonical" href="https://blog.mikannse.cn/2024/11/04/THMAdvancedStaticAnalysis/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Mikannse","link":"链接: ","source":"来源: MikannseのSekai","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'THMAdvancedStaticAnalysis',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2024-11-04 15:30:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">313</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">74</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/yjr-1100/Photobag/githubioimg/background_4k.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="MikannseのSekai"><span class="site-name">MikannseのSekai</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">THMAdvancedStaticAnalysis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-04T01:28:47.000Z" title="发表于 2024-11-04 09:28:47">2024-11-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-04T07:30:25.224Z" title="更新于 2024-11-04 15:30:25">2024-11-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BD%91%E5%AE%89/">网安</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="THMAdvancedStaticAnalysis"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>在 <a target="_blank" rel="noopener" href="https://tryhackme.com/room/staticanalysis1">基本静态分析</a> 房间中，我们研究了恶意软件的特征，如字符串、哈希、导入函数和标头中的其他关键信息，以了解给定恶意软件的用途。在 <strong>高级静态分析</strong> 中，我们将进一步将恶意软件逆向工程到反汇编代码中，并分析汇编指令，以更好地了解恶意软件的核心功能。</p>
<h2 id="高级静态分析"><a href="#高级静态分析" class="headerlink" title="高级静态分析"></a>高级静态分析</h2><p>高级静态分析是一种用于分析恶意软件代码和结构而不执行恶意软件的技术。这可以帮助我们识别恶意软件的行为和弱点，并为防病毒软件开发签名以检测它。通过分析恶意软件的代码和结构，研究人员还可以更好地了解它的工作原理并开发新的防御技术。</p>
<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/fbf57fb542e5fe5cf7a1024be29e5fe8.png" alt="Reverse Engineering Process simplified"></p>
<p>这个房间旨在帮助您获得有效逆向恶意软件所需的知识。它将教您更系统地处理汇编指令，使您能够更轻松地识别重要功能，而不是被每条指令所吸引。</p>
<p>这个房间涵盖的一些主题包括：</p>
<ul>
<li>了解如何执行高级静态分析。</li>
<li>探索 Ghidra 的反汇编程序功能。</li>
<li>理解和识别汇编中的不同 C 构造。</li>
</ul>
<h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>参与者应完成以下房间以更好地理解。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://tryhackme.com/room/x8664arch">x86 架构概述</a></li>
<li><a target="_blank" rel="noopener" href="https://tryhackme.com/room/x86assemblycrashcourse">x86 汇编速成课程</a></li>
<li><a target="_blank" rel="noopener" href="https://tryhackme.com/room/staticanalysis1">基本静态分析</a></li>
</ul>
<p>让我们开始学习吧。</p>
<h1 id="Malware-Analysis-Overview"><a href="#Malware-Analysis-Overview" class="headerlink" title="Malware Analysis: Overview"></a>Malware Analysis: Overview</h1><p>恶意软件分析是检查恶意软件（恶意软件）以了解其工作原理并确定其功能、行为和潜在影响的过程。分析恶意软件有四个主要步骤：<strong>基本静态分析</strong>、<strong>基本动态分析</strong>、<strong>高级静态分析</strong>和<strong>高级动态分析</strong>。每个步骤都使用不同的工具和技术来收集有关恶意软件的信息。</p>
<p>基本静态分析</p>
<p>基本静态分析旨在在不执行恶意软件的情况下了解恶意软件的结构和行为。这涉及检查恶意软件的代码、文件头和其他静态属性。</p>
<p>基本动态分析</p>
<p>基本动态分析旨在在受控环境中观察恶意软件在执行期间的行为。这涉及在沙箱或虚拟机中执行恶意软件并监控其系统活动、网络流量和进程行为。</p>
<p>高级动态分析</p>
<p>高级动态分析旨在使用高级监控技术发现更复杂和更具规避性的恶意软件行为。这涉及使用更复杂的沙箱和监控工具来更详细地捕获恶意软件的行为。</p>
<p>高级静态分析</p>
<p>高级静态分析旨在发现恶意软件中隐藏或混淆的代码和功能。这涉及使用更高级的技术来分析恶意软件的代码，例如反混淆和代码模拟。</p>
<p>如何执行高级静态分析</p>
<p>恶意软件的高级静态分析是了解其行为和识别其潜在威胁的关键过程。高级静态分析的主要目标是发现恶意软件的功能，识别其攻击媒介并确定其规避技术。</p>
<p>要执行高级静态分析，通常使用 IDA Pro、Binary Ninja 和 radare2 等反汇编程序。这些反汇编程序允许分析师探索恶意软件的代码并识别其功能和数据结构。执行恶意软件的高级静态分析所涉及的步骤如下：</p>
<ul>
<li>识别恶意软件的入口点及其进行的系统调用。</li>
<li>识别恶意软件的代码部分并使用可用工具（如调试器和十六进制编辑器）对其进行分析。</li>
<li>分析恶意软件的控制流图以确定其执行路径。</li>
<li>通过分析恶意软件在执行过程中进行的系统调用来追踪其动态行为。</li>
<li>使用以上信息了解恶意软件的逃避技术及其可能造成的潜在损害。</li>
</ul>
<h1 id="Ghidra-A-Quick-Overview"><a href="#Ghidra-A-Quick-Overview" class="headerlink" title="Ghidra: A Quick Overview"></a>Ghidra: A Quick Overview</h1><p>许多反汇编程序（如 Cutter、radare2、Ghidra 和 IDA Pro）都可用于反汇编恶意软件。但是，我们将在此房间中探索 Ghidra，因为它是免费的、开源的，并且具有许多可用于熟练掌握逆向工程的功能。目标是熟悉反汇编程序的主要用途，并利用这些知识使用任何反汇编程序。</p>
<p><strong>Ghidra</strong> 是一种软件逆向工程工具，允许用户分析编译后的代码以了解其功能。它旨在通过提供反编译、反汇编和调试二进制文件的平台来帮助分析师和开发人员了解软件的工作原理。</p>
<p>功能<br>Ghidra 包含许多功能，使其成为强大的逆向工程工具。其中一些功能包括：</p>
<ul>
<li><strong>反编译</strong>：Ghidra 可以将二进制文件反编译为可读的 C 代码，使开发人员更容易理解软件的工作原理。</li>
<li><strong>反汇编</strong>：Ghidra 可以将二进制文件反汇编为汇编语言，让分析人员可以检查代码的低级操作。</li>
<li><strong>调试</strong>：Ghidra 有一个内置调试器，允许用户逐步执行代码并检查其行为。</li>
<li><strong>分析</strong>：Ghidra 可以自动识别函数、变量和其他代码，帮助用户了解代码的结构。</li>
</ul>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/31bd01c318e5d3edfe699dd8a885fb12.png" alt="Ghidra Interface"></p>
<p>如何使用 Ghidra 进行分析</p>
<p>我们将通过分析位于桌面上的简单“HelloWorld.exe”程序来探索 Ghidra 及其功能。以下是使用 Ghidra 执行代码分析的步骤：</p>
<ul>
<li>打开 Ghidra 并创建一个新项目。</li>
</ul>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/0f76e89684b13728c6b30e4dae7f3cca.png" alt="Creating a New project in Ghidra"></p>
<ul>
<li>选择<strong>非共享</strong>项目<strong>。选择</strong>共享项目**可以让我们与其他分析师分享我们的分析。</li>
</ul>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/f724b2f4335e62644fda147b6f20fb33.png" alt="Creating a New Project in Ghidra"></p>
<ul>
<li>命名项目并设置目录或保留默认路径。</li>
</ul>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/a7c746831caa8e8865eee6fa6295890a.png" alt=" Steps to start  a New Poroject in Ghidra"></p>
<ul>
<li>导入您要分析的恶意软件可执行文件。现在我们已经创建了一个空项目，让我们将位于桌面上的“HelloWorld.exe”拖放到该项目中，或者导航到桌面文件夹并选择该程序。</li>
</ul>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/cbd0101db66c015df4f32eecee7857ab.png" alt="Load HelloWorld Program in Ghidra"></p>
<ul>
<li>一旦导入，它会向我们显示该程序的摘要，如下所示：</li>
</ul>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/7f8c4c4ba8fa80a9de690617dbefbf02.png" alt=" Shows summary of program in Ghidra"></p>
<ul>
<li>双击 <strong>HelloWorld.exe</strong> 在代码浏览器中打开它。当系统要求分析可执行文件时，单击 <strong>是</strong>。</li>
</ul>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/73812dfaae55db78c9fff4ab621401d0.png" alt=" Shows Analysis steps in Ghidra"></p>
<ul>
<li>接下来出现的窗口向我们展示了各种分析选项。我们可以根据需要选中或取消选中它们。这些插件或附加组件在分析过程中为 Ghidra 提供帮助。</li>
</ul>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/ef6f8a3d9e21dd0d14fcdb8a0a011b0c.png" alt="Shows Analysis steps in Ghidra"></p>
<p>分析需要一些时间。右下角的栏显示进度。等到分析完成 100%。</p>
<p>探索 Ghidra 布局</p>
<ul>
<li>Ghidra 有很多选项可以帮助我们进行分析。其默认布局如下所示并简要说明。</li>
</ul>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/a0b59e7019e8e2fc7f1b9393489fbf10.png" alt="Layout of the Ghidra Code Browser"></p>
<ol>
<li><strong>程序树</strong>：显示程序的各个部分。我们可以单击不同的部分来查看每个部分的内容。<a target="_blank" rel="noopener" href="https://tryhackme.com/room/dissectingpeheaders">解剖 PE 头文件</a> 房间深入解释了头文件和 PE 部分。</li>
<li>符号树：</li>
</ol>
<p>包含导入、导出和函数等重要部分。每个部分都提供了有关我们正在分析的程序的大量信息。</p>
<ul>
<li><strong>导入</strong>：此部分包含有关程序正在导入的库的信息。单击每个 API 调用将显示使用该 API 的汇编代码。</li>
<li><strong>导出</strong>：此部分包含程序正在导出的 API/函数调用。此部分在分析 DLL 时很有用，因为它将显示 dll 包含的所有函数。</li>
<li><strong>函数</strong>：此部分包含它在代码中找到的函数。单击每个函数将带我们到该函数的反汇编代码。它还包含入口函数。单击 <code>entry</code> 函数将带我们进入正在分析的程序的开头。通用名称以 <code>FUN_VirtualAddress</code> 开头的函数是 Ghidra 没有为其命名的函数。</li>
</ul>
<ol start="3">
<li><p><strong>数据类型管理器</strong>：此部分显示程序中发现的各种数据类型。</p>
</li>
<li><p>列表：</p>
</li>
</ol>
<p>此窗口显示二进制文件的反汇编代码，其中按顺序包含以下值。</p>
<ul>
<li>虚拟地址</li>
<li>操作码</li>
<li>汇编指令（PUSH、POP、ADD、XOR 等）</li>
<li>操作数</li>
<li>注释</li>
</ul>
<ol start="5">
<li><p><strong>反编译</strong>：Ghidra 在这里将汇编代码转换为伪 C 代码。这是分析过程中需要查看的一个非常重要的部分，因为它可以更好地理解汇编代码。</p>
</li>
<li><p><strong>工具栏</strong>：它有各种选项可在分析过程中使用。</p>
</li>
</ol>
<ul>
<li><strong>图形视图</strong>：工具栏中的图形视图是一个重要选项，它允许我们查看反汇编的图形视图。</li>
</ul>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/037ba353282224e547d2f12722e0c0b7.png" alt=" Shows Graph View of if-else.exe program"></p>
<ul>
<li><strong>内存映射</strong>选项显示程序的内存映射，如下所示：</li>
</ul>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/290b22b08876e6b5d92db2143932f9f4.png" alt="Shows Memory map in Ghidra"></p>
<ul>
<li>该导航工具栏显示了浏览代码的不同选项。</li>
</ul>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/d0f9cc1c1e8b8bc5114a7832e84a856b.png" alt=" Shows toolbar options in Ghidra"></p>
<ul>
<li>探索字符串。转到“搜索 -&gt; 字符串”，然后单击“搜索”将为我们提供 Ghidra 在程序中找到的字符串。此窗口可以包含非常有用的信息，以帮助我们进行分析。</li>
</ul>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/31ddc15ff3e17b57767bbebc9220faa3.png" alt=" Shows Strings Search tab"></p>
<p>用汇编语言分析 HelloWorld</p>
<p>有很多方法可以找到感兴趣的代码。要找到 <strong>HelloWorld.exe</strong> 的汇编代码，我们将双击 Program Trees 部分中的 <strong>.text</strong>；它将带我们进入反汇编代码部分。滚动反汇编代码，直到看到对将显示 <code>Hello World</code> 字符串的消息框的调用。在反编译部分，我们可以看到该函数的翻译伪 C 代码。</p>
<p>反汇编部分显示了参数是如何被推送的，然后是调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messageboxa">MessageBoxA</a>，负责消息框的显示。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/335a22fc87e428662afbe1b257bde334.png" alt=" Shows Analysis steps in Ghidra"><br>我们在本任务中通过检查一个简单的“HelloWorld”程序探索了 Ghidra 及其功能。在下一个任务中，我们将利用这些知识探索不同的 C 构造及其在汇编中的对应表示。</p>
<p><strong>注意：</strong>值得注意的是，恶意软件的作者可能对其进行了打包或使用了混淆或反 VM/AV 检测技术，使分析更加困难。这些技术将在后面的讨论中讨论。</p>
<h1 id="Identifying-C-Code-Constructs-in-Assembly"><a href="#Identifying-C-Code-Constructs-in-Assembly" class="headerlink" title="Identifying C Code Constructs in Assembly"></a>Identifying C Code Constructs in Assembly</h1><p>分析编译二进制文件的汇编代码对于初学者来说可能是一项艰巨的任务。了解汇编指令以及各种编程组件如何翻译/反映到汇编中非常重要。在这里，我们将检查各种 C 构造及其相应的汇编代码。这将帮助我们在分析过程中识别并关注恶意软件的关键部分。</p>
<p>您可以加载 Ghidra 中 Code_Constructs 文件夹中的程序，如下所示：</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/7acd8eb6041a438d1707b4672d6292c2.png" alt=" Add programs in Ghidra project"></p>
<p>有多种方法可以开始分析反汇编代码：</p>
<ul>
<li>从 <strong>符号树</strong> 部分找到主要函数。</li>
<li>从 <strong>程序树</strong> 部分检查 <strong>.text</strong> 代码以查看代码部分并找到入口点。</li>
<li>搜索有趣的 <strong>字符串</strong> 并找到引用这些字符串的代码。</li>
</ul>
<p><strong>注意：</strong>不同的编译器在编译时会添加自己的代码进行各种检查。因此，可能会出现一些没有意义的垃圾汇编代码。</p>
<p>代码：Hello World</p>
<p><strong>用 C 语言</strong></p>
<p><code>Hello World</code> 是我们在任何编程语言中尝试的第一个程序。下面是一个简单的 C 代码，它将在控制台上打印“Hello World！”消息。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> { <span class="built_in">printf</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>有两个 HelloWorld 程序。桌面上的程序显示一个带有“Hello World”消息的消息框。Code_Constructs 文件夹中的程序在终端中显示“Hello_World”。</p>
<p><strong>In Assembly</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">section .data </span><br><span class="line">    message db <span class="string">'HELLO WORLD!!'</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">    global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    ; write the message to <span class="built_in">stdout</span></span><br><span class="line">    mov eax, <span class="number">4</span>      ; write system call</span><br><span class="line">    mov ebx, <span class="number">1</span>      ; file descriptor <span class="keyword">for</span> <span class="built_in">stdout</span></span><br><span class="line">    mov ecx, message    ; pointer to message</span><br><span class="line">    mov edx, <span class="number">13</span>     ; message length</span><br><span class="line">    <span class="type">int</span> <span class="number">0x80</span>        ; call kernel</span><br></pre></td></tr></tbody></table></figure>

<p>此程序在 <strong>.data</strong> 部分中定义一个字符串“HELLO WORLD!!”，然后使用 <strong>write</strong> 系统调用将该字符串打印到 stdout。</p>
<p>Ghidra 中的 HelloWorld</p>
<p>打开 Ghidra 中 Code_Constructs 文件夹中的 <code>Hello_World.exe</code> 程序。找到主函数并检查汇编和反编译的 C 代码。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/8133da941ef342ecdd1e6d037bc71bd4.png" alt=" Shows Hello_World program disassembled in Ghidra"></p>
<p>如果我们在<strong>Listings View</strong>中查看反汇编代码，我们可以看到在调用打印函数之前将“HELLO WORLD!!”推送到堆栈的指令。</p>
<p>代码：For 循环</p>
<p>For 循环是重复某些指令直到循环完成的重要编程组件。</p>
<p><strong>在 C 语言中</strong></p>
<p>以下代码显示了一个简单的 for 循环，显示一条消息十次。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) {</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>汇编中的 For 循环</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">    ; initialize loop counter to <span class="number">1</span></span><br><span class="line">    mov ecx, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    ; loop <span class="number">5</span> times</span><br><span class="line">    mov edx, <span class="number">5</span></span><br><span class="line">loop:</span><br><span class="line">    ; print the loop counter</span><br><span class="line">    push ecx</span><br><span class="line">    push format</span><br><span class="line">    call <span class="built_in">printf</span></span><br><span class="line">    add esp, <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    ; increment loop counter</span><br><span class="line">    inc ecx</span><br><span class="line"></span><br><span class="line">    ; check <span class="keyword">if</span> the loop is finished</span><br><span class="line">    cmp ecx, edx</span><br><span class="line">    jle loop</span><br></pre></td></tr></tbody></table></figure>

<p>在此代码中，主函数将循环计数器 <code>ecx</code> 初始化为 1，将循环限制 <code>edx</code> 初始化为 5。循环标签用于标记循环的开始。在循环内部，使用标准 C 库中的 <code>printf</code> 函数将循环计数器打印到控制台。打印循环计数器后，循环计数器递增，并检查循环限制以查看循环是否应继续。如果计数器仍然小于或等于循环限制，则循环继续。如果循环计数器超过循环限制，则循环终止，并将控制权传递给程序末尾，程序在此处返回 0。</p>
<p>Ghidra 中的 For 循环</p>
<p>打开 Ghidra 中 Code_Constructs 文件夹中的 <code>for-loop.exe</code> 程序。找到入口函数并检查汇编和反编译的 C 代码。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/2ba27e40ba2483a4011d1e52c4728e16.png" alt="Shows assembly and decompiled code of for_loop program in Ghidra"></p>
<p>我们可以看到 <code> for 循环</code> 是如何被翻译成反汇编代码的。</p>
<p>代码：函数</p>
<p>函数是任何编程语言的关键组成部分。它是一个独立的代码块，执行特定的任务。</p>
<p><strong>在 C 语言中</strong></p>
<p>下面是 C 程序中的一个简单的 add 函数，用于演示函数的工作原理以及如何将它们翻译成汇编语言。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>{</span><br><span class="line">    <span class="type">int</span> result = a + b;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>In Assembly</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">add:</span><br><span class="line">    push ebp          ; save the current base pointer value</span><br><span class="line">    mov ebp, esp      ; <span class="built_in">set</span> base pointer to current <span class="built_in">stack</span> pointer value</span><br><span class="line">    mov eax, dword ptr [ebp+<span class="number">8</span>]  ; move the value of <span class="string">'a'</span> into the eax <span class="keyword">register</span></span><br><span class="line">    add eax, dword ptr [ebp+<span class="number">12</span>] ; add the value of <span class="string">'b'</span> to the eax <span class="keyword">register</span></span><br><span class="line">    mov dword ptr [ebp<span class="number">-4</span>], eax  ; move the sum into the <span class="string">'result'</span> variable</span><br><span class="line">    mov eax, dword ptr [ebp<span class="number">-4</span>]  ; move the value of <span class="string">'result'</span> into the eax <span class="keyword">register</span></span><br><span class="line">    pop ebp           ; restore the previous base pointer value</span><br><span class="line">    ret               ; <span class="keyword">return</span> to calling function</span><br></pre></td></tr></tbody></table></figure>

<p><code>add</code> 函数首先将当前基指针值保存到堆栈上。然后，它将基指针设置为当前堆栈指针值。然后，该函数将 <code>a</code> 和 <code>b</code> 的值移动到 <code>eax</code> 寄存器中，将它们相加，并将结果存储在结果变量中。最后，该函数将结果值移动到 <code>eax</code> 寄存器中，恢复先前的基指针值，并返回到调用函数。</p>
<p>Code: While loop</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\\n"</span>, i);</span><br><span class="line">    i++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>While Loop in Assembly</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">mov ecx, <span class="number">0</span>     ; initialize i to <span class="number">0</span></span><br><span class="line">loop_start:</span><br><span class="line">cmp ecx, <span class="number">10</span>    ; compare i to <span class="number">10</span></span><br><span class="line">jge loop_end   ; jump to loop_end <span class="keyword">if</span> i &gt;= <span class="number">10</span></span><br><span class="line">push ecx       ; save the value of i on the <span class="built_in">stack</span></span><br><span class="line">push format    ; push the format <span class="built_in">string</span> <span class="keyword">for</span> <span class="built_in">printf</span></span><br><span class="line">push dword [ecx]; push the value of i <span class="keyword">for</span> <span class="built_in">printf</span></span><br><span class="line">call <span class="built_in">printf</span>    ; call <span class="built_in">printf</span> to print the value of i</span><br><span class="line">add esp, <span class="number">12</span>    ; clean up the <span class="built_in">stack</span></span><br><span class="line">inc ecx        ; increment i</span><br><span class="line">jmp loop_start ; jump back to the start of the loop</span><br><span class="line">loop_end:</span><br></pre></td></tr></tbody></table></figure>

<p>在此示例中，<code>mov</code> 指令将寄存器 <code>ecx</code> 初始化为 <code>0</code>，代表变量 <code>i</code>。<code>loop_start</code> 标签标记循环的开始。<code>cmp</code> 指令将 <code>ecx</code> 的值与 <code>10</code> 进行比较。如果 <code>ecx</code> 大于或等于 <code>10</code>，则循环结束，程序跳转到 <code>loop_end</code> 标签。否则，<code>ecx</code> 的值将与格式字符串和 <code>ecx</code> 本身的值一起推送到堆栈上，以便使用 <code>printf</code> 打印。<code>add</code> 指令在 <code>printf</code> 调用后清理堆栈。最后，<code>ecx</code> 的值递增，程序跳回到 <code>loop_start</code> 标签以重复循环。</p>
<p>Ghidra 中的 While 循环</p>
<p>在 Ghidra 中打开 <code>While-Loop.exe</code> 程序。转到 <code>Symbol Tree</code> 部分中的 Functions 选项卡，然后找到主函数。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/5354b9cec1cc160731b99a6c723c4cde.png" alt="Shows assembly and decompiled code of while program in Ghidra"></p>
<p>在这个程序中，打印了五次文本，直到计数器变量的值达到 5。我们可以观察关于如何设置计数器变量、循环如何工作以及程序如何使用跳转指令来满足条件的汇编指令。</p>
<p>需要注意的是，不同的编译器会以不同的方式编译程序，并添加与编译器相关的代码。为了演示，本房间中使用的程序是使用不同的编译器编译的。因此，您可能会发现汇编代码的解释存在差异。</p>
<h1 id="An-Overview-of-Windows-API-Calls"><a href="#An-Overview-of-Windows-API-Calls" class="headerlink" title="An Overview of Windows API Calls"></a>An Overview of Windows API Calls</h1><p>Windows API 是 Windows 操作系统提供的一组函数和服务，可帮助开发人员创建 Windows 应用程序。这些函数包括创建窗口、菜单、按钮和其他用户界面元素，以及执行文件输入/输出和网络通信等任务。让我们以一个非常常见的 API 函数为例：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a>。</p>
<p>创建进程 API</p>
<p><code>CreateProcessA</code> 函数创建一个新进程及其主线程。该函数采用多个参数，包括可执行文件的名称、命令行参数和安全属性。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/44520d306a993be58ddd3f5cb8712ac1.png" alt="Shows CreateProcess API function help"></p>
<p>下面是使用“CreateProcessA”函数启动新进程的 C 代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    STARTUPINFO si;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">    ZeroMemory(&amp;si, <span class="keyword">sizeof</span>(si));</span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">    ZeroMemory(&amp;pi, <span class="keyword">sizeof</span>(pi));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!CreateProcess(<span class="literal">NULL</span>, <span class="string">"C:\\\\Windows\\\\notepad.exe"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"CreateProcess failed (%d).\\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(pi.hProcess, INFINITE);</span><br><span class="line"></span><br><span class="line">    CloseHandle(pi.hProcess);</span><br><span class="line">    CloseHandle(pi.hThread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当编译成汇编代码时，“CreateProcessA”函数调用如下所示：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">push <span class="number">0</span></span><br><span class="line">lea eax, [esp+<span class="number">10</span>h+StartupInfo]</span><br><span class="line">push eax</span><br><span class="line">lea eax, [esp+<span class="number">14</span>h+ProcessInformation]</span><br><span class="line">push eax</span><br><span class="line">push <span class="number">0</span></span><br><span class="line">push <span class="number">0</span></span><br><span class="line">push <span class="number">0</span></span><br><span class="line">push <span class="number">0</span></span><br><span class="line">push <span class="number">0</span></span><br><span class="line">push <span class="number">0</span></span><br><span class="line">push dword ptr [hWnd]</span><br><span class="line">call CreateProcessA</span><br></pre></td></tr></tbody></table></figure>

<p>此汇编代码以相反的顺序将必要的参数推送到堆栈上，然后调用<code>CreateProcessA</code>函数。然后，<code>CreateProcessA</code>函数启动一个新进程并返回该进程及其主线程的句柄。</p>
<p>在恶意软件分析过程中，识别 API 调用并检查代码有助于了解恶意软件的用途。</p>
<h1 id="Common-APIs-used-by-Malware"><a href="#Common-APIs-used-by-Malware" class="headerlink" title="Common APIs used by Malware"></a>Common APIs used by Malware</h1><p>恶意软件作者严重依赖 Windows API 来实现其目标。了解不同恶意软件变体中使用的 Windows API 非常重要。检查“导入”函数是高级静态分析中的重要步骤，它可以揭示有关恶意软件的很多信息。</p>
<h2 id="键盘记录器"><a href="#键盘记录器" class="headerlink" title="键盘记录器"></a>键盘记录器</h2><p>恶意软件可以使用多个 Windows API 进行键盘记录，包括：</p>
<ul>
<li><strong>SetWindowsHookEx</strong>：此函数将应用程序定义的挂钩过程安装到挂钩链中。恶意软件可以使用此功能监视和拦截系统事件，例如击键或鼠标点击。<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa">SetWindowsHookEx</a></li>
<li><strong>GetAsyncKeyState</strong>：此函数在调用时检索虚拟键的状态。恶意软件可以使用此函数来确定是否按下或释放了某个键。 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getasynckeystate">GetAsyncKeyState</a></li>
<li><strong>GetKeyboardState</strong>：此函数检索所有虚拟按键的状态。恶意软件可以使用此函数确定键盘上所有按键的状态。<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getkeyboardstate">GetKeyboardState</a></li>
<li><strong>GetKeyNameText</strong>：此函数检索按键的名称。恶意软件可以使用此函数确定所按下按键的名称。<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getkeynametexta">GetKeyNameText</a></li>
</ul>
<p>利用这些 API，恶意软件可以拦截和记录按键，从而获取密码和信用卡号等敏感信息。</p>
<h2 id="下载器"><a href="#下载器" class="headerlink" title="下载器"></a>下载器</h2><p>下载器是一种恶意软件，旨在将其他恶意软件下载到受害者的系统中。下载器可以伪装成合法软件或文件，并通过恶意电子邮件附件、软件下载或利用软件中的漏洞进行传播。下载器可以使用各种 Windows API 来执行恶意操作。下载器常用的一些 API 包括：</p>
<ul>
<li><strong>URLDownloadToFile</strong>：此函数从互联网下载文件并将其保存到本地文件。恶意软件可以使用此功能下载其他恶意代码或恶意软件更新。<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms775123(v=vs.85)">URLDownloadToFile</a></li>
<li><strong>WinHttpOpen</strong>：此函数初始化 WinHTTP API。恶意软件可以使用此功能与远程服务器建立 HTTP 连接并下载其他恶意代码。 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winhttp/nf-winhttp-winhttpopen">WinHttpOpen</a></li>
<li><strong>WinHttpConnect</strong>：此函数使用 WinHTTP API 建立与远程服务器的连接。恶意软件可以使用此函数连接到远程服务器并下载其他恶意代码。<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winhttp/nf-winhttp-winhttpconnect">WinHttpConnect</a></li>
<li><strong>WinHttpOpenRequest</strong>：此函数使用 WinHTTP API 打开 HTTP 请求。恶意软件可以使用此函数将 HTTP 请求发送到远程服务器并下载其他恶意代码或窃取数据。<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winhttp/nf-winhttp-winhttpopenrequest">WinHttpOpenRequest</a></li>
</ul>
<h2 id="C2-通信"><a href="#C2-通信" class="headerlink" title="C2 通信"></a>C2 通信</h2><p>命令和控制 (C2) 通信是恶意软件用来与远程服务器或攻击者通信的一种方法。此通信可用于接收来自攻击者的命令、向攻击者发送被盗数据或将其他恶意软件下载到受害者的系统上。</p>
<ul>
<li><strong>InternetOpen</strong>：此函数初始化用于连接互联网的会话。恶意软件可以使用此函数连接到远程服务器并与命令和控制 (C2) 服务器通信。<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopena">InternetOpen</a></li>
<li><strong>InternetOpenUrl</strong>：此函数打开一个 URL 进行下载。恶意软件可以使用此函数下载其他恶意代码或从 C2 服务器窃取数据。<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopenurla">InternetOpenUrl</a></li>
<li><strong>HttpOpenRequest</strong>：此函数打开 HTTP 请求。恶意软件可以使用此函数向 C2 服务器发送 HTTP 请求并接收命令或其他恶意代码。 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-httpopenrequesta">HttpOpenRequest</a></li>
<li><strong>HttpSendRequest</strong>：此函数向 C2 服务器发送 HTTP 请求。恶意软件可以使用此函数从 C2 服务器发送数据或接收命令。<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-httpsendrequesta">HttpSendRequest</a></li>
</ul>
<h2 id="数据泄露"><a href="#数据泄露" class="headerlink" title="数据泄露"></a>数据泄露</h2><p>数据泄露是指未经授权将数据从组织传输到外部目的地。恶意软件可以使用各种 Windows API 执行数据泄露，包括：</p>
<ul>
<li><strong>InternetReadFile</strong>：此函数从开放互联网资源的句柄读取数据。</li>
</ul>
<p>恶意软件可以使用此功能从受感染的系统中窃取数据并将其传输到 C2 服务器。<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetreadfile">InternetReadFile</a></p>
<ul>
<li><strong>FtpPutFile</strong>：此功能将文件上传到 FTP 服务器。恶意软件可以使用此功能将被盗数据泄露到远程服务器。<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-ftpputfilea">FtpPutFile</a></li>
<li><strong>CreateFile</strong>：此功能创建或打开文件或设备。恶意软件可以使用此功能读取或修改包含敏感信息或系统配置数据的文件。 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a></li>
<li><strong>WriteFile</strong>：此函数将数据写入文件或设备。恶意软件可以使用此函数将窃取的数据写入文件，然后将其泄露到远程服务器。<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile">WriteFile API</a></li>
<li>GetClipboardData：此 API 用于从剪贴板检索数据。恶意软件可以使用此 API 检索复制到剪贴板的敏感数据。<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getclipboarddata">GetClipboardData</a></li>
</ul>
<h2 id="Dropper"><a href="#Dropper" class="headerlink" title="Dropper"></a>Dropper</h2><p>Dropper 是一种旨在将其他恶意软件安装到受害者系统的恶意软件。 Dropper 可以伪装成合法软件或文件，并通过恶意电子邮件附件、软件下载或利用软件中的漏洞进行传播。</p>
<ul>
<li><strong>CreateProcess</strong>：此函数创建一个新进程及其主线程。恶意软件可以使用此函数在合法进程的上下文中执行其代码，从而更难以检测和分析。<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a></li>
<li><strong>VirtualAlloc</strong>：此函数在调用进程的虚拟地址空间内保留或提交内存区域。恶意软件可以使用此函数分配内存来存储其代码。 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a></li>
<li><strong>WriteProcessMemory</strong>：此函数将数据写入指定进程地址空间内的内存区域。恶意软件可以使用此函数将其代码写入分配的内存。<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory">WriteProcessMemory</a></li>
</ul>
<h2 id="API-挂钩"><a href="#API-挂钩" class="headerlink" title="API 挂钩"></a>API 挂钩</h2><p>API 挂钩是恶意软件用来拦截对 Windows API 的调用并修改其行为的一种方法。这允许恶意软件避免被安全软件检测到并执行恶意操作，例如窃取数据或修改系统设置。恶意软件可以使用各种 API 进行挂钩，包括：</p>
<ul>
<li><strong>GetProcAddress</strong>：此函数从指定的动态链接库 (DLL) 中检索导出函数或变量的地址。恶意软件可以使用此函数来定位和挂接其他进程发出的 API 调用。<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a></li>
<li><strong>LoadLibrary</strong>：此函数将动态链接库 (DLL) 加载到进程的地址空间中。恶意软件可以使用此函数从 DLL 或其他模块加载并执行其他代码。<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a></li>
<li><strong>SetWindowsHookEx</strong> API：此 API 用于安装挂接程序，用于监视发送到窗口或系统事件的消息。恶意软件可以使用此 API 拦截对其他 Windows API 的调用并修改其行为。 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa">SetWindowsHookEx API</a></li>
</ul>
<h2 id="反调试和-VM-检测"><a href="#反调试和-VM-检测" class="headerlink" title="反调试和 VM 检测"></a>反调试和 VM 检测</h2><p>反调试和虚拟机检测是恶意软件用来逃避安全研究人员检测和分析的技术。以下是用于这些目的的一些常见 Windows API：</p>
<h3 id="IsDebuggerPresent："><a href="#IsDebuggerPresent：" class="headerlink" title="IsDebuggerPresent："></a>IsDebuggerPresent：</h3><p>此函数检查进程是否在调试器下运行。恶意软件可以使用此函数确定是否正在分析该进程，并采取适当的措施逃避检测。IsDebuggerPresent</p>
<h3 id="CheckRemoteDebuggerPresent："><a href="#CheckRemoteDebuggerPresent：" class="headerlink" title="CheckRemoteDebuggerPresent："></a>CheckRemoteDebuggerPresent：</h3><p>此函数检查远程调试器是否正在调试进程。恶意软件可以使用此函数确定是否正在分析该进程，并采取适当的措施逃避检测。CheckRemoteDebuggerPresent</p>
<h3 id="NtQueryInformationProcess："><a href="#NtQueryInformationProcess：" class="headerlink" title="NtQueryInformationProcess："></a>NtQueryInformationProcess：</h3><p>此函数检索有关指定进程的信息。恶意软件可以使用此函数确定是否正在调试该进程，并采取适当的措施逃避检测。NtQueryInformationProcess</p>
<h3 id="GetTickCount："><a href="#GetTickCount：" class="headerlink" title="GetTickCount："></a>GetTickCount：</h3><p>此函数检索自系统启动以来经过的毫秒数。恶意软件可以使用此函数来确定它是否在虚拟化环境中运行，这可能表明它正在被分析。GetTickCount</p>
<h3 id="GetModuleHandle："><a href="#GetModuleHandle：" class="headerlink" title="GetModuleHandle："></a>GetModuleHandle：</h3><p>此函数检索指定模块的句柄。恶意软件可以使用此函数来确定它是否在虚拟化环境中运行，这可能表明它正在被分析。GetModuleHandle</p>
<h3 id="GetSystemMetrics："><a href="#GetSystemMetrics：" class="headerlink" title="GetSystemMetrics："></a>GetSystemMetrics：</h3><p>此函数检索各种系统指标和配置设置。恶意软件可以使用此函数来确定它是否在虚拟化环境中运行，这可能表明它正在被分析。GetSystemMetrics<br>有关反调试/AV 检测的详细信息，请参阅此房间 <a target="_blank" rel="noopener" href="https://tryhackme.com/room/antireverseengineering">反逆向工程</a>。</p>
<h1 id="Process-Hollowing-Overview"><a href="#Process-Hollowing-Overview" class="headerlink" title="Process Hollowing: Overview"></a>Process Hollowing: Overview</h1><p>现在我们已经了解了如何识别汇编中的代码构造，让我们利用之前获得的知识来理解和分析称为进程挖空的进程注入技术，恶意软件主要使用这种技术来逃避检测。</p>
<h2 id="进程挖空"><a href="#进程挖空" class="headerlink" title="进程挖空"></a>进程挖空</h2><p>进程挖空是恶意软件用来将恶意代码注入受害者计算机上运行的合法进程的一种技术。恶意软件创建一个挂起的进程，并用自己的代码替换其内存空间。然后恶意软件恢复该进程，使其执行注入的代码。由于恶意代码是在合法进程的上下文中执行的，因此这种技术允许恶意软件绕过可能存在的安全措施。</p>
<h2 id="如何实现进程挖空"><a href="#如何实现进程挖空" class="headerlink" title="如何实现进程挖空"></a>如何实现进程挖空</h2><p>进程挖空涉及几个步骤：</p>
<p>使用 CreateProcessA() API 创建一个新进程。此进程将充当合法进程并将被挖空。<br>然后使用 NtSuspendProcess() 暂停新进程。<br>使用 VirtualAllocEx() API 在挂起的进程中分配内存。此内存将用于保存恶意代码。<br>使用 WriteProcessMemory() API 将恶意代码写入分配的内存。<br>使用 SetThreadContext() 和 GetThreadContext() API 修改进程的入口点以指向恶意代码的地址。<br>使用 NtResumeProcess() API 恢复暂停的进程。这将导致进程执行恶意代码。<br>清理进程以及进程期间使用的任何资源。<br>为了更好地理解我们所介绍的技术，下面添加了一个示例 C++ 代码：</p>
<pre><code>#include 
#include 
#include 
using namespace std;

bool HollowProcess(char *szSourceProcessName, char *szTargetProcessName)
{
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    PROCESSENTRY32 pe;
    pe.dwSize = sizeof(PROCESSENTRY32);

    if (Process32First(hSnapshot, &amp;pe))
    {
        do
        {
            if (_stricmp((const char*)pe.szExeFile, szTargetProcessName) == 0)
            {
                HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe.th32ProcessID);
                if (hProcess == NULL)
                {
                    return false;
                }

                IMAGE_DOS_HEADER idh;
                IMAGE_NT_HEADERS inth;
                IMAGE_SECTION_HEADER ish;

                DWORD dwRead = 0;

                ReadProcessMemory(hProcess, (LPVOID)pe.modBaseAddr, &amp;idh, sizeof(idh), &amp;dwRead);
                ReadProcessMemory(hProcess, (LPVOID)(pe.modBaseAddr + idh.e_lfanew), &amp;inth, sizeof(inth), &amp;dwRead);

                LPVOID lpBaseAddress = VirtualAllocEx(hProcess, NULL, inth.OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

                if (lpBaseAddress == NULL)
                {
                    return false;
                }

                if (!WriteProcessMemory(hProcess, lpBaseAddress, (LPVOID)pe.modBaseAddr, inth.OptionalHeader.SizeOfHeaders, &amp;dwRead))
                {
                    return false;
                }

                for (int i = 0; i &lt; inth.FileHeader.NumberOfSections; i++)
                {
                    ReadProcessMemory(hProcess, (LPVOID)(pe.modBaseAddr + idh.e_lfanew + sizeof(IMAGE_NT_HEADERS) + (i * sizeof(IMAGE_SECTION_HEADER))), &amp;ish, sizeof(ish), &amp;dwRead);
                    WriteProcessMemory(hProcess, (LPVOID)((DWORD)lpBaseAddress + ish.VirtualAddress), (LPVOID)((DWORD)pe.modBaseAddr + ish.PointerToRawData), ish.SizeOfRawData, &amp;dwRead);
                }

                DWORD dwEntrypoint = (DWORD)pe.modBaseAddr + inth.OptionalHeader.AddressOfEntryPoint;
                DWORD dwOffset = (DWORD)lpBaseAddress - inth.OptionalHeader.ImageBase + dwEntrypoint;

                if (!WriteProcessMemory(hProcess, (LPVOID)(lpBaseAddress + dwEntrypoint - (DWORD)pe.modBaseAddr), &amp;dwOffset, sizeof(DWORD), &amp;dwRead))
                {
                    return false;
                }

                CloseHandle(hProcess);

                break;
            }
        } while (Process32Next(hSnapshot, &amp;pe));
    }

    CloseHandle(hSnapshot);

    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&amp;si, sizeof(si));
    ZeroMemory(&amp;pi, sizeof(pi));

    if (!CreateProcess(NULL, szSourceProcessName, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi))
    {
        return false;
    }

    CONTEXT ctx;
    ctx.ContextFlags = CONTEXT_FULL;

    if (!GetThreadContext(pi.hThread, &amp;ctx))
    {
        return false;
    }

    ctx.Eax = (DWORD)pi.lpBaseOfImage + ((IMAGE_DOS_HEADER*)pi.lpBaseOfImage)-&gt;e_lfanew + ((IMAGE_NT_HEADERS*)(((BYTE*)pi.lpBaseOfImage) + ((IMAGE_DOS_HEADER*)pi.lpBaseOfImage)-&gt;e_lfanew))-&gt;OptionalHeader.AddressOfEntryPoint;

    if (!SetThreadContext(pi.hThread, &amp;ctx))
    {
        return false;
    }

    ResumeThread(pi.hThread);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);

    return true;
}

int main()
{
    char* szSourceProcessName = "C:\\\\Windows\\\\System32\\\\calc.exe";
    char* szTargetProcessName = "notepad.exe";

    if (HollowProcess(szSourceProcessName, szTargetProcessName))
    {
        cout &lt;&lt; "Process hollowing successful" &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; "Process hollowing failed" &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
<p>现在我们已经了解了如何实现进程挖空，现在是时候探索 Ghidra 反汇编程序并在实验室中检查进程挖空样本 benign.exe 了。</p>
<h1 id="Analyzing-Process-Hollowing"><a href="#Analyzing-Process-Hollowing" class="headerlink" title="Analyzing Process Hollowing"></a>Analyzing Process Hollowing</h1><p>现在我们了解了什么是进程挖空以及如何使用 Ghidra 反汇编程序分析恶意软件以更好地了解其来龙去脉，让我们创建一个新项目并将位于桌面上的 Benign.exe 示例加载到 Ghidra 中。</p>
<p>需要注意的一点是，几乎所有恶意软件都带有已知或自定义的打包程序，并且还采用了不同的反调试/VM 检测技术来阻碍分析。这个主题将在下一个房间中介绍。示例未在此任务中打包，并且未应用任何反调试/VM 检测技术。</p>
<p>我们进行高级静态分析的目标是：</p>
<p>检查 API 调用以查找模式或可疑调用。<br>查看可疑字符串。<br>查找有趣或恶意的函数。<br>检查反汇编/反编译的代码以查找尽可能多的信息。<br>让我们开始分析。</p>
<p><code>加载示例</code>：加载程序；它将显示摘要，如下所示：</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/23cb7630645de4ffa08c33ab62356ea0.png"></p>
<p><code>分析</code>：让 Ghidra 分析样本。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/0a744d5cbed645b8de22c0872efb582b.png"></p>
<p>Ghidra 不会自动在程序启动时启动。由我们来选择首先要分析哪个函数。我们将开始研究用于完成进程挖空的 Windows API。</p>
<p><code>注意</code>：需要指出的是，立即开始搜索 CreateProcessA 函数并不是分析师开始分析未知二进制文件的方式。</p>
<h2 id="CreateProcess"><a href="#CreateProcess" class="headerlink" title="CreateProcess"></a>CreateProcess</h2><p>我们在上一个任务中了解到，在进程挖空中，可疑进程会创建一个处于挂起状态的受害进程。为了确认，让我们在符号树部分中搜索 <code>CreateProcessA</code> API。然后，右键单击 <code>Show References</code> 选项以显示调用此函数的所有程序部分。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/8fa4dfa56dc48c298209eabe8e9bdfa0.png"></p>
<p>单击第一个引用将带我们到反汇编的代码并在反编译部分显示反编译的 C 代码。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/5f7d90c1e105a4b0e5906b1768a00d67.png"></p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/a128471d7f022eab2ad3d78dc08b913c.png"></p>
<p>它清楚地显示了在调用函数之前，堆栈上的参数是如何以相反的顺序被推送的。进程创建标志中的值 0x4 被推送到堆栈中，代表暂停状态。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/1fb01debad5d05ad08f3e84889000a81.png"></p>
<h2 id="Graph-View"><a href="#Graph-View" class="headerlink" title="Graph View"></a>Graph View</h2><p>点击工具栏中的“显示函数图”将显示我们正在检查的反汇编代码的图形视图。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/72ed0c7a08de545195403621dac05411.png"></p>
<p>在上述情况下，如果程序：</p>
<p>无法在挂起状态下创建受害进程，它将移动到块 1。红色箭头表示未能满足上述条件。<br>成功创建受害进程，它将移动到块 2。绿色箭头表示跳转条件成功。</p>
<h2 id="打开可疑文件"><a href="#打开可疑文件" class="headerlink" title="打开可疑文件"></a>打开可疑文件</h2><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFileA API</a> 用于创建或打开现有文件。让我们在符号树部分中搜索此 API 调用，并转到它引用的代码。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/e70072a69662db2d73e502fd5f7d82e2.png"></p>
<h2 id="Hollow-the-Process"><a href="#Hollow-the-Process" class="headerlink" title="Hollow the Process"></a>Hollow the Process</h2><p>恶意软件使用 <code>ZwUnmapViewOfSection</code> 或 <code>NtUnmapViewOfSection</code> API 调用来取消映射目标进程的内存。让我们搜索一下这两个 API，看看是否调用了其中一个 API。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/73581248f62e8778becab5ab669d925a.png"></p>
<p><code>NtUnmapViewOfSection</code> 恰好接受两个参数，即要取消映射的基地址（虚拟地址）和需要挖空的进程的句柄。</p>
<h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>一旦进程被挖空，恶意软件必须使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex">VirtualAllocEx</a> 分配内存，然后再写入进程。让我们以相同的方式找到 VirtualAllocEx API 调用的实例。传递给该函数的参数包括进程的句柄、要分配的地址、大小、分配类型和内存保护标志。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/4d386a49c2ce6297dbf0dce79ad5bc2b.png"></p>
<h2 id="Write-Down-the-Memory"><a href="#Write-Down-the-Memory" class="headerlink" title="Write Down the Memory"></a>Write Down the Memory</h2><p>一旦分配了内存，恶意软件就会尝试将可疑的进程/代码写入被挖空的进程的内存中。 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory">WriteProcessMemory</a> API 就是用于此目的。让我们找到该函数并分析代码。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/a3036f1fc16a5e9cc12177fcbc0a395d.png"></p>
<p>对 <code>WriteProcessMemory</code> 函数有三次调用。最后一次调用引用了 Kernel32 DLL 中的代码；因此，我们可以忽略它。从反编译的代码来看，该程序似乎正在逐个复制可疑进程的不同部分。</p>
<h2 id="恢复线程"><a href="#恢复线程" class="headerlink" title="恢复线程"></a>恢复线程</h2><p>一旦一切都整理好，恶意软件将使用 SetThreadContext 控制线程，然后使用 ResumeThread API 恢复线程以执行代码。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5e8dd9a4a45e18443162feab/room-content/ae784a683a2d91112d923f6e22ae6b8f.png"></p>
<p>在这里，我们可以看到程序如何设置线程上下文，然后恢复它来执行恶意代码。</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>呼！！</p>
<p>终于，我们走到了尽头。这个房间讲授了以下内容：</p>
<ul>
<li>使用 Ghidra 工具对恶意软件执行高级静态分析的基础知识</li>
<li>恶意软件使用的常见 API</li>
<li>进程 Hollowing 的工作原理</li>
</ul>
<p>执行高级静态分析后的下一步是高级动态分析，接下来将介绍该分析。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.mikannse.cn">Mikannse</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.mikannse.cn/2024/11/04/THMAdvancedStaticAnalysis/">https://blog.mikannse.cn/2024/11/04/THMAdvancedStaticAnalysis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.mikannse.cn" target="_blank">MikannseのSekai</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="post-meta__tags" href="/tags/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/">恶意软件分析</a><a class="post-meta__tags" href="/tags/%E9%80%86%E5%90%91/">逆向</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/11/04/THMBasicDynamicAnalysis/" title="THMBasicDynamicAnalysis"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">THMBasicDynamicAnalysis</div></div></a></div><div class="next-post pull-right"><a href="/2024/11/02/THMBasicStaticAnalysis/" title="THMBasicStaticAnalysis"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">THMBasicStaticAnalysis</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/11/04/THMBasicDynamicAnalysis/" title="THMBasicDynamicAnalysis"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-04</div><div class="title">THMBasicDynamicAnalysis</div></div></a></div><div><a href="/2024/11/02/THMBasicStaticAnalysis/" title="THMBasicStaticAnalysis"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-02</div><div class="title">THMBasicStaticAnalysis</div></div></a></div><div><a href="/2024/11/12/THMDynamicAnalysisDebugging/" title="THMDynamicAnalysisDebugging"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-12</div><div class="title">THMDynamicAnalysisDebugging</div></div></a></div><div><a href="/2024/11/02/THMIntrotoMalwareAnalysis/" title="THMIntrotoMalwareAnalysis"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-02</div><div class="title">THMIntrotoMalwareAnalysis</div></div></a></div><div><a href="/2024/11/05/THMMalDocStaticAnalysis/" title="THMMalDocStaticAnalysis"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-05</div><div class="title">THMMalDocStaticAnalysis</div></div></a></div><div><a href="/2024/07/19/CSS%E9%9A%8F%E6%89%8B%E8%AE%B0/" title="CSS随手记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-19</div><div class="title">CSS随手记</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Mikannse</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">313</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">74</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mikannse/mikannse.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">暂时没有公告QAQ</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-number">1.1.</span> <span class="toc-text">高级静态分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87"><span class="toc-number">1.2.</span> <span class="toc-text">学习目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%88%E5%86%B3%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">先决条件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Malware-Analysis-Overview"><span class="toc-number">2.</span> <span class="toc-text">Malware Analysis: Overview</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ghidra-A-Quick-Overview"><span class="toc-number">3.</span> <span class="toc-text">Ghidra: A Quick Overview</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Identifying-C-Code-Constructs-in-Assembly"><span class="toc-number">4.</span> <span class="toc-text">Identifying C Code Constructs in Assembly</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#An-Overview-of-Windows-API-Calls"><span class="toc-number">5.</span> <span class="toc-text">An Overview of Windows API Calls</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Common-APIs-used-by-Malware"><span class="toc-number">6.</span> <span class="toc-text">Common APIs used by Malware</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95%E5%99%A8"><span class="toc-number">6.1.</span> <span class="toc-text">键盘记录器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E5%99%A8"><span class="toc-number">6.2.</span> <span class="toc-text">下载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C2-%E9%80%9A%E4%BF%A1"><span class="toc-number">6.3.</span> <span class="toc-text">C2 通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2"><span class="toc-number">6.4.</span> <span class="toc-text">数据泄露</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dropper"><span class="toc-number">6.5.</span> <span class="toc-text">Dropper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API-%E6%8C%82%E9%92%A9"><span class="toc-number">6.6.</span> <span class="toc-text">API 挂钩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%B0%83%E8%AF%95%E5%92%8C-VM-%E6%A3%80%E6%B5%8B"><span class="toc-number">6.7.</span> <span class="toc-text">反调试和 VM 检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IsDebuggerPresent%EF%BC%9A"><span class="toc-number">6.7.1.</span> <span class="toc-text">IsDebuggerPresent：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CheckRemoteDebuggerPresent%EF%BC%9A"><span class="toc-number">6.7.2.</span> <span class="toc-text">CheckRemoteDebuggerPresent：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NtQueryInformationProcess%EF%BC%9A"><span class="toc-number">6.7.3.</span> <span class="toc-text">NtQueryInformationProcess：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetTickCount%EF%BC%9A"><span class="toc-number">6.7.4.</span> <span class="toc-text">GetTickCount：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetModuleHandle%EF%BC%9A"><span class="toc-number">6.7.5.</span> <span class="toc-text">GetModuleHandle：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetSystemMetrics%EF%BC%9A"><span class="toc-number">6.7.6.</span> <span class="toc-text">GetSystemMetrics：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Process-Hollowing-Overview"><span class="toc-number">7.</span> <span class="toc-text">Process Hollowing: Overview</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8C%96%E7%A9%BA"><span class="toc-number">7.1.</span> <span class="toc-text">进程挖空</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E6%8C%96%E7%A9%BA"><span class="toc-number">7.2.</span> <span class="toc-text">如何实现进程挖空</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Analyzing-Process-Hollowing"><span class="toc-number">8.</span> <span class="toc-text">Analyzing Process Hollowing</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CreateProcess"><span class="toc-number">8.1.</span> <span class="toc-text">CreateProcess</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Graph-View"><span class="toc-number">8.2.</span> <span class="toc-text">Graph View</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E5%8F%AF%E7%96%91%E6%96%87%E4%BB%B6"><span class="toc-number">8.3.</span> <span class="toc-text">打开可疑文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hollow-the-Process"><span class="toc-number">8.4.</span> <span class="toc-text">Hollow the Process</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">8.5.</span> <span class="toc-text">分配内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Write-Down-the-Memory"><span class="toc-number">8.6.</span> <span class="toc-text">Write Down the Memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E7%BA%BF%E7%A8%8B"><span class="toc-number">8.7.</span> <span class="toc-text">恢复线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Conclusion"><span class="toc-number">9.</span> <span class="toc-text">Conclusion</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/28/THMDependencyManagement/" title="THMDependencyManagement">THMDependencyManagement</a><time datetime="2025-02-28T12:59:01.000Z" title="发表于 2025-02-28 20:59:01">2025-02-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/03/25-1%E6%9D%82%E8%B0%88/" title="25-1杂谈">25-1杂谈</a><time datetime="2025-02-03T04:48:34.000Z" title="发表于 2025-02-03 12:48:34">2025-02-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/15/%E6%89%93%E9%9D%B6%E8%AE%B0%E5%BD%95(%E4%B8%80%E5%85%AD%E4%B9%9D)%E4%B9%8BVulnHubSNAKEOIL/" title="打靶记录(一六九)之VulnHubSNAKEOIL">打靶记录(一六九)之VulnHubSNAKEOIL</a><time datetime="2025-01-15T08:34:34.000Z" title="发表于 2025-01-15 16:34:34">2025-01-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/15/%E6%89%93%E9%9D%B6%E8%AE%B0%E5%BD%95(%E4%B8%80%E5%85%AD%E5%85%AB)%E4%B9%8BVulnHubEvilbox/" title="打靶记录(一六八)之VulnHubEvilbox">打靶记录(一六八)之VulnHubEvilbox</a><time datetime="2025-01-15T06:41:28.000Z" title="发表于 2025-01-15 14:41:28">2025-01-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/06/2024%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/" title="2024年度总结">2024年度总结</a><time datetime="2025-01-05T16:23:47.000Z" title="发表于 2025-01-06 00:23:47">2025-01-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/yjr-1100/Photobag/githubioimg/background_4k.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By Mikannse</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  const disqus_config = function () {
    this.page.url = 'https://blog.mikannse.cn/2024/11/04/THMAdvancedStaticAnalysis/'
    this.page.identifier = '/2024/11/04/THMAdvancedStaticAnalysis/'
    this.page.title = 'THMAdvancedStaticAnalysis'
  }

  const disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addModeChange('disqus', disqusReset)

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>