<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>IntrotoKubernetesTHM | MikannseのSekai</title><meta name="author" content="Mikannse"><meta name="copyright" content="Mikannse"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="Introduction我们将通过引导您了解 Kubernetes 基础知识、一些安全的 K8s 实践以及一些实践经验，将这个似乎每个人都非常喜欢的神秘词变成一个熟悉的术语。开始消除这个谜团，让你不再思考“‘Keights’到底是什么？”。 Kubernetes 有时被称为 K8s，如 k(ubern)8s - 在这个行业中任何可以节省时间的东西！ 学习先决条件 这个房间将延续 DevSecOps">
<meta property="og:type" content="article">
<meta property="og:title" content="IntrotoKubernetesTHM">
<meta property="og:url" content="http://mikannse.space/2024/05/30/IntrotoKubernetesTHM/index.html">
<meta property="og:site_name" content="MikannseのSekai">
<meta property="og:description" content="Introduction我们将通过引导您了解 Kubernetes 基础知识、一些安全的 K8s 实践以及一些实践经验，将这个似乎每个人都非常喜欢的神秘词变成一个熟悉的术语。开始消除这个谜团，让你不再思考“‘Keights’到底是什么？”。 Kubernetes 有时被称为 K8s，如 k(ubern)8s - 在这个行业中任何可以节省时间的东西！ 学习先决条件 这个房间将延续 DevSecOps">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg">
<meta property="article:published_time" content="2024-05-30T03:08:03.000Z">
<meta property="article:modified_time" content="2024-06-14T03:25:37.891Z">
<meta property="article:author" content="Mikannse">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="渗透测试">
<meta property="article:tag" content="运维">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg"><link rel="shortcut icon" href="/img/icon.jpg"><link rel="canonical" href="http://mikannse.space/2024/05/30/IntrotoKubernetesTHM/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Mikannse","link":"链接: ","source":"来源: MikannseのSekai","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'IntrotoKubernetesTHM',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2024-06-14 11:25:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">303</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">74</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/yjr-1100/Photobag/githubioimg/background_4k.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="MikannseのSekai"><span class="site-name">MikannseのSekai</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">IntrotoKubernetesTHM</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-30T03:08:03.000Z" title="发表于 2024-05-30 11:08:03">2024-05-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-14T03:25:37.891Z" title="更新于 2024-06-14 11:25:37">2024-06-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BD%91%E5%AE%89/">网安</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="IntrotoKubernetesTHM"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>我们将通过引导您了解 Kubernetes 基础知识、一些安全的 K8s 实践以及一些实践经验，将这个似乎每个人都非常喜欢的神秘词变成一个熟悉的术语。开始消除这个谜团，让你不再思考“‘Keights’到底是什么？”。 Kubernetes 有时被称为 K8s，如 k(ubern)8s - 在这个行业中任何可以节省时间的东西！</p>
<p>学习先决条件</p>
<p>这个房间将延续 <a target="_blank" rel="noopener" href="https://tryhackme.com/path-action/devsecops/join">DevSecOps</a> 路径，因此所有之前的 DevSecOps 模块都应该完成，尤其是 <a href="%E4%B8%AD%E8%BF%99%E4%B8%AA%E6%88%BF%E9%97%B4%E4%B9%8B%E5%89%8D%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%88%BF%E9%97%B4">Container Security</a> <a target="_blank" rel="noopener" href="https://tryhackme.com/module/container-security%EF%BC%89%E6%A8%A1%E5%9D%97%EF%BC%88[%E5%AE%B9%E5%99%A8%E5%8C%96%E7%AE%80%E4%BB%8B](https://tryhackme.com/jr/introtocontainerization)">https://tryhackme.com/module/container-security）模块（[容器化简介](https://tryhackme.com/jr/introtocontainerization)</a> 和 [Docker 简介](<a target="_blank" rel="noopener" href="https://tryhackme.com/jr">https://tryhackme.com/jr</a> /introtodockerk8pdqk)) 应该完成。</p>
<p>学习目标</p>
<ul>
<li>了解为什么需要像 Kubernetes 这样的系统</li>
<li>了解基本的 Kubernetes 架构</li>
<li>了解 Kubernetes 环境的关键组成部分</li>
<li>了解如何使用 kubectl 遍历 Kubernetes 集群</li>
<li>了解 DevSecOps 工程师如何使用 Kubernetes 以及最佳 K8s 安全实践</li>
</ul>
<h1 id="Kubernetes-101"><a href="#Kubernetes-101" class="headerlink" title="Kubernetes 101"></a>Kubernetes 101</h1><p>新的曙光</p>
<p>为了更好地理解 Kubernetes，让我们首先考虑一下它出现的背景。换句话说，为什么首先需要它？过去，公司采用整体架构更为常见。也就是说，应用程序被构建为单个单元、单个代码库，并且通常作为单个组件部署的单个可执行文件。这对很多公司来说都有效，并且仍然有效。然而，一些公司开始转向微服务架构，因此不再有一个单一的应用程序，而是将其分解为不同的组件，每个组件通常具有不同的业务功能，这意味着可以扩展高需求的业务功能，而无需扩展整个应用程序。一个引人注目的例子发生在 2009 年（在微服务还没有名字之前），当时 Netflix 的单体架构无法满足其日益增长的需求，因此开始采用微服务架构。</p>
<p>微服务架构现在是一种越来越流行的方法，这对于今天的课程如此重要的原因是容器技术为这些微服务提供了完美的宿主。由于微服务架构通常包含数百甚至数千个这样的容器，因此需要一种技术来帮助管理和组织它们——无需猜测是什么技术可以解决这个问题。</p>
<p>进入 Kubernetes</p>
<p>让我们从一个大问题开始吧？什么是 Kubernetes？在本模块的前面的房间中，我们讨论了容器和 Docker，所以让我们以此为出发点。想象一下，您有一个 Docker 容器，正在运行一个可以从外部访问的应用程序。 突然，该应用程序开始接收大量流量，因此需要启动一个包含该应用程序的新容器，以便可以在两者之间分配流量。这就是 Kubernetes 作为容器编排系统的用武之地。 “管弦乐队”这个词让人想起真正的管弦乐队的形象。这个比喻确实有一定的吸引力，容器就像仪器，而 Kubernetes 是控制流程的指挥者。这将是一个非常奇怪的管弦乐队，当歌曲不再需要演奏者时，指挥告诉演奏者离开，并在需要时带来新的演奏者。</p>
<p>Kubernetes 的诸多好处</p>
<p>现在我们已经了解了 Kubernetes 是什么以及为什么需要它，让我们看看这项技术如何使 DevSecOps 领域受益。</p>
<ul>
<li>Kubernetes 使应用程序<strong>高度可用和可扩展</strong>。例如，它通过复制应用程序（及其数据库组件）并将对该应用程序的外部请求负载平衡到可用资源来实现这一点，从而从架构中消除单点故障并消除可能减慢应用程序响应的瓶颈次。如前所述，可扩展性是许多公司非常关心的问题。 Kubernetes 允许扩大或缩小工作负载以满足需求。</li>
<li>Kubernetes 还具有<strong>高度可移植性</strong>，因为它可以在几乎任何类型的基础设施的任何地方运行，并且可以与单个或多云集一起使用，使其成为一个非常灵活的工具。</li>
<li>Kubernetes 的另一个好处是它的受欢迎程度；正因为如此，许多技术都与其兼容，并且可以用来使每个工具变得更加强大。</li>
</ul>
<p>这些只是 Kubernetes 让 DevSecOps 领域受益的几种方式，它解释了为什么这个词被如此广泛地使用！</p>
<h1 id="Kubernetes-Architecture"><a href="#Kubernetes-Architecture" class="headerlink" title="Kubernetes Architecture"></a>Kubernetes Architecture</h1><p>集群架构</p>
<p>好的，我们已经了解了 Kubernetes 是什么、为什么需要它以及它如何使我们在 DevSecOps 中受益。现在，是时候通过深入了解并分析它如何做到这一点来加深我们的理解了。这是正确的！现在是建筑时间！我们将一一介绍构成 Kubernetes 架构的每个关键组件，然后最后将它们组合在一起并展示所有这些组件如何连接。让我们开始吧！</p>
<p><strong>Kubernetes Pod</strong></p>
<p>Pod 是您可以在 Kubernetes 中创建和管理的最小可部署计算单元。当您使用 Kubernetes 进行 DevSecOps 工作时，您会听到很多这个词。您可以将 Pod 视为一组一个或多个容器。这些容器共享存储和网络资源。 因此，同一 Pod 上的容器可以轻松通信，就像它们在同一台机器上一样，同时保持一定程度的隔离。 Pod 在 Kubernetes 中被视为一个复制单元；如果需要扩大工作负载，您将增加运行的 Pod 数量。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/6228f0d4ca8e57005149c3e3/room-content/98b54b6b8427fae556be0cdd516b9e36.svg" alt="pod diagram"></p>
<p><strong>Kubernetes 节点</strong></p>
<p>Kubernetes 工作负载（应用程序）在容器内运行，容器放置在 Pod 中。这些 Pod 在节点上运行。在谈论节点架构时，有两种类型需要考虑。 <strong>控制平面</strong>（也称为“主节点”）和<strong>工作节点</strong>。这两个都有自己的架构/组件，所以让我们来看看它们。节点可以是虚拟机或物理机。可以这样想：如果应用程序在放置在 Pod 中的容器中运行，则节点包含运行 Pod 所需的所有服务。</p>
<p><strong>Kubernetes 集群</strong></p>
<p>在最高层，我们有 Kubernetes 集群；简而言之，集群只是一组节点。</p>
<p>Kubernetes 控制平面</p>
<p>控制平面管理集群中的工作节点和 Pod。它通过使用各种组件来实现这一点。查看每个组件以及它们的职责。然后将它们全部放在控制平面架构图中。</p>
<p><strong>Kube-apiserver</strong></p>
<p>API服务器是控制平面的前端，负责暴露Kubernetes API。 kube-apiserver 组件是可扩展的，这意味着可以创建多个实例，以便对流量进行负载平衡。</p>
<p><strong>Etcd</strong> </p>
<p>Etcd 是一个键/值存储，包含集群数据/集群的当前状态。它具有高可用性和一致性。如果集群中发生更改，例如启动另一个 pod，这将反映在键/值存储、etcd 中。其他控制平面组件依赖 etcd 作为信息存储，并查询它以获取可用资源等信息。</p>
<p><strong>Kube 调度程序</strong></p>
<p>kube-scheduler 组件主动监控集群。它的工作是捕获任何尚未分配给节点的新创建的 Pod，并确保它被分配给一个节点。它根据特定标准做出此决定，例如正在运行的应用程序使用的资源或所有工作节点上的可用资源。</p>
<p><strong>Kube-控制器-管理器</strong></p>
<p>该组件负责运行控制器进程。有许多不同类型的控制器进程，但控制器进程的一个示例是 <strong>节点控制器</strong> 进程，它负责通知节点何时出现故障。然后，控制器管理器将与调度程序组件通信以调度新节点的出现。</p>
<p><strong>云控制器管理器</strong></p>
<p>该组件支持 Kubernetes 集群和云提供商 API 之间的通信。该组件的目的是允许将集群内部通信的组件与通过与云提供商交互进行外部通信的组件分开。这也允许云提供商按照自己的节奏发布功能。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/6228f0d4ca8e57005149c3e3/room-content/84f898f84e80373f4a4a34e1f658d914.svg" alt="Kubernetes uses a Hub and Spoke API pattern"></p>
<p>Kubernetes工作节点</p>
<p>Worker 节点负责维护正在运行的 Pod。让我们看一下每个工作节点上都存在的组件以及它们的职责：</p>
<p><strong>Kubelet</strong> </p>
<p>Kubelet 是一个运行在集群中每个节点上的代理，负责确保容器在 pod 中运行。 Kubelet 提供了 pod 规范，并确保此 pod 规范中详细说明的容器运行且健康！它执行控制器管理器给它的操作，例如，启动内部有容器的 Pod。</p>
<p><strong>Kube-proxy</strong></p>
<p>Kube-proxy 负责集群内的网络通信。它制定网络规则，以便流量可以流动并定向到 Pod（从集群内部或外部）。流量不会直接到达 Pod，而是到达称为服务的东西（它将与一组 Pod 关联），然后被定向到其中一个关联的 Pod。 下一个任务中将详细介绍服务！</p>
<p><strong>Container runtime</strong></p>
<p>Pod 内有运行的容器。为此，必须在每个节点上安装容器运行时。到目前为止，我们已经在本模块中介绍了一个示例，它可能是最受欢迎的选择，Docker。但是，可以使用一些替代方案，例如 rkt 或 runC。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/6228f0d4ca8e57005149c3e3/room-content/1bf22d1f65ab408e71d15d5049d11129.svg" alt="The control plane can communicate with nodes using two paths"></p>
<p>组件之间的通信</p>
<p>好的，我们已经介绍了很多内容。让我们看看我们刚刚介绍的所有这些单独组件如何协同工作来构成 Kubernetes 架构。 Kubernetes 集群包含节点，Kubernetes 通过将容器放入在这些节点上运行的 Pod 来运行工作负载。请看下图，了解所有这些组件是如何组合在一起的。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/6228f0d4ca8e57005149c3e3/room-content/1eba5a686238be009bc802dd419a09c8.svg" alt="Cluster diagram"></p>
<h1 id="Kubernetes-Landscape"><a href="#Kubernetes-Landscape" class="headerlink" title="Kubernetes Landscape"></a>Kubernetes Landscape</h1><p>The Lay of the Land</p>
<p>我们刚刚了解了 Kubernetes 架构以及事物的工作原理和幕后设置！现在是时候向您展示这片土地的情况了。换句话说，作为一名 DevSecOps 工程师，您每天会与什么互动？我们将介绍 Kubernetes 中一些最常见的概念并详细解释它们的含义。</p>
<p><strong>Namespaces</strong></p>
<p>在 Kubernetes 中，命名空间用于隔离单个集群中的资源组。例如，假设您想要对与特定组件关联的资源进行分组，或者如果您使用集群来托管多个租户，则按租户对资源进行分组。资源在命名空间内必须唯一命名，但相同的资源名称可以在不同的命名空间中使用。</p>
<p><strong>ReplicaSet</strong></p>
<p>顾名思义，Kubernetes 中的 ReplicaSet 维护一组副本 pod，并且可以保证 x 个相同 pod 的可用性（当需要在多个 pod 之间分配工作负载时，相同 pod 很有帮助）。 ReplicaSet 通常不是直接定义的（就此而言，pod 也不是），而是由部署进行管理，这给我们带来了下一个概念。</p>
<p><strong>Deployments</strong> </p>
<p>Kubernetes 中的部署用于定义所需的状态。一旦定义了所需状态，部署控制器（控制器进程之一）就会将实际状态更改为所需状态。部署为 Pod 和副本集提供声明性更新。换句话说，作为用户，您可以定义部署，例如“test-nginx-deployment”。在定义中，您可以注意到您希望此部署有一个包含三个 nginx pod 的 ReplicaSet。一旦定义了此部署，ReplicaSet 将在后台创建 Pod。</p>
<p><strong>StatefulSets</strong> </p>
<p>要了解 Kubernetes Statefulset 是什么，您必须首先了解有状态应用程序和无状态应用程序之间的区别。有状态应用程序存储和记录用户数据，允许它们返回到特定状态。例如，假设您有一个使用电子邮件应用程序的开放会话并阅读了 3 封电子邮件，但您的会话被中断。在这种情况下，您可以重新加载此应用程序，并且状态将被保存，确保这 3 封电子邮件仍然被阅读。然而，无状态应用程序不知道任何先前的用户交互，因为它不存储用户会话数据。例如，考虑使用搜索引擎提出问题。如果该会话被中断，您可以通过搜索问题重新开始该过程，而不依赖于任何先前的会话数据。</p>
<p>对于这些无状态应用程序（搜索引擎示例），部署可用于定义和管理 Pod 副本。由于应用程序的无状态性质，可以使用随机 Pod 名称创建副本，并且在删除时可以随机删除 Pod。</p>
<p>但是，对于有状态应用程序（电子邮件示例）而言，情况并非如此，因为有状态应用程序需要访问和更新用户会话的当前状态。想象一下当前状态存储在跨 3 个 Pod 运行的数据库中（意味着数据库被复制 3 次）。现在，当其中一个数据库更新时会发生什么？这会使两个数据库不同步。这就是 StatefulSet 的用武之地，也是您使用 StatefulSet 而不是部署来管理 Kubernetes 中的有状态应用程序的原因。</p>
<p>Statefulsets 使有状态应用程序能够在 Kubernetes 上运行，但与部署中的 Pod 不同，它们不能以任何顺序创建，并且将具有唯一的 ID（这是持久性的，这意味着如果 Pod 发生故障，它将被恢复并保留此 ID） ）与每个 Pod 关联。 换句话说，这些 Pod 是根据相同规格创建的，但不可互换。 StatefulSets 将有一个可以读取/写入数据库的 pod（因为如果其他 pod 可以的话，将会出现绝对的大屠杀和各种数据不一致），称为 master pod。其他 Pod（称为从属 Pod）只能读取并拥有自己的存储复制，该复制不断同步以确保反映主节点所做的任何更改。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/6228f0d4ca8e57005149c3e3/room-content/3c0a1d5471d84bd4b86ae3e5a9fefa1f.svg" alt="statefulset diagram"></p>
<p><strong>服务</strong></p>
<p>为了更好地理解 Kubernetes 中的服务，了解它们正在解决的问题非常重要。 Kubernetes Pod 是短暂的，这意味着它们的寿命很短，并且会定期启动和销毁。 想象一下现在需要与这些 Pod 建立连接。这可能来自集群内部；也许后端应用程序正在这些 Pod 中运行，并且前端应用程序需要访问它们，或者请求可能来自浏览器，并且这些 Pod 正在运行 Web 应用程序。要进行此连接，需要 IP 地址。 如果IP地址与Pod绑定，那么这些IP地址会频繁变化，导致各种问题；使用服务以便单个静态 IP 地址可以与 Pod 及其副本关联。 换句话说，服务被放置在这些 pod 前面并公开它们，充当访问点。拥有这个单一访问点可以让请求在 Pod 副本之间实现负载平衡。您可以定义不同类型的服务：ClusterIP、LoadBalancer、NodePort 和ExternalName。要了解有关这些类型和服务的更多信息，请查看<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types">此处</a>。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/6228f0d4ca8e57005149c3e3/room-content/263deb8228845aed0db78319097bd63b.svg" alt="The source of the traffic will depend on the type of service"></p>
<p><strong>入口</strong></p>
<p>在上面有关 Kubernetes 服务的部分中，我们提到了一个应用程序示例，可以通过使用服务公开运行该应用程序的 pod（我们将此称为服务 A）来访问该应用程序。现在想象一下这个 Web 应用程序有一个新功能。这个新功能需要自己的应用程序，因此有自己的一组 pod，这些 pod 由单独的服务（我们将此服务称为 B）公开。现在，假设用户请求访问 Web 应用程序的这一新功能；需要某种流量路由来确保该请求定向到服务 B。这就是入口的用武之地。入口充当集群的单个访问点，意味着所有路由规则都位于单个资源中。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/6228f0d4ca8e57005149c3e3/room-content/1b0ab1f0b6ee779c1ee6f2a3f4d4924c.svg" alt="Ingress diagram"></p>
<p>K8s 中的 DevOps 与 DevSecOps</p>
<p>此任务向您展示了一些协同工作以构建集群的 Kubernetes 资源。接下来，我们将讨论如何与该集群交互以创建这些组件，但在此之前，这是讨论 K8s 世界中的分工的好时机。理解 DevOps 和 DevSecOps 职责之间的区别非常重要，尤其是在学习特定职业道路时。在非常高的层面上，您可以将 DevOps 任务视为与构建集群相关的任务，将 DevSecOps 任务视为与保护集群相关的任务。当然，根据公司架构或公司设置，会有一些重叠，但一般来说，这些任务可以定义为其中之一。由于此房间作为介绍，因此首先向您展示 Kubernetes 集群的构建块以及如何与这些资源（DevOps 任务）进行交互。由于这些知识是基础知识，因此当我们讨论保护集群（DevSecOps 任务）时，理解这些概念将有助于您完成后续任务。话虽这么说，正如前面提到的，这种区别很重要，特别是对于那些追求特定职业道路的人来说，所以请记住这一点！</p>
<h1 id="Kubernetes-Configuration"><a href="#Kubernetes-Configuration" class="headerlink" title="Kubernetes Configuration"></a>Kubernetes Configuration</h1><p>配置时间</p>
<p>现在我们已经介绍了 Kubernetes 中使用的一些关键组件，让我们将其中一些组件组合起来，并向您介绍如何配置它！我们将使用的示例是控制 ReplicaSet 的部署，该 ReplicaSet 管理服务公开的 pod。</p>
<p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/6228f0d4ca8e57005149c3e3/room-content/a0872c63c555b82e63ce1ea3dbed6c42.svg" alt="Interfacing with deployment diagram"></p>
<p>要配置此设置，我们需要两个配置文件，一个用于部署，一个用于服务。在向您介绍每个文件的工作方式之前，让我们先了解一下 Kubernetes 中的一些基本配置，这些配置将在这两个文件（以及所有配置文件）中保持一致。</p>
<p>首先，让我们讨论一下文件格式。Kubernetes 配置文件通常以 YAML 编写。它们也可以使用 JSON 格式互换，但根据 Kubernetes 文档，通常认为使用 YAML 是最佳做法，因为它简单易读（只需注意缩进！）。</p>
<p><strong>必填字段</strong></p>
<p>接下来，让我们讨论每个 YAML 文件中必须存在的四个字段，并细分每个文件中需要包含的内容：</p>
<p><strong>apiVersion：</strong>您将用于创建此对象的 Kubernetes API 版本。您使用的 API 版本将取决于所定义的对象。可以在 <a target="_blank" rel="noopener" href="https://matthewpalmer.net/kubernetes-app-developer/articles/kubernetes-apiversion-definition-guide.html">此处</a> 找到有关哪个对象使用哪个 API 版本的备忘单。</p>
<p><strong>kind：</strong>您要创建哪种类型的对象（例如 Deployment、Service、StatefulSet）。</p>
<p><strong>metadata：</strong>这将包含可用于唯一标识对象的数据（包括名称和可选的命名空间）。</p>
<p><strong>spec：</strong>对象的期望状态（对于部署，这可能是 3 个 nginx pod）。</p>
<p><strong>配置资源</strong></p>
<p>这些是 Kubernetes YAML 配置文件的基础。让我们考虑一下这些，现在看看上面提到的两个文件。我们首先来看一下服务配置文件，因为在定义部署和服务时，通常最佳做法是先定义服务，然后再定义它指向的后端部署/副本集（这是因为当 Kubernetes 启动容器时，它会为容器启动时运行的每个服务创建一个环境变量）。我们的 example-service.yaml 文件如下所示：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: example-nginx-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 8080</span><br><span class="line">      targetPort: 80</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP</span><br></pre></td></tr></tbody></table></figure>

<p>让我们分解一下：<strong>apiVersion</strong> 设置为 v1（最适合用于此简单服务示例的 Kubernetes API 版本），<strong>kind</strong> 设置为 service。对于 <strong>metadata</strong>，我们只是将此服务称为“example-nginx-service”。<strong>spec</strong> 变得更加有趣，在“selector”下，我们有“app: nginx”。当我们定义部署配置时，这一点很重要，<strong>ports</strong> 信息也是如此，因为我们在这里基本上是在说：“此服务将查找带有 nginx 标签的应用程序并将目标端口 80。这里需要区分‘port’和‘targetPort’字段。‘targetPort’是服务将向其发送请求的端口，即 pod 将监听的端口。‘port’是服务公开的端口。最后，‘type’定义为 ClusterIP（之前，我们讨论过有多种类型的服务，这是其中一种），这是默认的服务类型。现在让我们看一下部署 YAML 并定义此服务将指向的后端：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: example-nginx-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></tbody></table></figure>

<p>您可能注意到的第一件事是，在“spec”字段内，有一个名为“template”的嵌套字段，它本身包含“metadata”和“spec”字段。要理解这一点，请记住此任务开始时的图像。我们正在定义一个控制 ReplicaSet 的部署；在这里，在外部“spec”字段中，我们告诉 Kubernetes，我们希望此 ReplicaSet 中有 3 个副本（相同的 pod）。此 template 字段是 Kubernetes 将用于创建这些 pod 的模板，因此需要其自己的元数据字段（以便可以识别 pod）和 spec 字段（以便 Kubernetes 知道要运行哪个映像以及要监听哪个端口）。请注意，此处定义的端口与服务 YAML 中的端口相同。这是因为服务的目标端口是 80，需要匹配。除此之外，在外部“spec”字段中，您可以看到我们还将“selector”字段设置为具有“matchLabels”，这与我们在服务 YAML 的“selector”字段中定义的内容相匹配。这样服务就可以映射到正确的 pod。通过这两个配置 YAML 文件，我们定义了一个部署，该部署控制一个 ReplicaSet，该 ReplicaSet 管理 3 个 pod，所有 pod 都暴露给一个服务。一切都整合在一起了！</p>
<p>这些配置文件用于定义 Kubernetes 组件的期望状态；Kubernetes 将不断根据集群的当前状态检查此期望状态。使用 etcd（前面任务中提到的控制平面进程之一），Kubernetes 用当前状态填充这些配置文件并进行比较。例如，如果我们告诉 Kubernetes 我们希望运行 3 个 nginx pod，并且它在状态中检测到只有 2 个正在运行的 pod，它将开始采取措施来纠正此问题。</p>
<p>Q1:在配置文件中，您刚刚声明需要 4 个 nginx pod。在哪一个“必填字段”中声明了这一点？</p>
<p>A1:spec</p>
<p>Q2:配置文件用于’deployment’。在哪一个“必填字段”中声明了此内容？<br>A2:kind</p>
<p>Q3:此部署中的 pod 将由服务公开。在服务配置文件中，目标端口设置为 80。您应该将“containerPort”填入什么？</p>
<p>A3:80</p>
<h1 id="Kubectl"><a href="#Kubectl" class="headerlink" title="Kubectl"></a>Kubectl</h1><p>Kubectl 来救场</p>
<p>我们刚刚介绍了如何使用 YAML 配置文件定义集群的所需状态，但目前，这些文件仅以文件形式存在。要将这些文件从配置转换为正在运行的进程，我们需要与集群进行交互。我们可以通过使用不同的方法与控制平面的 apiserver 组件进行交互来实现这一点：如果使用 Kubernetes 仪表板，则使用 UI；如果使用某种脚本，则使用 API；或者使用名为 kubectl 的工具，则使用命令行。此任务重点介绍其中的最后一项。简而言之，kubectl 是 Kubernetes 提供的命令行工具，它允许我们与 Kubernetes 集群的控制平面进行通信，是 DevSecOps 工具库的一个很好的补充。此任务将向您展示如何获取上一个任务中概述的配置文件并应用它们，并为您提供一些此工具的新兵训练营培训，教您一些基本命令，以便您可以像在后花园一样浏览 Kubernetes 集群！</p>
<p><strong>Kubectl apply</strong> </p>
<p>在 YAML 文件中定义部署和服务配置后，下一步就是应用它们，以便 Kubernetes 可以采用所需的配置并将其转变为正在运行的进程。这是使用恰当命名的 apply 命令完成的。例如，如果应用上一个任务中提到的服务 YAML，它将如下所示：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">kubectl apply -f example-deployment.yaml</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Kubectl get</strong> </p>
<p>一旦应用了两种配置，您将需要检查两者的状态以确保一切按预期运行。这可以使用 Kubectl get 命令完成。这是一个非常通用的命令，您在使用 Kubernetes 时会经常使用它。get 命令可用于检查资源的状态。资源类型将跟在“get”后面，然后是“-n”或“–namespace”，后面是命名空间（除非您正在检查集群级资源，如节点）。例如，要检查部署的状态，您可以使用：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">kubectl get pods -n example-namespace</span><br></pre></td></tr></tbody></table></figure>

<p>此命令的输出将类似于以下内容：</p>
<p>​            Terminal        </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">           user@tryhackme$ kubectl get pods -n example-namespace</span><br><span class="line">NAME          READY   STATUS              RESTARTS   AGE</span><br><span class="line">example-pod   1/1     Running             0          2m18s</span><br></pre></td></tr></tbody></table></figure>

<p>如上所述，此命令可用于检查各种资源，例如部署、服务、pod 和 ReplicaSet。</p>
<p><strong>Kubectl describe</strong> </p>
<p>此命令可用于显示资源（或一组资源）的详细信息。这些详细信息有助于故障排除或分析情况。例如，假设集群中的一个 Pod 开始出错，并且您想要获取有关该 Pod 的更多信息以尝试确定其崩溃的原因。您可以运行以下命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">kubectl describe pod example-pod -n example-namespace</span><br></pre></td></tr></tbody></table></figure>

<p>这将返回有关出错 pod 的一些详细信息。例如：</p>
<p>​            Terminal        </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">           user@tryhackme$ kubectl describe pod example-pod -n example-namespace</span><br><span class="line"></span><br><span class="line">Name:             example-pod</span><br><span class="line">Namespace:        example-namespace</span><br><span class="line">Priority:         0</span><br><span class="line">Service Account:  default</span><br><span class="line">Node:             minikube/192.168.49.2</span><br><span class="line">Start Time:       Mon, 22 Jan 2024 14:01:14 +0000</span><br><span class="line">Labels:           &lt;none&gt;</span><br><span class="line">Annotations:      &lt;none&gt;</span><br><span class="line">Status:           Running</span><br><span class="line">IP:               10.244.0.21</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure>

<p>您可以在此处看到 describe 命令详细信息包含一些“事件”。这些事件可以帮助阐明问题所在。有关此事件的更多详细信息，Kubernetes 会从正在运行的 pod 中的每个容器中捕获日志。可以使用我们的下一个命令查看这些日志。</p>
<p><strong>Kubectl logs</strong> </p>
<p>假设您想要查看出错 pod 的应用程序日志。也许您想要查看围绕事件错误的日志。为此，我们将使用 kubectl logs 命令。以下是如何使用这个命令的示例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">kubectl logs example-pod -n example-namespace</span><br></pre></td></tr></tbody></table></figure>

<p>这些日志不仅可以为故障排除提供有价值的见解，还可以为安全分析提供有价值的见解。</p>
<p><strong>Kubectl exec</strong></p>
<p>现在，假设日志信息很有帮助，但仍有一些未解答的问题，并且您想要深入挖掘并访问容器的 shell。kubectl exec 命令将允许您进入容器并执行此操作！如果 pod 有多个容器，您可以使用 <code>-c</code> 或 <code>--container</code> 标志指定容器。此命令为（<code>-it</code> 标志以交互模式运行命令，<code>--</code> 之后的所有内容都将在容器内运行）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">kubectl exec -it example-pod -n example-namespace -- sh</span><br></pre></td></tr></tbody></table></figure>

<p>从这里，您可以在容器内部运行任何您想要的命令。也许您想窥探一下您的安全分析，或者运行命令来测试容器的连接性。</p>
<p><strong>Kubectl port-forward</strong> </p>
<p>另一个方便的命令是 kubectl port-forward。此命令允许您在本地计算机和集群中正在运行的 pod 之间创建安全隧道。这可能有用的一个例子是测试应用程序时。假设我们有一个 nginx Web 应用程序在 3 个由 Web 应用程序服务公开的 pod 中运行。如果您还记得，服务使 pod 可从外部访问。我们获取用于公开这些 pod 的端口并将其映射到我们的本地端口之一。例如，将目标端口（服务公开的端口，在我们的配置示例中为 8080）与本地端口 8090 匹配将使此 Web 应用程序可通过“<a href="http://localhost:8090”在我们的本地计算机上访问。指定的资源是“resource-type/resource-name”。这将使用">http://localhost:8090”在我们的本地计算机上访问。指定的资源是“resource-type/resource-name”。这将使用</a> kubectl port-forward 命令完成，语法如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">kubectl port-forward service/example-service 8090:8080</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Kubernetes-amp-DevSecOps"><a href="#Kubernetes-amp-DevSecOps" class="headerlink" title="Kubernetes &amp; DevSecOps"></a>Kubernetes &amp; DevSecOps</h1><p>好吧，现在你已经对 Kubernetes 非常熟悉了；它不再是熟人，而更像是朋友。你已经了解了该工具的来龙去脉，很快就会有机会亲手试用它，但在此之前，让我们先看看作为一名 DevSecOps 工程师，你将如何使用这个工具。毕竟，这很可能就是你来这里的原因！</p>
<p>Kubernetes 和安全</p>
<p>在我们深入探讨 DevSecOps 工程师在 Kubernetes 集群中负责什么之前，让我们从安全的角度来考虑一下 Kubernetes，以提供一些背景信息。相对而言，Kubernetes 是一个新兴技术。也就是说，它是一种新兴技术。它虽然新兴，但非常受欢迎，许多公司都在采用 Kubernetes，尤其是年轻的科技和初创公司。</p>
<p>将任何工具引入系统都被视为增加安全风险，因为新工具意味着进入该系统的新潜在途径。当使用 Kubernetes 这样的工具时，这些风险会被放大，因为您拥有一个可以相互通信的 Pod 网络。默认设置允许任何 Pod 与另一个 Pod 通信。这意味着需要考虑各种安全问题。作为 DevSecOps 工程师，您有责任确保这些渠道是安全的。</p>
<p>Kubernetes 强化</p>
<p>容器强化是 DevSecOps 工程师保护这些渠道的一种方式，我们将在本模块后面的 <a target="_blank" rel="noopener" href="https://tryhackme.com/room/containerhardening">容器强化</a> 房间中深入探讨这一点。它是使用容器扫描工具检测集群中存在的 CVE 并对其进行修复以确保将安全漏洞风险降至最低的过程。</p>
<p>Kubernetes 强化正是通过按照您作为 DevSecOps 工程师将执行的最佳容器安全实践来强化集群，从而确保这些渠道是安全的。各种公司和政府机构都定义了这些最佳实践；让我们来看看我们可以加强容器安全性的每个领域以及如何做到这一点。</p>
<p><strong>保护您的 Pod！</strong></p>
<p>让我们从几种保护 Pod 本身的方法开始。一些 Pod 安全性的最佳实践包括：</p>
<ul>
<li>运行应用程序的容器不应具有 root 权限</li>
<li>容器应具有不可变的文件系统，这意味着它们不能被更改或添加（根据容器的用途，这可能是不可能的）</li>
<li>应经常扫描容器镜像以查找漏洞或错误配置</li>
<li>应防止特权容器</li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/security/pod-security-standards/">Pod 安全标准</a> 和 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/security/pod-security-admission/">Pod 安全准入</a></li>
</ul>
<p><strong>强化和分离您的网络！</strong></p>
<p>在这项任务的介绍中，有一件事特别被标记为一个巨大的安全风险：通信。该通信通过网络进行，作为 DevSecOps 工程师，您的工作就是确保此通信的安全。可以使用以下最佳实践来实现这一点：</p>
<ul>
<li>应使用防火墙和隔离网络中的基于角色的访问控制来限制对控制平面节点的访问</li>
<li>控制平面组件应使用传输层安全性 (TLS) 证书进行通信</li>
<li>应创建显式拒绝策略</li>
<li>凭据和敏感信息不应以纯文本形式存储在配置文件中。相反，它们应该被加密并存储在 Kubernetes 机密中</li>
</ul>
<p><strong>最佳地使用身份验证和授权</strong></p>
<p>如果我们不谈论身份验证和授权，那就不是安全课程了！Kubernetes 也不例外。以下是一些最佳实践，可帮助您确保高效使用 Kubernetes 身份验证和授权功能：</p>
<ul>
<li>应禁用匿名访问</li>
<li>应使用强用户身份验证</li>
<li>应为使用集群的各个团队和所使用的服务帐户创建 RBAC 策略</li>
</ul>
<p><strong>保持警惕</strong></p>
<p>如果您不知道 Kubernetes 集群中发生了什么，您就无法安心地知道 Kubernetes 集群是安全的。以下是一些日志记录最佳实践，可确保您确切了解集群中发生了什么，并能在威胁出现时检测到它们：</p>
<ul>
<li>应启用审计日志记录</li>
<li>应实施日志监控和警报系统</li>
</ul>
<p><strong>安全永不停歇</strong></p>
<p>这绝不是对不眠生活方式的认可；事实上，DevSecOps 工程师确实需要睡觉！安全是一回事，保持安全是另一回事。以下是一些确保您的集群保持安全状态的最佳实践：</p>
<ul>
<li>应快速应用安全补丁和更新</li>
<li>应定期进行漏洞扫描和渗透测试</li>
<li>应删除集群中任何过时的组件</li>
</ul>
<p>Kubernetes 安全最佳实践在行动</p>
<p>以上信息告诉我们，有很多方法可以强化 Kubernetes基础设施。事实上，有太多实践，分解每一项实践都会把这个房间变成一本自出版的电子书。有机会在完成一项任务后开始使用 Kubernetes，让我们通过分解其中三个来完成这项工作。</p>
<p><strong>RBAC</strong></p>
<p>Kubernetes 中的 RBAC（基于角色的访问控制）根据定义的角色和权限来规范对 Kubernetes 集群及其资源的访问。这些权限（创建/删除 x 资源等的权限）分配给用户、组或服务帐户。RBAC 是一种确保集群中的资源只能由<strong>需要</strong>访问它的人访问的好方法。可以使用 YAML 文件（与定义资源相同）配置 RBAC，其中可以通过声明资源类型和动词来定义特定规则。动词是受限制的操作，例如“创建”和“获取”。</p>
<p><strong>机密管理</strong></p>
<p>Kubernetes 机密是用于存储敏感信息（如凭证、OAuth 令牌或 SSH 密钥）的对象。机密是确保敏感数据不泄露并允许更好地控制这些信息使用方式的好方法。机密以 base64 编码字符串的形式存储，默认情况下未加密。为了安全起见，最好配置静态加密。在 Kubernetes 集群中促进安全机密管理的另一种方法是使用 RBAC 配置对机密的最小特权访问。</p>
<p><strong>PSA（Pod 安全准入）和 PSS（Pod 安全标准）</strong></p>
<p>Pod 安全标准用于在命名空间或集群范围级别上定义 3 个级别（特权、基线和受限）的安全策略。这些级别的含义：</p>
<ul>
<li>特权：这是一项几乎不受限制的策略（允许已知权限升级）</li>
<li>基线：这是一项最低限度限制的策略，将阻止已知权限升级（允许使用默认配置部署 Pod）</li>
<li>受限：此严格限制的策略遵循当前 Pod 强化最佳实践</li>
</ul>
<p>Pod 安全准入（使用 Pod 安全准入控制器）通过拦截 API 服务器请求并应用这些策略来执行这些 Pod 安全标准。</p>
<p><strong>注意：</strong>以前，PSA 和 PSS 的角色是使用 PSP（Pod 安全策略）来实现的；但是，从 Kubernetes v1.25 开始，这些已被删除。如果您偶然发现 PSP 正在进行一些课外 Kubernetes 安全研究，请避免混淆！</p>
<p>如您所见，强化 Kubernetes 集群需要做很多工作，足以让 DevSecOps 工程师忙个不停。这些是 Kubernetes 强化中涉及的一些最佳实践。 DevSecOps 工程师在遵循这些实践并利用自动安全检查等技术的同时，可以确保他们的 Kubernetes 环境免受网络威胁。</p>
<h1 id="Hands-on-with-Kubernetes"><a href="#Hands-on-with-Kubernetes" class="headerlink" title="Hands-on with Kubernetes"></a>Hands-on with Kubernetes</h1><p>第一阶段：探索</p>
<p>好的，我们开始吧？我们要做的第一件事是启动我们的 Minikube 集群。您可以通过在终端中运行以下命令来执行此操作（集群将需要几分钟才能启动）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">minikube start</span><br></pre></td></tr></tbody></table></figure>

<p>一旦集群启动，您就可以开始了！本指南将带您了解该集群，巩固课堂上教授的知识。话虽如此，您有一个 Kubernetes 集群可供使用，因此请随意探索集群并尝试您迄今为止学到的不同命令！</p>
<p>让我们看看哪些已经在运行，好吗？我们可以使用以下命令执行此操作（所有命名空间均使用 <code>-A</code>）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">kubectl get pods -A</span><br></pre></td></tr></tbody></table></figure>

<p>运行此命令后，您应该会看到一些正在运行的 Pod。这些是首次启动 Kubernetes 集群时默认存在的 Pod（您可能认识其中一些名称，因为它们代表一些控制平面和工作节点进程）。令人兴奋的东西！但是，我们如何通过添加部署和服务使其更令人兴奋？在虚拟机上，您将能够在此处找到一些配置 YAML 文件：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">~/Desktop/configuration</span><br></pre></td></tr></tbody></table></figure>

<p>这里有两个我们感兴趣的配置 YAML：<strong>nginx-deployment.yaml</strong> 和 <strong>nginx-service.yaml</strong>。使用 cat 命令检查这些配置文件：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">cat filename </span><br></pre></td></tr></tbody></table></figure>

<p>让我们分析一下每个文件中的内容：</p>
<p><strong>nginx-deployment.yaml</strong></p>
<p>这是一个相对简单的部署；我们可以看到所需状态已定义为单个副本 pod，其中将是一个运行 nginx 映像的容器。从其他行中，我们可以确定此 pod 将用于运行某种 Web 应用程序。</p>
<p><strong>nginx-service.yaml</strong></p>
<p>这又是一个在此处定义的简单 nginx NodePort 服务。眼尖的您可能已经注意到，“selector: -&gt; app: ”字段与部署中定义的 app 标签匹配，并且“targetPort”与部署中概述的“containerPort”匹配。此服务公开部署控制的 pod 中运行的 Web 应用程序。要应用这些 YAML 文件中概述的配置，我们使用 kubectl apply 命令。请记住先应用服务文件！如下所示：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">kubectl apply -f nginx-service.yaml</span><br><span class="line">kubectl apply -f nginx-deployment.yaml</span><br></pre></td></tr></tbody></table></figure>

<p>使用以下命令验证副本 pod 是否正在运行（不提供任何命名空间标志将获取默认命名空间中的所有 pod，这也是我们的 pod 应该所在的位置）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">kubectl get pods -A</span><br></pre></td></tr></tbody></table></figure>

<p>现在您应该会看到一个名称中带有“nginx-deployment”的 pod！我们的部署已启动！</p>
<p>第二阶段：交互</p>
<p>好的，现在我们有一个在 pod 中运行的 Web 应用程序，该应用程序由服务公开。如果您回想一下 nginx-service.yaml，该服务使用目标端口 80（容器公开的端口）连接到 Web 应用程序。但是，服务的端口本身设置为 8080。我们想要访问此服务。我们将使用 kubectl port-forward 命令来执行此操作，该命令允许我们将本地主机上的端口转发到 Kubernetes 服务端口（8080）。以下是执行此操作的完整命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">kubectl port-forward service/nginx-service 8090:8080</span><br></pre></td></tr></tbody></table></figure>

<p>运行此命令后，打开 Web 浏览器（Firefox）并通过以下地址访问 Web 应用程序：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">http://localhost:8090/</span><br></pre></td></tr></tbody></table></figure>

<p>看起来像一个简单的登录终端，但它需要凭证。为什么我们没有看到集群上是否有任何可以帮助我们登录终端的 Kubernetes 机密？打开另一个终端窗口（以便前一个窗口继续端口转发）并运行以下命令以查看是否有任何机密（在默认命名空间中）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">kubectl get secrets</span><br></pre></td></tr></tbody></table></figure>

<p>啊，有！“terminal-creds”听起来像是我们找到了赢家！使用 kubectl describe 命令，我们可以获取有关此机密的更多详细信息，以查看此处存储的内容：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">kubectl describe secret terminal-creds</span><br></pre></td></tr></tbody></table></figure>

<p>在描述中，我们可以看到存储了两部分“数据”：用户名和密码。虽然 Kubernetes 机密<strong>以</strong>纯文本形式存储且默认情况下未加密，但它们是 base64 编码的，因此我们通过管道传输此命令并对输出进行 base64 解码以获取纯文本。要访问此数据，我们可以使用以下命令：</p>
<p>要获取用户名，请运行：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">kubectl get secret terminal-creds -o jsonpath='{.data.username}'| base64 --decode</span><br></pre></td></tr></tbody></table></figure>

<p>要获取密码，请运行：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">kubectl get secret terminal-creds -o jsonpath='{.data.password}'| base64 --decode</span><br></pre></td></tr></tbody></table></figure>

<p>使用这些凭据访问登录终端。成功了！我们成功了，您已经检索到了标志！</p>
<p><strong>奖励任务：</strong>对于那些好奇心强的人，您可以使用另一种方法来获取此标志。这将需要您进行一些 Kubernetes 调查，但第一个线索位于 nginx-deployment.yaml 中！</p>
<p>第三阶段：安全</p>
<p>我们可以使用存储在 Kubernetes 机密中的凭据访问终端，这很棒，但作为 DevSecOps 工程师，我们应该在这里敲响警钟。是时候开始使用一些 Kubernetes 机密管理了。由于这些凭据是敏感信息，我们希望限制对存储它们的 Kubernetes 机密的访问。我们可以通过配置 RBAC（基于角色的访问控制）来实现这一点。</p>
<p>首先，让我们决定谁可以访问这个机密。您的 DevSecOps 经理建议您限制对服务帐户的访问，服务帐户本质上是 pod 可以假设与 Kubernetes API/集群交互的身份。通过这样做，我们甚至可以设置它，以便将来我们的日常终端任务可以由 pod 中的应用程序运行。让我们使用 kubectl create serviceaccount（可以缩写为“sa”）命令创建两个服务帐户，“terminal-user”用于非管理员终端活动（不应有权访问机密），“terminal-admin”用于管理员终端活动（应该有权访问机密）。运行这两个命令来创建这些服务帐户：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">kubectl create sa terminal-user</span><br><span class="line">kubectl create sa terminal-admin</span><br></pre></td></tr></tbody></table></figure>

<p>创建这些服务帐户后，就该限制对“terminal-creds”机密的访问，以便只有“terminal-admin”服务帐户可以访问它。我们将通过定义和应用两个配置来实现这一点。首先，定义角色及其功能的角色 YAML（获取“terminal-creds”机密）。然后，将我们定义的角色绑定到“terminal admin”服务帐户的角色绑定 YAML。导航到以下目录并 cat 这两个 YAML 以检查它们是如何定义的：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">~/Desktop/configuration/rbac</span><br></pre></td></tr></tbody></table></figure>

<p><strong>role.yaml</strong></p>
<p>在这里，您可以看到我们定义了一个名为“secret-admin”的角色。在规则部分，我们定义了这个角色可以做什么。我们定义了资源（secrets）、受限制的动词（我们限制了“get”动词，但您可以限制其他动词）以及最后，我们的秘密的名称（terminal-creds）。</p>
<p><strong>role-binding.yaml</strong></p>
<p>在此 YAML 中，我们将“terminal-admin”服务帐户（在“subjects”部分中）与上面定义的“secret-admin”角色（在 roleRef 部分中）绑定。</p>
<p>现在让我们以与应用部署和服务相同的方式应用这些配置（使用 kubectl apply）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">kubectl apply -f role.yaml</span><br><span class="line">kubectl apply -f role-binding.yaml</span><br></pre></td></tr></tbody></table></figure>

<p>现在您已为该 Kubernetes 机密配置了 RBAC！剩下要做的就是测试我们的 RBAC 是否正常工作。我们可以使用 kubectl auth 命令执行此操作，该命令告诉我们服务帐户是否具有足够的权限来执行特定操作。让我们首先验证常规“终端用户”服务帐户是否无法访问机密：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">kubectl auth can-i get secret/terminal-creds --as=system:serviceaccount:default:terminal-user</span><br></pre></td></tr></tbody></table></figure>

<p>看起来就像我们预期的那样。这个“否”响应确认此服务帐户不再能够访问终端凭据机密。现在，最后，让我们验证我们的“终端管理员”服务帐户是否可以访问它：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">kubectl auth can-i get secret/terminal-creds --as=system:serviceaccount:default:terminal-admin</span><br></pre></td></tr></tbody></table></figure>

<p>通过此“是”输出，您已确认 RBAC 已到位并履行了您作为 DevSecOps 工程师的职责，强化了集群并迈出了强化此集群的良好第一步。希望您喜欢参观这个 Kubernetes 集群并了解基础知识。下次见！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://mikannse.space">Mikannse</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://mikannse.space/2024/05/30/IntrotoKubernetesTHM/">http://mikannse.space/2024/05/30/IntrotoKubernetesTHM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://mikannse.space" target="_blank">MikannseのSekai</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="post-meta__tags" href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">渗透测试</a><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/31/%E6%89%93%E9%9D%B6%E8%AE%B0%E5%BD%95(%E4%B8%80%E4%B8%80%E4%BA%94)%E4%B9%8BTHMTryHack3M_Subscribe/" title="打靶记录(一一五)之THMTryHack3M_Subscribe"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">打靶记录(一一五)之THMTryHack3M_Subscribe</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/27/IntrotoLogAnalysisTHM/" title="IntrotoLogAnalysisTHM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">IntrotoLogAnalysisTHM</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/27/IntrotoLogAnalysisTHM/" title="IntrotoLogAnalysisTHM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-27</div><div class="title">IntrotoLogAnalysisTHM</div></div></a></div><div><a href="/2024/06/15/AdvancedSQLInjectionTHM/" title="AdvancedSQLInjectionTHM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-15</div><div class="title">AdvancedSQLInjectionTHM</div></div></a></div><div><a href="/2024/03/14/ContainerVulnerabilitiesTHM/" title="ContainerVulnerabilitiesTHM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-14</div><div class="title">ContainerVulnerabilitiesTHM</div></div></a></div><div><a href="/2023/11/17/Cross-Site%20Scripting%20(XSS)HTB/" title="Cross-Site Scripting (XSS)HTB"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-17</div><div class="title">Cross-Site Scripting (XSS)HTB</div></div></a></div><div><a href="/2023/10/24/HackingWordPressHTB/" title="HackingWordPressHTB"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-24</div><div class="title">HackingWordPressHTB</div></div></a></div><div><a href="/2024/04/02/IceTHM/" title="IceTHM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-02</div><div class="title">IceTHM</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/06/22/PMAjL6lORKa5CGy.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Mikannse</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">303</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">74</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mikannse/mikannse.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">暂时没有公告QAQ</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kubernetes-101"><span class="toc-number">2.</span> <span class="toc-text">Kubernetes 101</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kubernetes-Architecture"><span class="toc-number">3.</span> <span class="toc-text">Kubernetes Architecture</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kubernetes-Landscape"><span class="toc-number">4.</span> <span class="toc-text">Kubernetes Landscape</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kubernetes-Configuration"><span class="toc-number">5.</span> <span class="toc-text">Kubernetes Configuration</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kubectl"><span class="toc-number">6.</span> <span class="toc-text">Kubectl</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kubernetes-amp-DevSecOps"><span class="toc-number">7.</span> <span class="toc-text">Kubernetes &amp; DevSecOps</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hands-on-with-Kubernetes"><span class="toc-number">8.</span> <span class="toc-text">Hands-on with Kubernetes</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/15/THMWindowsEventLogs/" title="THMWindowsEventLogs">THMWindowsEventLogs</a><time datetime="2024-11-14T16:20:53.000Z" title="发表于 2024-11-15 00:20:53">2024-11-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/14/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%AC%AC%E5%9B%9B%E7%AB%A0/" title="玄机应急响应第四章">玄机应急响应第四章</a><time datetime="2024-11-14T12:39:37.000Z" title="发表于 2024-11-14 20:39:37">2024-11-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/14/THMIntrotoEndpointSecurity/" title="THMIntrotoEndpointSecurity">THMIntrotoEndpointSecurity</a><time datetime="2024-11-14T09:08:33.000Z" title="发表于 2024-11-14 17:08:33">2024-11-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/13/Python3%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80,%E4%BA%8C%E7%AB%A0%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E5%92%8C%E5%B8%B8%E7%94%A8%E5%BA%93/" title="Python3爬虫开发笔记第一,二章爬虫基础和常用库">Python3爬虫开发笔记第一,二章爬虫基础和常用库</a><time datetime="2024-11-13T13:46:32.000Z" title="发表于 2024-11-13 21:46:32">2024-11-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/12/THMDynamicAnalysisDebugging/" title="THMDynamicAnalysisDebugging">THMDynamicAnalysisDebugging</a><time datetime="2024-11-12T14:56:18.000Z" title="发表于 2024-11-12 22:56:18">2024-11-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/yjr-1100/Photobag/githubioimg/background_4k.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Mikannse</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  const disqus_config = function () {
    this.page.url = 'http://mikannse.space/2024/05/30/IntrotoKubernetesTHM/'
    this.page.identifier = '/2024/05/30/IntrotoKubernetesTHM/'
    this.page.title = 'IntrotoKubernetesTHM'
  }

  const disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addModeChange('disqus', disqusReset)

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>